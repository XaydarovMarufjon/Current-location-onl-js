
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: string
  username: string
  password: string
  refreshToken: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Employee
 * 
 */
export type Employee = {
  id: string
  fullName: string
  organization: string
  departmentId: string
  position: string
  email: string
  phone: string
  roleId: string
  photo: string
  userId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Department
 * 
 */
export type Department = {
  id: string
  name: string
  nameuz: string | null
  nameru: string | null
  listOrgId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SubDepartment
 * 
 */
export type SubDepartment = {
  id: string
  name: string
  nameuz: string | null
  nameru: string | null
  departmentId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Role
 * 
 */
export type Role = {
  id: string
  name: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Position
 * 
 */
export type Position = {
  id: string
  name: string
  nameuz: string | null
  nameru: string | null
  listOrgId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TypeIncident
 * 
 */
export type TypeIncident = {
  id: string
  name: string
  nameuz: string
  nameru: string
  code: string
  vector: string
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ListOrg
 * 
 */
export type ListOrg = {
  id: string
  name: string
  nameuz: string | null
  nameru: string | null
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Personal
 * 
 */
export type Personal = {
  id: string
  firstName: string
  middleName: string | null
  lastName: string
  phone: string | null
  email: string | null
  positionId: string
  listOrgId: string
  departmentId: string
  subDepartmentId: string | null
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model HotLine
 * 
 */
export type HotLine = {
  id: string
  date: Date
  fullName: string
  contact: string
  description: string
  answer: string
  employeeId: string
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ServiceSue
 * 
 */
export type ServiceSue = {
  id: string
  name: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TypeComputer
 * 
 */
export type TypeComputer = {
  id: string
  incidentTypes: string
  code: string
  vector: string
  nameuz: string
  nameru: string
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model AboutMeans
 * 
 */
export type AboutMeans = {
  id: string
  code: string
  toolDetails: string
  nameuz: string
  nameru: string
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SeverityLevel
 * 
 */
export type SeverityLevel = {
  id: string
  code: string
  severityLevel: string
  nameuz: string
  nameru: string
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SortForce
 * 
 */
export type SortForce = {
  id: string
  code: string
  incidentSeverity: string
  nameuz: string
  nameru: string
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SortGravity
 * 
 */
export type SortGravity = {
  id: string
  code: string
  incidentSeverity: string
  nameuz: string
  nameru: string
  creatorId: string | null
  editorId: string | null
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model MarkLimit
 * 
 */
export type MarkLimit = {
  id: string
  code: string
  privacySymbol: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model AttackedDomain
 * 
 */
export type AttackedDomain = {
  id: string
  hosting: string
  domainSupport: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model AttackedDomainUri
 * 
 */
export type AttackedDomainUri = {
  id: string
  code: string
  organizationWebsite: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model AttackedDomainEmail
 * 
 */
export type AttackedDomainEmail = {
  id: string
  code: string
  email: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model HarmfulDomain
 * 
 */
export type HarmfulDomain = {
  id: string
  hosting: string
  domainSupport: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model HarmfulDomainUri
 * 
 */
export type HarmfulDomainUri = {
  id: string
  code: string
  organizationWebsite: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model HarmfulDomainEmail
 * 
 */
export type HarmfulDomainEmail = {
  id: string
  code: string
  email: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Vulnerability
 * 
 */
export type Vulnerability = {
  id: string
  code: string
  cellPhone: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model AsDetected
 * 
 */
export type AsDetected = {
  id: string
  name: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model DetectedStatus
 * 
 */
export type DetectedStatus = {
  id: string
  name: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ImpactObject
 * 
 */
export type ImpactObject = {
  id: string
  code: string
  objectsInfluence: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TypeComponents
 * 
 */
export type TypeComponents = {
  id: string
  code: string
  name: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model GroupComponents
 * 
 */
export type GroupComponents = {
  id: string
  code: string
  nameGroup: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ImpactComponent
 * 
 */
export type ImpactComponent = {
  id: string
  code: string
  impactComponents: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Motivation
 * 
 */
export type Motivation = {
  id: string
  code: string
  hackerGroups: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model MethodViolator
 * 
 */
export type MethodViolator = {
  id: string
  techniqueCode: string
  nameTechnique: string
  MITRECode: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TacticsViolator
 * 
 */
export type TacticsViolator = {
  id: string
  code: string
  objectAttack: string
  stages: string
  description: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model TypicalThreat
 * 
 */
export type TypicalThreat = {
  id: string
  gangTools: string
  toolType: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ResGeography
 * 
 */
export type ResGeography = {
  id: string
  code: string
  geographicregions: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model CurrentStatus
 * 
 */
export type CurrentStatus = {
  id: string
  code: string
  nameStatus: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Confidentiality
 * 
 */
export type Confidentiality = {
  id: string
  code: string
  name: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model DamageFactors
 * 
 */
export type DamageFactors = {
  id: string
  code: string
  name: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model SubjectDamage
 * 
 */
export type SubjectDamage = {
  id: string
  code: string
  damage: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model EmployeeName
 * 
 */
export type EmployeeName = {
  id: string
  code: string
  fullName: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model EditEmployeeName
 * 
 */
export type EditEmployeeName = {
  id: string
  code: string
  fullName: string
  nameuz: string
  nameru: string
  creatorId: string
  editorId: string
  removerId: string | null
  createdAt: Date
  updatedAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<GlobalReject>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<GlobalReject>;

  /**
   * `prisma.subDepartment`: Exposes CRUD operations for the **SubDepartment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubDepartments
    * const subDepartments = await prisma.subDepartment.findMany()
    * ```
    */
  get subDepartment(): Prisma.SubDepartmentDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<GlobalReject>;

  /**
   * `prisma.typeIncident`: Exposes CRUD operations for the **TypeIncident** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeIncidents
    * const typeIncidents = await prisma.typeIncident.findMany()
    * ```
    */
  get typeIncident(): Prisma.TypeIncidentDelegate<GlobalReject>;

  /**
   * `prisma.listOrg`: Exposes CRUD operations for the **ListOrg** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListOrgs
    * const listOrgs = await prisma.listOrg.findMany()
    * ```
    */
  get listOrg(): Prisma.ListOrgDelegate<GlobalReject>;

  /**
   * `prisma.personal`: Exposes CRUD operations for the **Personal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Personals
    * const personals = await prisma.personal.findMany()
    * ```
    */
  get personal(): Prisma.PersonalDelegate<GlobalReject>;

  /**
   * `prisma.hotLine`: Exposes CRUD operations for the **HotLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotLines
    * const hotLines = await prisma.hotLine.findMany()
    * ```
    */
  get hotLine(): Prisma.HotLineDelegate<GlobalReject>;

  /**
   * `prisma.serviceSue`: Exposes CRUD operations for the **ServiceSue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSues
    * const serviceSues = await prisma.serviceSue.findMany()
    * ```
    */
  get serviceSue(): Prisma.ServiceSueDelegate<GlobalReject>;

  /**
   * `prisma.typeComputer`: Exposes CRUD operations for the **TypeComputer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeComputers
    * const typeComputers = await prisma.typeComputer.findMany()
    * ```
    */
  get typeComputer(): Prisma.TypeComputerDelegate<GlobalReject>;

  /**
   * `prisma.aboutMeans`: Exposes CRUD operations for the **AboutMeans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AboutMeans
    * const aboutMeans = await prisma.aboutMeans.findMany()
    * ```
    */
  get aboutMeans(): Prisma.AboutMeansDelegate<GlobalReject>;

  /**
   * `prisma.severityLevel`: Exposes CRUD operations for the **SeverityLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SeverityLevels
    * const severityLevels = await prisma.severityLevel.findMany()
    * ```
    */
  get severityLevel(): Prisma.SeverityLevelDelegate<GlobalReject>;

  /**
   * `prisma.sortForce`: Exposes CRUD operations for the **SortForce** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SortForces
    * const sortForces = await prisma.sortForce.findMany()
    * ```
    */
  get sortForce(): Prisma.SortForceDelegate<GlobalReject>;

  /**
   * `prisma.sortGravity`: Exposes CRUD operations for the **SortGravity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SortGravities
    * const sortGravities = await prisma.sortGravity.findMany()
    * ```
    */
  get sortGravity(): Prisma.SortGravityDelegate<GlobalReject>;

  /**
   * `prisma.markLimit`: Exposes CRUD operations for the **MarkLimit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarkLimits
    * const markLimits = await prisma.markLimit.findMany()
    * ```
    */
  get markLimit(): Prisma.MarkLimitDelegate<GlobalReject>;

  /**
   * `prisma.attackedDomain`: Exposes CRUD operations for the **AttackedDomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttackedDomains
    * const attackedDomains = await prisma.attackedDomain.findMany()
    * ```
    */
  get attackedDomain(): Prisma.AttackedDomainDelegate<GlobalReject>;

  /**
   * `prisma.attackedDomainUri`: Exposes CRUD operations for the **AttackedDomainUri** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttackedDomainUris
    * const attackedDomainUris = await prisma.attackedDomainUri.findMany()
    * ```
    */
  get attackedDomainUri(): Prisma.AttackedDomainUriDelegate<GlobalReject>;

  /**
   * `prisma.attackedDomainEmail`: Exposes CRUD operations for the **AttackedDomainEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttackedDomainEmails
    * const attackedDomainEmails = await prisma.attackedDomainEmail.findMany()
    * ```
    */
  get attackedDomainEmail(): Prisma.AttackedDomainEmailDelegate<GlobalReject>;

  /**
   * `prisma.harmfulDomain`: Exposes CRUD operations for the **HarmfulDomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HarmfulDomains
    * const harmfulDomains = await prisma.harmfulDomain.findMany()
    * ```
    */
  get harmfulDomain(): Prisma.HarmfulDomainDelegate<GlobalReject>;

  /**
   * `prisma.harmfulDomainUri`: Exposes CRUD operations for the **HarmfulDomainUri** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HarmfulDomainUris
    * const harmfulDomainUris = await prisma.harmfulDomainUri.findMany()
    * ```
    */
  get harmfulDomainUri(): Prisma.HarmfulDomainUriDelegate<GlobalReject>;

  /**
   * `prisma.harmfulDomainEmail`: Exposes CRUD operations for the **HarmfulDomainEmail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HarmfulDomainEmails
    * const harmfulDomainEmails = await prisma.harmfulDomainEmail.findMany()
    * ```
    */
  get harmfulDomainEmail(): Prisma.HarmfulDomainEmailDelegate<GlobalReject>;

  /**
   * `prisma.vulnerability`: Exposes CRUD operations for the **Vulnerability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vulnerabilities
    * const vulnerabilities = await prisma.vulnerability.findMany()
    * ```
    */
  get vulnerability(): Prisma.VulnerabilityDelegate<GlobalReject>;

  /**
   * `prisma.asDetected`: Exposes CRUD operations for the **AsDetected** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AsDetecteds
    * const asDetecteds = await prisma.asDetected.findMany()
    * ```
    */
  get asDetected(): Prisma.AsDetectedDelegate<GlobalReject>;

  /**
   * `prisma.detectedStatus`: Exposes CRUD operations for the **DetectedStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetectedStatuses
    * const detectedStatuses = await prisma.detectedStatus.findMany()
    * ```
    */
  get detectedStatus(): Prisma.DetectedStatusDelegate<GlobalReject>;

  /**
   * `prisma.impactObject`: Exposes CRUD operations for the **ImpactObject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImpactObjects
    * const impactObjects = await prisma.impactObject.findMany()
    * ```
    */
  get impactObject(): Prisma.ImpactObjectDelegate<GlobalReject>;

  /**
   * `prisma.typeComponents`: Exposes CRUD operations for the **TypeComponents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeComponents
    * const typeComponents = await prisma.typeComponents.findMany()
    * ```
    */
  get typeComponents(): Prisma.TypeComponentsDelegate<GlobalReject>;

  /**
   * `prisma.groupComponents`: Exposes CRUD operations for the **GroupComponents** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupComponents
    * const groupComponents = await prisma.groupComponents.findMany()
    * ```
    */
  get groupComponents(): Prisma.GroupComponentsDelegate<GlobalReject>;

  /**
   * `prisma.impactComponent`: Exposes CRUD operations for the **ImpactComponent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImpactComponents
    * const impactComponents = await prisma.impactComponent.findMany()
    * ```
    */
  get impactComponent(): Prisma.ImpactComponentDelegate<GlobalReject>;

  /**
   * `prisma.motivation`: Exposes CRUD operations for the **Motivation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motivations
    * const motivations = await prisma.motivation.findMany()
    * ```
    */
  get motivation(): Prisma.MotivationDelegate<GlobalReject>;

  /**
   * `prisma.methodViolator`: Exposes CRUD operations for the **MethodViolator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MethodViolators
    * const methodViolators = await prisma.methodViolator.findMany()
    * ```
    */
  get methodViolator(): Prisma.MethodViolatorDelegate<GlobalReject>;

  /**
   * `prisma.tacticsViolator`: Exposes CRUD operations for the **TacticsViolator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TacticsViolators
    * const tacticsViolators = await prisma.tacticsViolator.findMany()
    * ```
    */
  get tacticsViolator(): Prisma.TacticsViolatorDelegate<GlobalReject>;

  /**
   * `prisma.typicalThreat`: Exposes CRUD operations for the **TypicalThreat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypicalThreats
    * const typicalThreats = await prisma.typicalThreat.findMany()
    * ```
    */
  get typicalThreat(): Prisma.TypicalThreatDelegate<GlobalReject>;

  /**
   * `prisma.resGeography`: Exposes CRUD operations for the **ResGeography** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResGeographies
    * const resGeographies = await prisma.resGeography.findMany()
    * ```
    */
  get resGeography(): Prisma.ResGeographyDelegate<GlobalReject>;

  /**
   * `prisma.currentStatus`: Exposes CRUD operations for the **CurrentStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CurrentStatuses
    * const currentStatuses = await prisma.currentStatus.findMany()
    * ```
    */
  get currentStatus(): Prisma.CurrentStatusDelegate<GlobalReject>;

  /**
   * `prisma.confidentiality`: Exposes CRUD operations for the **Confidentiality** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Confidentialities
    * const confidentialities = await prisma.confidentiality.findMany()
    * ```
    */
  get confidentiality(): Prisma.ConfidentialityDelegate<GlobalReject>;

  /**
   * `prisma.damageFactors`: Exposes CRUD operations for the **DamageFactors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DamageFactors
    * const damageFactors = await prisma.damageFactors.findMany()
    * ```
    */
  get damageFactors(): Prisma.DamageFactorsDelegate<GlobalReject>;

  /**
   * `prisma.subjectDamage`: Exposes CRUD operations for the **SubjectDamage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubjectDamages
    * const subjectDamages = await prisma.subjectDamage.findMany()
    * ```
    */
  get subjectDamage(): Prisma.SubjectDamageDelegate<GlobalReject>;

  /**
   * `prisma.employeeName`: Exposes CRUD operations for the **EmployeeName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeNames
    * const employeeNames = await prisma.employeeName.findMany()
    * ```
    */
  get employeeName(): Prisma.EmployeeNameDelegate<GlobalReject>;

  /**
   * `prisma.editEmployeeName`: Exposes CRUD operations for the **EditEmployeeName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EditEmployeeNames
    * const editEmployeeNames = await prisma.editEmployeeName.findMany()
    * ```
    */
  get editEmployeeName(): Prisma.EditEmployeeNameDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.10.1
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Employee: 'Employee',
    Department: 'Department',
    SubDepartment: 'SubDepartment',
    Role: 'Role',
    Position: 'Position',
    TypeIncident: 'TypeIncident',
    ListOrg: 'ListOrg',
    Personal: 'Personal',
    HotLine: 'HotLine',
    ServiceSue: 'ServiceSue',
    TypeComputer: 'TypeComputer',
    AboutMeans: 'AboutMeans',
    SeverityLevel: 'SeverityLevel',
    SortForce: 'SortForce',
    SortGravity: 'SortGravity',
    MarkLimit: 'MarkLimit',
    AttackedDomain: 'AttackedDomain',
    AttackedDomainUri: 'AttackedDomainUri',
    AttackedDomainEmail: 'AttackedDomainEmail',
    HarmfulDomain: 'HarmfulDomain',
    HarmfulDomainUri: 'HarmfulDomainUri',
    HarmfulDomainEmail: 'HarmfulDomainEmail',
    Vulnerability: 'Vulnerability',
    AsDetected: 'AsDetected',
    DetectedStatus: 'DetectedStatus',
    ImpactObject: 'ImpactObject',
    TypeComponents: 'TypeComponents',
    GroupComponents: 'GroupComponents',
    ImpactComponent: 'ImpactComponent',
    Motivation: 'Motivation',
    MethodViolator: 'MethodViolator',
    TacticsViolator: 'TacticsViolator',
    TypicalThreat: 'TypicalThreat',
    ResGeography: 'ResGeography',
    CurrentStatus: 'CurrentStatus',
    Confidentiality: 'Confidentiality',
    DamageFactors: 'DamageFactors',
    SubjectDamage: 'SubjectDamage',
    EmployeeName: 'EmployeeName',
    EditEmployeeName: 'EditEmployeeName'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DepartmentCountOutputType
   */


  export type DepartmentCountOutputType = {
    employee: number
    personal: number
    subdepartment: number
  }

  export type DepartmentCountOutputTypeSelect = {
    employee?: boolean
    personal?: boolean
    subdepartment?: boolean
  }

  export type DepartmentCountOutputTypeGetPayload<S extends boolean | null | undefined | DepartmentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DepartmentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DepartmentCountOutputTypeArgs)
    ? DepartmentCountOutputType 
    : S extends { select: any } & (DepartmentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DepartmentCountOutputType ? DepartmentCountOutputType[P] : never
  } 
      : DepartmentCountOutputType




  // Custom InputTypes

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect | null
  }



  /**
   * Count Type SubDepartmentCountOutputType
   */


  export type SubDepartmentCountOutputType = {
    personal: number
  }

  export type SubDepartmentCountOutputTypeSelect = {
    personal?: boolean
  }

  export type SubDepartmentCountOutputTypeGetPayload<S extends boolean | null | undefined | SubDepartmentCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubDepartmentCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SubDepartmentCountOutputTypeArgs)
    ? SubDepartmentCountOutputType 
    : S extends { select: any } & (SubDepartmentCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SubDepartmentCountOutputType ? SubDepartmentCountOutputType[P] : never
  } 
      : SubDepartmentCountOutputType




  // Custom InputTypes

  /**
   * SubDepartmentCountOutputType without action
   */
  export type SubDepartmentCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SubDepartmentCountOutputType
     */
    select?: SubDepartmentCountOutputTypeSelect | null
  }



  /**
   * Count Type RoleCountOutputType
   */


  export type RoleCountOutputType = {
    employee: number
  }

  export type RoleCountOutputTypeSelect = {
    employee?: boolean
  }

  export type RoleCountOutputTypeGetPayload<S extends boolean | null | undefined | RoleCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? RoleCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (RoleCountOutputTypeArgs)
    ? RoleCountOutputType 
    : S extends { select: any } & (RoleCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof RoleCountOutputType ? RoleCountOutputType[P] : never
  } 
      : RoleCountOutputType




  // Custom InputTypes

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect | null
  }



  /**
   * Count Type PositionCountOutputType
   */


  export type PositionCountOutputType = {
    personal: number
  }

  export type PositionCountOutputTypeSelect = {
    personal?: boolean
  }

  export type PositionCountOutputTypeGetPayload<S extends boolean | null | undefined | PositionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PositionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PositionCountOutputTypeArgs)
    ? PositionCountOutputType 
    : S extends { select: any } & (PositionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PositionCountOutputType ? PositionCountOutputType[P] : never
  } 
      : PositionCountOutputType




  // Custom InputTypes

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect | null
  }



  /**
   * Count Type ListOrgCountOutputType
   */


  export type ListOrgCountOutputType = {
    department: number
    personal: number
    position: number
  }

  export type ListOrgCountOutputTypeSelect = {
    department?: boolean
    personal?: boolean
    position?: boolean
  }

  export type ListOrgCountOutputTypeGetPayload<S extends boolean | null | undefined | ListOrgCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ListOrgCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ListOrgCountOutputTypeArgs)
    ? ListOrgCountOutputType 
    : S extends { select: any } & (ListOrgCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ListOrgCountOutputType ? ListOrgCountOutputType[P] : never
  } 
      : ListOrgCountOutputType




  // Custom InputTypes

  /**
   * ListOrgCountOutputType without action
   */
  export type ListOrgCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ListOrgCountOutputType
     */
    select?: ListOrgCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    refreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    refreshToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    password: number
    refreshToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    refreshToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    username: string
    password: string
    refreshToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    username?: boolean
    password?: boolean
    refreshToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeArgs
  }


  export type UserInclude = {
    employee?: boolean | EmployeeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'employee' ? EmployeeGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'employee' ? EmployeeGetPayload<S['select'][P]> | null :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    employee<T extends EmployeeArgs= {}>(args?: Subset<T, EmployeeArgs>): Prisma__EmployeeClient<EmployeeGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Employee
   */


  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    organization: string | null
    departmentId: string | null
    position: string | null
    email: string | null
    phone: string | null
    roleId: string | null
    photo: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    organization: string | null
    departmentId: string | null
    position: string | null
    email: string | null
    phone: string | null
    roleId: string | null
    photo: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    fullName: number
    organization: number
    departmentId: number
    position: number
    email: number
    phone: number
    roleId: number
    photo: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    fullName?: true
    organization?: true
    departmentId?: true
    position?: true
    email?: true
    phone?: true
    roleId?: true
    photo?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    fullName?: true
    organization?: true
    departmentId?: true
    position?: true
    email?: true
    phone?: true
    roleId?: true
    photo?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    fullName?: true
    organization?: true
    departmentId?: true
    position?: true
    email?: true
    phone?: true
    roleId?: true
    photo?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs = {
    where?: EmployeeWhereInput
    orderBy?: Enumerable<EmployeeOrderByWithAggregationInput>
    by: EmployeeScalarFieldEnum[]
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }


  export type EmployeeGroupByOutputType = {
    id: string
    fullName: string
    organization: string
    departmentId: string
    position: string
    email: string
    phone: string
    roleId: string
    photo: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect = {
    id?: boolean
    fullName?: boolean
    organization?: boolean
    departmentId?: boolean
    position?: boolean
    email?: boolean
    phone?: boolean
    roleId?: boolean
    photo?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentArgs
    role?: boolean | RoleArgs
    user?: boolean | UserArgs
  }


  export type EmployeeInclude = {
    department?: boolean | DepartmentArgs
    role?: boolean | RoleArgs
    user?: boolean | UserArgs
  }

  export type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Employee :
    S extends undefined ? never :
    S extends { include: any } & (EmployeeArgs | EmployeeFindManyArgs)
    ? Employee  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'department' ? DepartmentGetPayload<S['include'][P]> :
        P extends 'role' ? RoleGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (EmployeeArgs | EmployeeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'department' ? DepartmentGetPayload<S['select'][P]> :
        P extends 'role' ? RoleGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Employee ? Employee[P] : never
  } 
      : Employee


  type EmployeeCountArgs = 
    Omit<EmployeeFindManyArgs, 'select' | 'include'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmployeeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmployeeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Employee'> extends True ? Prisma__EmployeeClient<EmployeeGetPayload<T>> : Prisma__EmployeeClient<EmployeeGetPayload<T> | null, null>

    /**
     * Find one Employee that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EmployeeFindUniqueOrThrowArgs>
    ): Prisma__EmployeeClient<EmployeeGetPayload<T>>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmployeeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmployeeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Employee'> extends True ? Prisma__EmployeeClient<EmployeeGetPayload<T>> : Prisma__EmployeeClient<EmployeeGetPayload<T> | null, null>

    /**
     * Find the first Employee that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs>
    ): Prisma__EmployeeClient<EmployeeGetPayload<T>>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmployeeFindManyArgs>(
      args?: SelectSubset<T, EmployeeFindManyArgs>
    ): Prisma.PrismaPromise<Array<EmployeeGetPayload<T>>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
    **/
    create<T extends EmployeeCreateArgs>(
      args: SelectSubset<T, EmployeeCreateArgs>
    ): Prisma__EmployeeClient<EmployeeGetPayload<T>>

    /**
     * Create many Employees.
     *     @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     *     @example
     *     // Create many Employees
     *     const employee = await prisma.employee.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmployeeCreateManyArgs>(
      args?: SelectSubset<T, EmployeeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
    **/
    delete<T extends EmployeeDeleteArgs>(
      args: SelectSubset<T, EmployeeDeleteArgs>
    ): Prisma__EmployeeClient<EmployeeGetPayload<T>>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmployeeUpdateArgs>(
      args: SelectSubset<T, EmployeeUpdateArgs>
    ): Prisma__EmployeeClient<EmployeeGetPayload<T>>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmployeeDeleteManyArgs>(
      args?: SelectSubset<T, EmployeeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmployeeUpdateManyArgs>(
      args: SelectSubset<T, EmployeeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
    **/
    upsert<T extends EmployeeUpsertArgs>(
      args: SelectSubset<T, EmployeeUpsertArgs>
    ): Prisma__EmployeeClient<EmployeeGetPayload<T>>

    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmployeeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    department<T extends DepartmentArgs= {}>(args?: Subset<T, DepartmentArgs>): Prisma__DepartmentClient<DepartmentGetPayload<T> | Null>;

    role<T extends RoleArgs= {}>(args?: Subset<T, RoleArgs>): Prisma__RoleClient<RoleGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Employee base type for findUnique actions
   */
  export type EmployeeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUnique
   */
  export interface EmployeeFindUniqueArgs extends EmployeeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee base type for findFirst actions
   */
  export type EmployeeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }

  /**
   * Employee findFirst
   */
  export interface EmployeeFindFirstArgs extends EmployeeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Employee create
   */
  export type EmployeeCreateArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }


  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs = {
    /**
     * The data used to create many Employees.
     */
    data: Enumerable<EmployeeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Employee update
   */
  export type EmployeeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }


  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }


  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }


  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }


  /**
   * Employee without action
   */
  export type EmployeeArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
  }



  /**
   * Model Department
   */


  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    listOrgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    listOrgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    nameuz: number
    nameru: number
    listOrgId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    listOrgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    listOrgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    listOrgId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: Enumerable<DepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs = {
    where?: DepartmentWhereInput
    orderBy?: Enumerable<DepartmentOrderByWithAggregationInput>
    by: DepartmentScalarFieldEnum[]
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }


  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    nameuz: string | null
    nameru: string | null
    listOrgId: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect = {
    id?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    listOrgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listOrg?: boolean | ListOrgArgs
    employee?: boolean | Department$employeeArgs
    personal?: boolean | Department$personalArgs
    subdepartment?: boolean | Department$subdepartmentArgs
    _count?: boolean | DepartmentCountOutputTypeArgs
  }


  export type DepartmentInclude = {
    listOrg?: boolean | ListOrgArgs
    employee?: boolean | Department$employeeArgs
    personal?: boolean | Department$personalArgs
    subdepartment?: boolean | Department$subdepartmentArgs
    _count?: boolean | DepartmentCountOutputTypeArgs
  }

  export type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Department :
    S extends undefined ? never :
    S extends { include: any } & (DepartmentArgs | DepartmentFindManyArgs)
    ? Department  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'listOrg' ? ListOrgGetPayload<S['include'][P]> :
        P extends 'employee' ? Array < EmployeeGetPayload<S['include'][P]>>  :
        P extends 'personal' ? Array < PersonalGetPayload<S['include'][P]>>  :
        P extends 'subdepartment' ? Array < SubDepartmentGetPayload<S['include'][P]>>  :
        P extends '_count' ? DepartmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DepartmentArgs | DepartmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'listOrg' ? ListOrgGetPayload<S['select'][P]> :
        P extends 'employee' ? Array < EmployeeGetPayload<S['select'][P]>>  :
        P extends 'personal' ? Array < PersonalGetPayload<S['select'][P]>>  :
        P extends 'subdepartment' ? Array < SubDepartmentGetPayload<S['select'][P]>>  :
        P extends '_count' ? DepartmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Department ? Department[P] : never
  } 
      : Department


  type DepartmentCountArgs = 
    Omit<DepartmentFindManyArgs, 'select' | 'include'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DepartmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DepartmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Department'> extends True ? Prisma__DepartmentClient<DepartmentGetPayload<T>> : Prisma__DepartmentClient<DepartmentGetPayload<T> | null, null>

    /**
     * Find one Department that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DepartmentFindUniqueOrThrowArgs>
    ): Prisma__DepartmentClient<DepartmentGetPayload<T>>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DepartmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DepartmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Department'> extends True ? Prisma__DepartmentClient<DepartmentGetPayload<T>> : Prisma__DepartmentClient<DepartmentGetPayload<T> | null, null>

    /**
     * Find the first Department that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs>
    ): Prisma__DepartmentClient<DepartmentGetPayload<T>>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DepartmentFindManyArgs>(
      args?: SelectSubset<T, DepartmentFindManyArgs>
    ): Prisma.PrismaPromise<Array<DepartmentGetPayload<T>>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
    **/
    create<T extends DepartmentCreateArgs>(
      args: SelectSubset<T, DepartmentCreateArgs>
    ): Prisma__DepartmentClient<DepartmentGetPayload<T>>

    /**
     * Create many Departments.
     *     @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     *     @example
     *     // Create many Departments
     *     const department = await prisma.department.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DepartmentCreateManyArgs>(
      args?: SelectSubset<T, DepartmentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
    **/
    delete<T extends DepartmentDeleteArgs>(
      args: SelectSubset<T, DepartmentDeleteArgs>
    ): Prisma__DepartmentClient<DepartmentGetPayload<T>>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DepartmentUpdateArgs>(
      args: SelectSubset<T, DepartmentUpdateArgs>
    ): Prisma__DepartmentClient<DepartmentGetPayload<T>>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DepartmentDeleteManyArgs>(
      args?: SelectSubset<T, DepartmentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DepartmentUpdateManyArgs>(
      args: SelectSubset<T, DepartmentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
    **/
    upsert<T extends DepartmentUpsertArgs>(
      args: SelectSubset<T, DepartmentUpsertArgs>
    ): Prisma__DepartmentClient<DepartmentGetPayload<T>>

    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DepartmentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    listOrg<T extends ListOrgArgs= {}>(args?: Subset<T, ListOrgArgs>): Prisma__ListOrgClient<ListOrgGetPayload<T> | Null>;

    employee<T extends Department$employeeArgs= {}>(args?: Subset<T, Department$employeeArgs>): Prisma.PrismaPromise<Array<EmployeeGetPayload<T>>| Null>;

    personal<T extends Department$personalArgs= {}>(args?: Subset<T, Department$personalArgs>): Prisma.PrismaPromise<Array<PersonalGetPayload<T>>| Null>;

    subdepartment<T extends Department$subdepartmentArgs= {}>(args?: Subset<T, Department$subdepartmentArgs>): Prisma.PrismaPromise<Array<SubDepartmentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Department base type for findUnique actions
   */
  export type DepartmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUnique
   */
  export interface DepartmentFindUniqueArgs extends DepartmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department base type for findFirst actions
   */
  export type DepartmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: Enumerable<DepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }

  /**
   * Department findFirst
   */
  export interface DepartmentFindFirstArgs extends DepartmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: Enumerable<DepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: Enumerable<DepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * Department create
   */
  export type DepartmentCreateArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }


  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs = {
    /**
     * The data used to create many Departments.
     */
    data: Enumerable<DepartmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Department update
   */
  export type DepartmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }


  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }


  /**
   * Department delete
   */
  export type DepartmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }


  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }


  /**
   * Department.employee
   */
  export type Department$employeeArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    where?: EmployeeWhereInput
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Department.personal
   */
  export type Department$personalArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    where?: PersonalWhereInput
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    cursor?: PersonalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * Department.subdepartment
   */
  export type Department$subdepartmentArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    where?: SubDepartmentWhereInput
    orderBy?: Enumerable<SubDepartmentOrderByWithRelationInput>
    cursor?: SubDepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubDepartmentScalarFieldEnum>
  }


  /**
   * Department without action
   */
  export type DepartmentArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
  }



  /**
   * Model SubDepartment
   */


  export type AggregateSubDepartment = {
    _count: SubDepartmentCountAggregateOutputType | null
    _min: SubDepartmentMinAggregateOutputType | null
    _max: SubDepartmentMaxAggregateOutputType | null
  }

  export type SubDepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubDepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubDepartmentCountAggregateOutputType = {
    id: number
    name: number
    nameuz: number
    nameru: number
    departmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubDepartmentMinAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubDepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubDepartmentCountAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubDepartmentAggregateArgs = {
    /**
     * Filter which SubDepartment to aggregate.
     */
    where?: SubDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubDepartments to fetch.
     */
    orderBy?: Enumerable<SubDepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubDepartments
    **/
    _count?: true | SubDepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubDepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubDepartmentMaxAggregateInputType
  }

  export type GetSubDepartmentAggregateType<T extends SubDepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSubDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubDepartment[P]>
      : GetScalarType<T[P], AggregateSubDepartment[P]>
  }




  export type SubDepartmentGroupByArgs = {
    where?: SubDepartmentWhereInput
    orderBy?: Enumerable<SubDepartmentOrderByWithAggregationInput>
    by: SubDepartmentScalarFieldEnum[]
    having?: SubDepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubDepartmentCountAggregateInputType | true
    _min?: SubDepartmentMinAggregateInputType
    _max?: SubDepartmentMaxAggregateInputType
  }


  export type SubDepartmentGroupByOutputType = {
    id: string
    name: string
    nameuz: string | null
    nameru: string | null
    departmentId: string
    createdAt: Date
    updatedAt: Date
    _count: SubDepartmentCountAggregateOutputType | null
    _min: SubDepartmentMinAggregateOutputType | null
    _max: SubDepartmentMaxAggregateOutputType | null
  }

  type GetSubDepartmentGroupByPayload<T extends SubDepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubDepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubDepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubDepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], SubDepartmentGroupByOutputType[P]>
        }
      >
    >


  export type SubDepartmentSelect = {
    id?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personal?: boolean | SubDepartment$personalArgs
    department?: boolean | DepartmentArgs
    _count?: boolean | SubDepartmentCountOutputTypeArgs
  }


  export type SubDepartmentInclude = {
    personal?: boolean | SubDepartment$personalArgs
    department?: boolean | DepartmentArgs
    _count?: boolean | SubDepartmentCountOutputTypeArgs
  }

  export type SubDepartmentGetPayload<S extends boolean | null | undefined | SubDepartmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubDepartment :
    S extends undefined ? never :
    S extends { include: any } & (SubDepartmentArgs | SubDepartmentFindManyArgs)
    ? SubDepartment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personal' ? Array < PersonalGetPayload<S['include'][P]>>  :
        P extends 'department' ? DepartmentGetPayload<S['include'][P]> :
        P extends '_count' ? SubDepartmentCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SubDepartmentArgs | SubDepartmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personal' ? Array < PersonalGetPayload<S['select'][P]>>  :
        P extends 'department' ? DepartmentGetPayload<S['select'][P]> :
        P extends '_count' ? SubDepartmentCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof SubDepartment ? SubDepartment[P] : never
  } 
      : SubDepartment


  type SubDepartmentCountArgs = 
    Omit<SubDepartmentFindManyArgs, 'select' | 'include'> & {
      select?: SubDepartmentCountAggregateInputType | true
    }

  export interface SubDepartmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SubDepartment that matches the filter.
     * @param {SubDepartmentFindUniqueArgs} args - Arguments to find a SubDepartment
     * @example
     * // Get one SubDepartment
     * const subDepartment = await prisma.subDepartment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubDepartmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubDepartmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubDepartment'> extends True ? Prisma__SubDepartmentClient<SubDepartmentGetPayload<T>> : Prisma__SubDepartmentClient<SubDepartmentGetPayload<T> | null, null>

    /**
     * Find one SubDepartment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubDepartmentFindUniqueOrThrowArgs} args - Arguments to find a SubDepartment
     * @example
     * // Get one SubDepartment
     * const subDepartment = await prisma.subDepartment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubDepartmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubDepartmentFindUniqueOrThrowArgs>
    ): Prisma__SubDepartmentClient<SubDepartmentGetPayload<T>>

    /**
     * Find the first SubDepartment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDepartmentFindFirstArgs} args - Arguments to find a SubDepartment
     * @example
     * // Get one SubDepartment
     * const subDepartment = await prisma.subDepartment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubDepartmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubDepartmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubDepartment'> extends True ? Prisma__SubDepartmentClient<SubDepartmentGetPayload<T>> : Prisma__SubDepartmentClient<SubDepartmentGetPayload<T> | null, null>

    /**
     * Find the first SubDepartment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDepartmentFindFirstOrThrowArgs} args - Arguments to find a SubDepartment
     * @example
     * // Get one SubDepartment
     * const subDepartment = await prisma.subDepartment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubDepartmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubDepartmentFindFirstOrThrowArgs>
    ): Prisma__SubDepartmentClient<SubDepartmentGetPayload<T>>

    /**
     * Find zero or more SubDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDepartmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubDepartments
     * const subDepartments = await prisma.subDepartment.findMany()
     * 
     * // Get first 10 SubDepartments
     * const subDepartments = await prisma.subDepartment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subDepartmentWithIdOnly = await prisma.subDepartment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubDepartmentFindManyArgs>(
      args?: SelectSubset<T, SubDepartmentFindManyArgs>
    ): Prisma.PrismaPromise<Array<SubDepartmentGetPayload<T>>>

    /**
     * Create a SubDepartment.
     * @param {SubDepartmentCreateArgs} args - Arguments to create a SubDepartment.
     * @example
     * // Create one SubDepartment
     * const SubDepartment = await prisma.subDepartment.create({
     *   data: {
     *     // ... data to create a SubDepartment
     *   }
     * })
     * 
    **/
    create<T extends SubDepartmentCreateArgs>(
      args: SelectSubset<T, SubDepartmentCreateArgs>
    ): Prisma__SubDepartmentClient<SubDepartmentGetPayload<T>>

    /**
     * Create many SubDepartments.
     *     @param {SubDepartmentCreateManyArgs} args - Arguments to create many SubDepartments.
     *     @example
     *     // Create many SubDepartments
     *     const subDepartment = await prisma.subDepartment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubDepartmentCreateManyArgs>(
      args?: SelectSubset<T, SubDepartmentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubDepartment.
     * @param {SubDepartmentDeleteArgs} args - Arguments to delete one SubDepartment.
     * @example
     * // Delete one SubDepartment
     * const SubDepartment = await prisma.subDepartment.delete({
     *   where: {
     *     // ... filter to delete one SubDepartment
     *   }
     * })
     * 
    **/
    delete<T extends SubDepartmentDeleteArgs>(
      args: SelectSubset<T, SubDepartmentDeleteArgs>
    ): Prisma__SubDepartmentClient<SubDepartmentGetPayload<T>>

    /**
     * Update one SubDepartment.
     * @param {SubDepartmentUpdateArgs} args - Arguments to update one SubDepartment.
     * @example
     * // Update one SubDepartment
     * const subDepartment = await prisma.subDepartment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubDepartmentUpdateArgs>(
      args: SelectSubset<T, SubDepartmentUpdateArgs>
    ): Prisma__SubDepartmentClient<SubDepartmentGetPayload<T>>

    /**
     * Delete zero or more SubDepartments.
     * @param {SubDepartmentDeleteManyArgs} args - Arguments to filter SubDepartments to delete.
     * @example
     * // Delete a few SubDepartments
     * const { count } = await prisma.subDepartment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubDepartmentDeleteManyArgs>(
      args?: SelectSubset<T, SubDepartmentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubDepartments
     * const subDepartment = await prisma.subDepartment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubDepartmentUpdateManyArgs>(
      args: SelectSubset<T, SubDepartmentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubDepartment.
     * @param {SubDepartmentUpsertArgs} args - Arguments to update or create a SubDepartment.
     * @example
     * // Update or create a SubDepartment
     * const subDepartment = await prisma.subDepartment.upsert({
     *   create: {
     *     // ... data to create a SubDepartment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubDepartment we want to update
     *   }
     * })
    **/
    upsert<T extends SubDepartmentUpsertArgs>(
      args: SelectSubset<T, SubDepartmentUpsertArgs>
    ): Prisma__SubDepartmentClient<SubDepartmentGetPayload<T>>

    /**
     * Count the number of SubDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDepartmentCountArgs} args - Arguments to filter SubDepartments to count.
     * @example
     * // Count the number of SubDepartments
     * const count = await prisma.subDepartment.count({
     *   where: {
     *     // ... the filter for the SubDepartments we want to count
     *   }
     * })
    **/
    count<T extends SubDepartmentCountArgs>(
      args?: Subset<T, SubDepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubDepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubDepartmentAggregateArgs>(args: Subset<T, SubDepartmentAggregateArgs>): Prisma.PrismaPromise<GetSubDepartmentAggregateType<T>>

    /**
     * Group by SubDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubDepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubDepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubDepartmentGroupByArgs['orderBy'] }
        : { orderBy?: SubDepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubDepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubDepartment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubDepartmentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personal<T extends SubDepartment$personalArgs= {}>(args?: Subset<T, SubDepartment$personalArgs>): Prisma.PrismaPromise<Array<PersonalGetPayload<T>>| Null>;

    department<T extends DepartmentArgs= {}>(args?: Subset<T, DepartmentArgs>): Prisma__DepartmentClient<DepartmentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubDepartment base type for findUnique actions
   */
  export type SubDepartmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * Filter, which SubDepartment to fetch.
     */
    where: SubDepartmentWhereUniqueInput
  }

  /**
   * SubDepartment findUnique
   */
  export interface SubDepartmentFindUniqueArgs extends SubDepartmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubDepartment findUniqueOrThrow
   */
  export type SubDepartmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * Filter, which SubDepartment to fetch.
     */
    where: SubDepartmentWhereUniqueInput
  }


  /**
   * SubDepartment base type for findFirst actions
   */
  export type SubDepartmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * Filter, which SubDepartment to fetch.
     */
    where?: SubDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubDepartments to fetch.
     */
    orderBy?: Enumerable<SubDepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubDepartments.
     */
    cursor?: SubDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubDepartments.
     */
    distinct?: Enumerable<SubDepartmentScalarFieldEnum>
  }

  /**
   * SubDepartment findFirst
   */
  export interface SubDepartmentFindFirstArgs extends SubDepartmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubDepartment findFirstOrThrow
   */
  export type SubDepartmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * Filter, which SubDepartment to fetch.
     */
    where?: SubDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubDepartments to fetch.
     */
    orderBy?: Enumerable<SubDepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubDepartments.
     */
    cursor?: SubDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubDepartments.
     */
    distinct?: Enumerable<SubDepartmentScalarFieldEnum>
  }


  /**
   * SubDepartment findMany
   */
  export type SubDepartmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * Filter, which SubDepartments to fetch.
     */
    where?: SubDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubDepartments to fetch.
     */
    orderBy?: Enumerable<SubDepartmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubDepartments.
     */
    cursor?: SubDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubDepartments.
     */
    skip?: number
    distinct?: Enumerable<SubDepartmentScalarFieldEnum>
  }


  /**
   * SubDepartment create
   */
  export type SubDepartmentCreateArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * The data needed to create a SubDepartment.
     */
    data: XOR<SubDepartmentCreateInput, SubDepartmentUncheckedCreateInput>
  }


  /**
   * SubDepartment createMany
   */
  export type SubDepartmentCreateManyArgs = {
    /**
     * The data used to create many SubDepartments.
     */
    data: Enumerable<SubDepartmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubDepartment update
   */
  export type SubDepartmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * The data needed to update a SubDepartment.
     */
    data: XOR<SubDepartmentUpdateInput, SubDepartmentUncheckedUpdateInput>
    /**
     * Choose, which SubDepartment to update.
     */
    where: SubDepartmentWhereUniqueInput
  }


  /**
   * SubDepartment updateMany
   */
  export type SubDepartmentUpdateManyArgs = {
    /**
     * The data used to update SubDepartments.
     */
    data: XOR<SubDepartmentUpdateManyMutationInput, SubDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which SubDepartments to update
     */
    where?: SubDepartmentWhereInput
  }


  /**
   * SubDepartment upsert
   */
  export type SubDepartmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * The filter to search for the SubDepartment to update in case it exists.
     */
    where: SubDepartmentWhereUniqueInput
    /**
     * In case the SubDepartment found by the `where` argument doesn't exist, create a new SubDepartment with this data.
     */
    create: XOR<SubDepartmentCreateInput, SubDepartmentUncheckedCreateInput>
    /**
     * In case the SubDepartment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubDepartmentUpdateInput, SubDepartmentUncheckedUpdateInput>
  }


  /**
   * SubDepartment delete
   */
  export type SubDepartmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
    /**
     * Filter which SubDepartment to delete.
     */
    where: SubDepartmentWhereUniqueInput
  }


  /**
   * SubDepartment deleteMany
   */
  export type SubDepartmentDeleteManyArgs = {
    /**
     * Filter which SubDepartments to delete
     */
    where?: SubDepartmentWhereInput
  }


  /**
   * SubDepartment.personal
   */
  export type SubDepartment$personalArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    where?: PersonalWhereInput
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    cursor?: PersonalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * SubDepartment without action
   */
  export type SubDepartmentArgs = {
    /**
     * Select specific fields to fetch from the SubDepartment
     */
    select?: SubDepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubDepartmentInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs = {
    where?: RoleWhereInput
    orderBy?: Enumerable<RoleOrderByWithAggregationInput>
    by: RoleScalarFieldEnum[]
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }


  export type RoleGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | Role$employeeArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }


  export type RoleInclude = {
    employee?: boolean | Role$employeeArgs
    _count?: boolean | RoleCountOutputTypeArgs
  }

  export type RoleGetPayload<S extends boolean | null | undefined | RoleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Role :
    S extends undefined ? never :
    S extends { include: any } & (RoleArgs | RoleFindManyArgs)
    ? Role  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'employee' ? Array < EmployeeGetPayload<S['include'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (RoleArgs | RoleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'employee' ? Array < EmployeeGetPayload<S['select'][P]>>  :
        P extends '_count' ? RoleCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Role ? Role[P] : never
  } 
      : Role


  type RoleCountArgs = 
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find one Role that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, RoleFindUniqueOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? Prisma__RoleClient<RoleGetPayload<T>> : Prisma__RoleClient<RoleGetPayload<T> | null, null>

    /**
     * Find the first Role that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): Prisma.PrismaPromise<Array<RoleGetPayload<T>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Create many Roles.
     *     @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     *     @example
     *     // Create many Roles
     *     const role = await prisma.role.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): Prisma__RoleClient<RoleGetPayload<T>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    employee<T extends Role$employeeArgs= {}>(args?: Subset<T, Role$employeeArgs>): Prisma.PrismaPromise<Array<EmployeeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Role base type for findUnique actions
   */
  export type RoleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUnique
   */
  export interface RoleFindUniqueArgs extends RoleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role base type for findFirst actions
   */
  export type RoleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }

  /**
   * Role findFirst
   */
  export interface RoleFindFirstArgs extends RoleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: Enumerable<RoleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role createMany
   */
  export type RoleCreateManyArgs = {
    /**
     * The data used to create many Roles.
     */
    data: Enumerable<RoleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
  }


  /**
   * Role.employee
   */
  export type Role$employeeArgs = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmployeeInclude | null
    where?: EmployeeWhereInput
    orderBy?: Enumerable<EmployeeOrderByWithRelationInput>
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EmployeeScalarFieldEnum>
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RoleInclude | null
  }



  /**
   * Model Position
   */


  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    listOrgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    listOrgId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    name: number
    nameuz: number
    nameru: number
    listOrgId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionMinAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    listOrgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    listOrgId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    listOrgId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs = {
    where?: PositionWhereInput
    orderBy?: Enumerable<PositionOrderByWithAggregationInput>
    by: PositionScalarFieldEnum[]
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }


  export type PositionGroupByOutputType = {
    id: string
    name: string
    nameuz: string | null
    nameru: string | null
    listOrgId: string
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect = {
    id?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    listOrgId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    personal?: boolean | Position$personalArgs
    listOrg?: boolean | ListOrgArgs
    _count?: boolean | PositionCountOutputTypeArgs
  }


  export type PositionInclude = {
    personal?: boolean | Position$personalArgs
    listOrg?: boolean | ListOrgArgs
    _count?: boolean | PositionCountOutputTypeArgs
  }

  export type PositionGetPayload<S extends boolean | null | undefined | PositionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Position :
    S extends undefined ? never :
    S extends { include: any } & (PositionArgs | PositionFindManyArgs)
    ? Position  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'personal' ? Array < PersonalGetPayload<S['include'][P]>>  :
        P extends 'listOrg' ? ListOrgGetPayload<S['include'][P]> :
        P extends '_count' ? PositionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PositionArgs | PositionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'personal' ? Array < PersonalGetPayload<S['select'][P]>>  :
        P extends 'listOrg' ? ListOrgGetPayload<S['select'][P]> :
        P extends '_count' ? PositionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Position ? Position[P] : never
  } 
      : Position


  type PositionCountArgs = 
    Omit<PositionFindManyArgs, 'select' | 'include'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PositionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PositionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Position'> extends True ? Prisma__PositionClient<PositionGetPayload<T>> : Prisma__PositionClient<PositionGetPayload<T> | null, null>

    /**
     * Find one Position that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PositionFindUniqueOrThrowArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PositionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PositionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Position'> extends True ? Prisma__PositionClient<PositionGetPayload<T>> : Prisma__PositionClient<PositionGetPayload<T> | null, null>

    /**
     * Find the first Position that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PositionFindFirstOrThrowArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PositionFindManyArgs>(
      args?: SelectSubset<T, PositionFindManyArgs>
    ): Prisma.PrismaPromise<Array<PositionGetPayload<T>>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
    **/
    create<T extends PositionCreateArgs>(
      args: SelectSubset<T, PositionCreateArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Create many Positions.
     *     @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     *     @example
     *     // Create many Positions
     *     const position = await prisma.position.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PositionCreateManyArgs>(
      args?: SelectSubset<T, PositionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
    **/
    delete<T extends PositionDeleteArgs>(
      args: SelectSubset<T, PositionDeleteArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PositionUpdateArgs>(
      args: SelectSubset<T, PositionUpdateArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PositionDeleteManyArgs>(
      args?: SelectSubset<T, PositionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PositionUpdateManyArgs>(
      args: SelectSubset<T, PositionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
    **/
    upsert<T extends PositionUpsertArgs>(
      args: SelectSubset<T, PositionUpsertArgs>
    ): Prisma__PositionClient<PositionGetPayload<T>>

    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PositionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    personal<T extends Position$personalArgs= {}>(args?: Subset<T, Position$personalArgs>): Prisma.PrismaPromise<Array<PersonalGetPayload<T>>| Null>;

    listOrg<T extends ListOrgArgs= {}>(args?: Subset<T, ListOrgArgs>): Prisma__ListOrgClient<ListOrgGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Position base type for findUnique actions
   */
  export type PositionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUnique
   */
  export interface PositionFindUniqueArgs extends PositionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }


  /**
   * Position base type for findFirst actions
   */
  export type PositionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: Enumerable<PositionScalarFieldEnum>
  }

  /**
   * Position findFirst
   */
  export interface PositionFindFirstArgs extends PositionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: Enumerable<PositionScalarFieldEnum>
  }


  /**
   * Position findMany
   */
  export type PositionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: Enumerable<PositionScalarFieldEnum>
  }


  /**
   * Position create
   */
  export type PositionCreateArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }


  /**
   * Position createMany
   */
  export type PositionCreateManyArgs = {
    /**
     * The data used to create many Positions.
     */
    data: Enumerable<PositionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Position update
   */
  export type PositionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }


  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
  }


  /**
   * Position upsert
   */
  export type PositionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }


  /**
   * Position delete
   */
  export type PositionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }


  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
  }


  /**
   * Position.personal
   */
  export type Position$personalArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    where?: PersonalWhereInput
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    cursor?: PersonalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * Position without action
   */
  export type PositionArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
  }



  /**
   * Model TypeIncident
   */


  export type AggregateTypeIncident = {
    _count: TypeIncidentCountAggregateOutputType | null
    _min: TypeIncidentMinAggregateOutputType | null
    _max: TypeIncidentMaxAggregateOutputType | null
  }

  export type TypeIncidentMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    code: string | null
    vector: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeIncidentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    code: string | null
    vector: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeIncidentCountAggregateOutputType = {
    id: number
    name: number
    nameuz: number
    nameru: number
    code: number
    vector: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TypeIncidentMinAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    code?: true
    vector?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeIncidentMaxAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    code?: true
    vector?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeIncidentCountAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    code?: true
    vector?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TypeIncidentAggregateArgs = {
    /**
     * Filter which TypeIncident to aggregate.
     */
    where?: TypeIncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeIncidents to fetch.
     */
    orderBy?: Enumerable<TypeIncidentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeIncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeIncidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeIncidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeIncidents
    **/
    _count?: true | TypeIncidentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeIncidentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeIncidentMaxAggregateInputType
  }

  export type GetTypeIncidentAggregateType<T extends TypeIncidentAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeIncident]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeIncident[P]>
      : GetScalarType<T[P], AggregateTypeIncident[P]>
  }




  export type TypeIncidentGroupByArgs = {
    where?: TypeIncidentWhereInput
    orderBy?: Enumerable<TypeIncidentOrderByWithAggregationInput>
    by: TypeIncidentScalarFieldEnum[]
    having?: TypeIncidentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeIncidentCountAggregateInputType | true
    _min?: TypeIncidentMinAggregateInputType
    _max?: TypeIncidentMaxAggregateInputType
  }


  export type TypeIncidentGroupByOutputType = {
    id: string
    name: string
    nameuz: string
    nameru: string
    code: string
    vector: string
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TypeIncidentCountAggregateOutputType | null
    _min: TypeIncidentMinAggregateOutputType | null
    _max: TypeIncidentMaxAggregateOutputType | null
  }

  type GetTypeIncidentGroupByPayload<T extends TypeIncidentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypeIncidentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeIncidentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeIncidentGroupByOutputType[P]>
            : GetScalarType<T[P], TypeIncidentGroupByOutputType[P]>
        }
      >
    >


  export type TypeIncidentSelect = {
    id?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    code?: boolean
    vector?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TypeIncidentGetPayload<S extends boolean | null | undefined | TypeIncidentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TypeIncident :
    S extends undefined ? never :
    S extends { include: any } & (TypeIncidentArgs | TypeIncidentFindManyArgs)
    ? TypeIncident 
    : S extends { select: any } & (TypeIncidentArgs | TypeIncidentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TypeIncident ? TypeIncident[P] : never
  } 
      : TypeIncident


  type TypeIncidentCountArgs = 
    Omit<TypeIncidentFindManyArgs, 'select' | 'include'> & {
      select?: TypeIncidentCountAggregateInputType | true
    }

  export interface TypeIncidentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TypeIncident that matches the filter.
     * @param {TypeIncidentFindUniqueArgs} args - Arguments to find a TypeIncident
     * @example
     * // Get one TypeIncident
     * const typeIncident = await prisma.typeIncident.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypeIncidentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypeIncidentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TypeIncident'> extends True ? Prisma__TypeIncidentClient<TypeIncidentGetPayload<T>> : Prisma__TypeIncidentClient<TypeIncidentGetPayload<T> | null, null>

    /**
     * Find one TypeIncident that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypeIncidentFindUniqueOrThrowArgs} args - Arguments to find a TypeIncident
     * @example
     * // Get one TypeIncident
     * const typeIncident = await prisma.typeIncident.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypeIncidentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TypeIncidentFindUniqueOrThrowArgs>
    ): Prisma__TypeIncidentClient<TypeIncidentGetPayload<T>>

    /**
     * Find the first TypeIncident that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeIncidentFindFirstArgs} args - Arguments to find a TypeIncident
     * @example
     * // Get one TypeIncident
     * const typeIncident = await prisma.typeIncident.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypeIncidentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypeIncidentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TypeIncident'> extends True ? Prisma__TypeIncidentClient<TypeIncidentGetPayload<T>> : Prisma__TypeIncidentClient<TypeIncidentGetPayload<T> | null, null>

    /**
     * Find the first TypeIncident that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeIncidentFindFirstOrThrowArgs} args - Arguments to find a TypeIncident
     * @example
     * // Get one TypeIncident
     * const typeIncident = await prisma.typeIncident.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypeIncidentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TypeIncidentFindFirstOrThrowArgs>
    ): Prisma__TypeIncidentClient<TypeIncidentGetPayload<T>>

    /**
     * Find zero or more TypeIncidents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeIncidentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeIncidents
     * const typeIncidents = await prisma.typeIncident.findMany()
     * 
     * // Get first 10 TypeIncidents
     * const typeIncidents = await prisma.typeIncident.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeIncidentWithIdOnly = await prisma.typeIncident.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypeIncidentFindManyArgs>(
      args?: SelectSubset<T, TypeIncidentFindManyArgs>
    ): Prisma.PrismaPromise<Array<TypeIncidentGetPayload<T>>>

    /**
     * Create a TypeIncident.
     * @param {TypeIncidentCreateArgs} args - Arguments to create a TypeIncident.
     * @example
     * // Create one TypeIncident
     * const TypeIncident = await prisma.typeIncident.create({
     *   data: {
     *     // ... data to create a TypeIncident
     *   }
     * })
     * 
    **/
    create<T extends TypeIncidentCreateArgs>(
      args: SelectSubset<T, TypeIncidentCreateArgs>
    ): Prisma__TypeIncidentClient<TypeIncidentGetPayload<T>>

    /**
     * Create many TypeIncidents.
     *     @param {TypeIncidentCreateManyArgs} args - Arguments to create many TypeIncidents.
     *     @example
     *     // Create many TypeIncidents
     *     const typeIncident = await prisma.typeIncident.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypeIncidentCreateManyArgs>(
      args?: SelectSubset<T, TypeIncidentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypeIncident.
     * @param {TypeIncidentDeleteArgs} args - Arguments to delete one TypeIncident.
     * @example
     * // Delete one TypeIncident
     * const TypeIncident = await prisma.typeIncident.delete({
     *   where: {
     *     // ... filter to delete one TypeIncident
     *   }
     * })
     * 
    **/
    delete<T extends TypeIncidentDeleteArgs>(
      args: SelectSubset<T, TypeIncidentDeleteArgs>
    ): Prisma__TypeIncidentClient<TypeIncidentGetPayload<T>>

    /**
     * Update one TypeIncident.
     * @param {TypeIncidentUpdateArgs} args - Arguments to update one TypeIncident.
     * @example
     * // Update one TypeIncident
     * const typeIncident = await prisma.typeIncident.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypeIncidentUpdateArgs>(
      args: SelectSubset<T, TypeIncidentUpdateArgs>
    ): Prisma__TypeIncidentClient<TypeIncidentGetPayload<T>>

    /**
     * Delete zero or more TypeIncidents.
     * @param {TypeIncidentDeleteManyArgs} args - Arguments to filter TypeIncidents to delete.
     * @example
     * // Delete a few TypeIncidents
     * const { count } = await prisma.typeIncident.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypeIncidentDeleteManyArgs>(
      args?: SelectSubset<T, TypeIncidentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeIncidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeIncidentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeIncidents
     * const typeIncident = await prisma.typeIncident.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypeIncidentUpdateManyArgs>(
      args: SelectSubset<T, TypeIncidentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeIncident.
     * @param {TypeIncidentUpsertArgs} args - Arguments to update or create a TypeIncident.
     * @example
     * // Update or create a TypeIncident
     * const typeIncident = await prisma.typeIncident.upsert({
     *   create: {
     *     // ... data to create a TypeIncident
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeIncident we want to update
     *   }
     * })
    **/
    upsert<T extends TypeIncidentUpsertArgs>(
      args: SelectSubset<T, TypeIncidentUpsertArgs>
    ): Prisma__TypeIncidentClient<TypeIncidentGetPayload<T>>

    /**
     * Count the number of TypeIncidents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeIncidentCountArgs} args - Arguments to filter TypeIncidents to count.
     * @example
     * // Count the number of TypeIncidents
     * const count = await prisma.typeIncident.count({
     *   where: {
     *     // ... the filter for the TypeIncidents we want to count
     *   }
     * })
    **/
    count<T extends TypeIncidentCountArgs>(
      args?: Subset<T, TypeIncidentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeIncidentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeIncident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeIncidentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeIncidentAggregateArgs>(args: Subset<T, TypeIncidentAggregateArgs>): Prisma.PrismaPromise<GetTypeIncidentAggregateType<T>>

    /**
     * Group by TypeIncident.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeIncidentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeIncidentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeIncidentGroupByArgs['orderBy'] }
        : { orderBy?: TypeIncidentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeIncidentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeIncidentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeIncident.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypeIncidentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TypeIncident base type for findUnique actions
   */
  export type TypeIncidentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * Filter, which TypeIncident to fetch.
     */
    where: TypeIncidentWhereUniqueInput
  }

  /**
   * TypeIncident findUnique
   */
  export interface TypeIncidentFindUniqueArgs extends TypeIncidentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypeIncident findUniqueOrThrow
   */
  export type TypeIncidentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * Filter, which TypeIncident to fetch.
     */
    where: TypeIncidentWhereUniqueInput
  }


  /**
   * TypeIncident base type for findFirst actions
   */
  export type TypeIncidentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * Filter, which TypeIncident to fetch.
     */
    where?: TypeIncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeIncidents to fetch.
     */
    orderBy?: Enumerable<TypeIncidentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeIncidents.
     */
    cursor?: TypeIncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeIncidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeIncidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeIncidents.
     */
    distinct?: Enumerable<TypeIncidentScalarFieldEnum>
  }

  /**
   * TypeIncident findFirst
   */
  export interface TypeIncidentFindFirstArgs extends TypeIncidentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypeIncident findFirstOrThrow
   */
  export type TypeIncidentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * Filter, which TypeIncident to fetch.
     */
    where?: TypeIncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeIncidents to fetch.
     */
    orderBy?: Enumerable<TypeIncidentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeIncidents.
     */
    cursor?: TypeIncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeIncidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeIncidents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeIncidents.
     */
    distinct?: Enumerable<TypeIncidentScalarFieldEnum>
  }


  /**
   * TypeIncident findMany
   */
  export type TypeIncidentFindManyArgs = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * Filter, which TypeIncidents to fetch.
     */
    where?: TypeIncidentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeIncidents to fetch.
     */
    orderBy?: Enumerable<TypeIncidentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeIncidents.
     */
    cursor?: TypeIncidentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeIncidents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeIncidents.
     */
    skip?: number
    distinct?: Enumerable<TypeIncidentScalarFieldEnum>
  }


  /**
   * TypeIncident create
   */
  export type TypeIncidentCreateArgs = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * The data needed to create a TypeIncident.
     */
    data: XOR<TypeIncidentCreateInput, TypeIncidentUncheckedCreateInput>
  }


  /**
   * TypeIncident createMany
   */
  export type TypeIncidentCreateManyArgs = {
    /**
     * The data used to create many TypeIncidents.
     */
    data: Enumerable<TypeIncidentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TypeIncident update
   */
  export type TypeIncidentUpdateArgs = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * The data needed to update a TypeIncident.
     */
    data: XOR<TypeIncidentUpdateInput, TypeIncidentUncheckedUpdateInput>
    /**
     * Choose, which TypeIncident to update.
     */
    where: TypeIncidentWhereUniqueInput
  }


  /**
   * TypeIncident updateMany
   */
  export type TypeIncidentUpdateManyArgs = {
    /**
     * The data used to update TypeIncidents.
     */
    data: XOR<TypeIncidentUpdateManyMutationInput, TypeIncidentUncheckedUpdateManyInput>
    /**
     * Filter which TypeIncidents to update
     */
    where?: TypeIncidentWhereInput
  }


  /**
   * TypeIncident upsert
   */
  export type TypeIncidentUpsertArgs = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * The filter to search for the TypeIncident to update in case it exists.
     */
    where: TypeIncidentWhereUniqueInput
    /**
     * In case the TypeIncident found by the `where` argument doesn't exist, create a new TypeIncident with this data.
     */
    create: XOR<TypeIncidentCreateInput, TypeIncidentUncheckedCreateInput>
    /**
     * In case the TypeIncident was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeIncidentUpdateInput, TypeIncidentUncheckedUpdateInput>
  }


  /**
   * TypeIncident delete
   */
  export type TypeIncidentDeleteArgs = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
    /**
     * Filter which TypeIncident to delete.
     */
    where: TypeIncidentWhereUniqueInput
  }


  /**
   * TypeIncident deleteMany
   */
  export type TypeIncidentDeleteManyArgs = {
    /**
     * Filter which TypeIncidents to delete
     */
    where?: TypeIncidentWhereInput
  }


  /**
   * TypeIncident without action
   */
  export type TypeIncidentArgs = {
    /**
     * Select specific fields to fetch from the TypeIncident
     */
    select?: TypeIncidentSelect | null
  }



  /**
   * Model ListOrg
   */


  export type AggregateListOrg = {
    _count: ListOrgCountAggregateOutputType | null
    _min: ListOrgMinAggregateOutputType | null
    _max: ListOrgMaxAggregateOutputType | null
  }

  export type ListOrgMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListOrgMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ListOrgCountAggregateOutputType = {
    id: number
    name: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ListOrgMinAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListOrgMaxAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ListOrgCountAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ListOrgAggregateArgs = {
    /**
     * Filter which ListOrg to aggregate.
     */
    where?: ListOrgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListOrgs to fetch.
     */
    orderBy?: Enumerable<ListOrgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListOrgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListOrgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListOrgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListOrgs
    **/
    _count?: true | ListOrgCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListOrgMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListOrgMaxAggregateInputType
  }

  export type GetListOrgAggregateType<T extends ListOrgAggregateArgs> = {
        [P in keyof T & keyof AggregateListOrg]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListOrg[P]>
      : GetScalarType<T[P], AggregateListOrg[P]>
  }




  export type ListOrgGroupByArgs = {
    where?: ListOrgWhereInput
    orderBy?: Enumerable<ListOrgOrderByWithAggregationInput>
    by: ListOrgScalarFieldEnum[]
    having?: ListOrgScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListOrgCountAggregateInputType | true
    _min?: ListOrgMinAggregateInputType
    _max?: ListOrgMaxAggregateInputType
  }


  export type ListOrgGroupByOutputType = {
    id: string
    name: string
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ListOrgCountAggregateOutputType | null
    _min: ListOrgMinAggregateOutputType | null
    _max: ListOrgMaxAggregateOutputType | null
  }

  type GetListOrgGroupByPayload<T extends ListOrgGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ListOrgGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListOrgGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListOrgGroupByOutputType[P]>
            : GetScalarType<T[P], ListOrgGroupByOutputType[P]>
        }
      >
    >


  export type ListOrgSelect = {
    id?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | ListOrg$departmentArgs
    personal?: boolean | ListOrg$personalArgs
    position?: boolean | ListOrg$positionArgs
    _count?: boolean | ListOrgCountOutputTypeArgs
  }


  export type ListOrgInclude = {
    department?: boolean | ListOrg$departmentArgs
    personal?: boolean | ListOrg$personalArgs
    position?: boolean | ListOrg$positionArgs
    _count?: boolean | ListOrgCountOutputTypeArgs
  }

  export type ListOrgGetPayload<S extends boolean | null | undefined | ListOrgArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ListOrg :
    S extends undefined ? never :
    S extends { include: any } & (ListOrgArgs | ListOrgFindManyArgs)
    ? ListOrg  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'department' ? Array < DepartmentGetPayload<S['include'][P]>>  :
        P extends 'personal' ? Array < PersonalGetPayload<S['include'][P]>>  :
        P extends 'position' ? Array < PositionGetPayload<S['include'][P]>>  :
        P extends '_count' ? ListOrgCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ListOrgArgs | ListOrgFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'department' ? Array < DepartmentGetPayload<S['select'][P]>>  :
        P extends 'personal' ? Array < PersonalGetPayload<S['select'][P]>>  :
        P extends 'position' ? Array < PositionGetPayload<S['select'][P]>>  :
        P extends '_count' ? ListOrgCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ListOrg ? ListOrg[P] : never
  } 
      : ListOrg


  type ListOrgCountArgs = 
    Omit<ListOrgFindManyArgs, 'select' | 'include'> & {
      select?: ListOrgCountAggregateInputType | true
    }

  export interface ListOrgDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ListOrg that matches the filter.
     * @param {ListOrgFindUniqueArgs} args - Arguments to find a ListOrg
     * @example
     * // Get one ListOrg
     * const listOrg = await prisma.listOrg.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ListOrgFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ListOrgFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ListOrg'> extends True ? Prisma__ListOrgClient<ListOrgGetPayload<T>> : Prisma__ListOrgClient<ListOrgGetPayload<T> | null, null>

    /**
     * Find one ListOrg that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ListOrgFindUniqueOrThrowArgs} args - Arguments to find a ListOrg
     * @example
     * // Get one ListOrg
     * const listOrg = await prisma.listOrg.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ListOrgFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ListOrgFindUniqueOrThrowArgs>
    ): Prisma__ListOrgClient<ListOrgGetPayload<T>>

    /**
     * Find the first ListOrg that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListOrgFindFirstArgs} args - Arguments to find a ListOrg
     * @example
     * // Get one ListOrg
     * const listOrg = await prisma.listOrg.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ListOrgFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ListOrgFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ListOrg'> extends True ? Prisma__ListOrgClient<ListOrgGetPayload<T>> : Prisma__ListOrgClient<ListOrgGetPayload<T> | null, null>

    /**
     * Find the first ListOrg that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListOrgFindFirstOrThrowArgs} args - Arguments to find a ListOrg
     * @example
     * // Get one ListOrg
     * const listOrg = await prisma.listOrg.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ListOrgFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ListOrgFindFirstOrThrowArgs>
    ): Prisma__ListOrgClient<ListOrgGetPayload<T>>

    /**
     * Find zero or more ListOrgs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListOrgFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListOrgs
     * const listOrgs = await prisma.listOrg.findMany()
     * 
     * // Get first 10 ListOrgs
     * const listOrgs = await prisma.listOrg.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listOrgWithIdOnly = await prisma.listOrg.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ListOrgFindManyArgs>(
      args?: SelectSubset<T, ListOrgFindManyArgs>
    ): Prisma.PrismaPromise<Array<ListOrgGetPayload<T>>>

    /**
     * Create a ListOrg.
     * @param {ListOrgCreateArgs} args - Arguments to create a ListOrg.
     * @example
     * // Create one ListOrg
     * const ListOrg = await prisma.listOrg.create({
     *   data: {
     *     // ... data to create a ListOrg
     *   }
     * })
     * 
    **/
    create<T extends ListOrgCreateArgs>(
      args: SelectSubset<T, ListOrgCreateArgs>
    ): Prisma__ListOrgClient<ListOrgGetPayload<T>>

    /**
     * Create many ListOrgs.
     *     @param {ListOrgCreateManyArgs} args - Arguments to create many ListOrgs.
     *     @example
     *     // Create many ListOrgs
     *     const listOrg = await prisma.listOrg.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ListOrgCreateManyArgs>(
      args?: SelectSubset<T, ListOrgCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ListOrg.
     * @param {ListOrgDeleteArgs} args - Arguments to delete one ListOrg.
     * @example
     * // Delete one ListOrg
     * const ListOrg = await prisma.listOrg.delete({
     *   where: {
     *     // ... filter to delete one ListOrg
     *   }
     * })
     * 
    **/
    delete<T extends ListOrgDeleteArgs>(
      args: SelectSubset<T, ListOrgDeleteArgs>
    ): Prisma__ListOrgClient<ListOrgGetPayload<T>>

    /**
     * Update one ListOrg.
     * @param {ListOrgUpdateArgs} args - Arguments to update one ListOrg.
     * @example
     * // Update one ListOrg
     * const listOrg = await prisma.listOrg.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ListOrgUpdateArgs>(
      args: SelectSubset<T, ListOrgUpdateArgs>
    ): Prisma__ListOrgClient<ListOrgGetPayload<T>>

    /**
     * Delete zero or more ListOrgs.
     * @param {ListOrgDeleteManyArgs} args - Arguments to filter ListOrgs to delete.
     * @example
     * // Delete a few ListOrgs
     * const { count } = await prisma.listOrg.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ListOrgDeleteManyArgs>(
      args?: SelectSubset<T, ListOrgDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListOrgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListOrgUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListOrgs
     * const listOrg = await prisma.listOrg.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ListOrgUpdateManyArgs>(
      args: SelectSubset<T, ListOrgUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ListOrg.
     * @param {ListOrgUpsertArgs} args - Arguments to update or create a ListOrg.
     * @example
     * // Update or create a ListOrg
     * const listOrg = await prisma.listOrg.upsert({
     *   create: {
     *     // ... data to create a ListOrg
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListOrg we want to update
     *   }
     * })
    **/
    upsert<T extends ListOrgUpsertArgs>(
      args: SelectSubset<T, ListOrgUpsertArgs>
    ): Prisma__ListOrgClient<ListOrgGetPayload<T>>

    /**
     * Count the number of ListOrgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListOrgCountArgs} args - Arguments to filter ListOrgs to count.
     * @example
     * // Count the number of ListOrgs
     * const count = await prisma.listOrg.count({
     *   where: {
     *     // ... the filter for the ListOrgs we want to count
     *   }
     * })
    **/
    count<T extends ListOrgCountArgs>(
      args?: Subset<T, ListOrgCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListOrgCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListOrg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListOrgAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListOrgAggregateArgs>(args: Subset<T, ListOrgAggregateArgs>): Prisma.PrismaPromise<GetListOrgAggregateType<T>>

    /**
     * Group by ListOrg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListOrgGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListOrgGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListOrgGroupByArgs['orderBy'] }
        : { orderBy?: ListOrgGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListOrgGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListOrgGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ListOrg.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ListOrgClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    department<T extends ListOrg$departmentArgs= {}>(args?: Subset<T, ListOrg$departmentArgs>): Prisma.PrismaPromise<Array<DepartmentGetPayload<T>>| Null>;

    personal<T extends ListOrg$personalArgs= {}>(args?: Subset<T, ListOrg$personalArgs>): Prisma.PrismaPromise<Array<PersonalGetPayload<T>>| Null>;

    position<T extends ListOrg$positionArgs= {}>(args?: Subset<T, ListOrg$positionArgs>): Prisma.PrismaPromise<Array<PositionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ListOrg base type for findUnique actions
   */
  export type ListOrgFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * Filter, which ListOrg to fetch.
     */
    where: ListOrgWhereUniqueInput
  }

  /**
   * ListOrg findUnique
   */
  export interface ListOrgFindUniqueArgs extends ListOrgFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ListOrg findUniqueOrThrow
   */
  export type ListOrgFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * Filter, which ListOrg to fetch.
     */
    where: ListOrgWhereUniqueInput
  }


  /**
   * ListOrg base type for findFirst actions
   */
  export type ListOrgFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * Filter, which ListOrg to fetch.
     */
    where?: ListOrgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListOrgs to fetch.
     */
    orderBy?: Enumerable<ListOrgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListOrgs.
     */
    cursor?: ListOrgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListOrgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListOrgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListOrgs.
     */
    distinct?: Enumerable<ListOrgScalarFieldEnum>
  }

  /**
   * ListOrg findFirst
   */
  export interface ListOrgFindFirstArgs extends ListOrgFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ListOrg findFirstOrThrow
   */
  export type ListOrgFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * Filter, which ListOrg to fetch.
     */
    where?: ListOrgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListOrgs to fetch.
     */
    orderBy?: Enumerable<ListOrgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListOrgs.
     */
    cursor?: ListOrgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListOrgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListOrgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListOrgs.
     */
    distinct?: Enumerable<ListOrgScalarFieldEnum>
  }


  /**
   * ListOrg findMany
   */
  export type ListOrgFindManyArgs = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * Filter, which ListOrgs to fetch.
     */
    where?: ListOrgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListOrgs to fetch.
     */
    orderBy?: Enumerable<ListOrgOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListOrgs.
     */
    cursor?: ListOrgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListOrgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListOrgs.
     */
    skip?: number
    distinct?: Enumerable<ListOrgScalarFieldEnum>
  }


  /**
   * ListOrg create
   */
  export type ListOrgCreateArgs = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * The data needed to create a ListOrg.
     */
    data: XOR<ListOrgCreateInput, ListOrgUncheckedCreateInput>
  }


  /**
   * ListOrg createMany
   */
  export type ListOrgCreateManyArgs = {
    /**
     * The data used to create many ListOrgs.
     */
    data: Enumerable<ListOrgCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ListOrg update
   */
  export type ListOrgUpdateArgs = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * The data needed to update a ListOrg.
     */
    data: XOR<ListOrgUpdateInput, ListOrgUncheckedUpdateInput>
    /**
     * Choose, which ListOrg to update.
     */
    where: ListOrgWhereUniqueInput
  }


  /**
   * ListOrg updateMany
   */
  export type ListOrgUpdateManyArgs = {
    /**
     * The data used to update ListOrgs.
     */
    data: XOR<ListOrgUpdateManyMutationInput, ListOrgUncheckedUpdateManyInput>
    /**
     * Filter which ListOrgs to update
     */
    where?: ListOrgWhereInput
  }


  /**
   * ListOrg upsert
   */
  export type ListOrgUpsertArgs = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * The filter to search for the ListOrg to update in case it exists.
     */
    where: ListOrgWhereUniqueInput
    /**
     * In case the ListOrg found by the `where` argument doesn't exist, create a new ListOrg with this data.
     */
    create: XOR<ListOrgCreateInput, ListOrgUncheckedCreateInput>
    /**
     * In case the ListOrg was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListOrgUpdateInput, ListOrgUncheckedUpdateInput>
  }


  /**
   * ListOrg delete
   */
  export type ListOrgDeleteArgs = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
    /**
     * Filter which ListOrg to delete.
     */
    where: ListOrgWhereUniqueInput
  }


  /**
   * ListOrg deleteMany
   */
  export type ListOrgDeleteManyArgs = {
    /**
     * Filter which ListOrgs to delete
     */
    where?: ListOrgWhereInput
  }


  /**
   * ListOrg.department
   */
  export type ListOrg$departmentArgs = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DepartmentInclude | null
    where?: DepartmentWhereInput
    orderBy?: Enumerable<DepartmentOrderByWithRelationInput>
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DepartmentScalarFieldEnum>
  }


  /**
   * ListOrg.personal
   */
  export type ListOrg$personalArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    where?: PersonalWhereInput
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    cursor?: PersonalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * ListOrg.position
   */
  export type ListOrg$positionArgs = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PositionInclude | null
    where?: PositionWhereInput
    orderBy?: Enumerable<PositionOrderByWithRelationInput>
    cursor?: PositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PositionScalarFieldEnum>
  }


  /**
   * ListOrg without action
   */
  export type ListOrgArgs = {
    /**
     * Select specific fields to fetch from the ListOrg
     */
    select?: ListOrgSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListOrgInclude | null
  }



  /**
   * Model Personal
   */


  export type AggregatePersonal = {
    _count: PersonalCountAggregateOutputType | null
    _min: PersonalMinAggregateOutputType | null
    _max: PersonalMaxAggregateOutputType | null
  }

  export type PersonalMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    positionId: string | null
    listOrgId: string | null
    departmentId: string | null
    subDepartmentId: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonalMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    positionId: string | null
    listOrgId: string | null
    departmentId: string | null
    subDepartmentId: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PersonalCountAggregateOutputType = {
    id: number
    firstName: number
    middleName: number
    lastName: number
    phone: number
    email: number
    positionId: number
    listOrgId: number
    departmentId: number
    subDepartmentId: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PersonalMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    phone?: true
    email?: true
    positionId?: true
    listOrgId?: true
    departmentId?: true
    subDepartmentId?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonalMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    phone?: true
    email?: true
    positionId?: true
    listOrgId?: true
    departmentId?: true
    subDepartmentId?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PersonalCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    phone?: true
    email?: true
    positionId?: true
    listOrgId?: true
    departmentId?: true
    subDepartmentId?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PersonalAggregateArgs = {
    /**
     * Filter which Personal to aggregate.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Personals
    **/
    _count?: true | PersonalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalMaxAggregateInputType
  }

  export type GetPersonalAggregateType<T extends PersonalAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonal[P]>
      : GetScalarType<T[P], AggregatePersonal[P]>
  }




  export type PersonalGroupByArgs = {
    where?: PersonalWhereInput
    orderBy?: Enumerable<PersonalOrderByWithAggregationInput>
    by: PersonalScalarFieldEnum[]
    having?: PersonalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalCountAggregateInputType | true
    _min?: PersonalMinAggregateInputType
    _max?: PersonalMaxAggregateInputType
  }


  export type PersonalGroupByOutputType = {
    id: string
    firstName: string
    middleName: string | null
    lastName: string
    phone: string | null
    email: string | null
    positionId: string
    listOrgId: string
    departmentId: string
    subDepartmentId: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PersonalCountAggregateOutputType | null
    _min: PersonalMinAggregateOutputType | null
    _max: PersonalMaxAggregateOutputType | null
  }

  type GetPersonalGroupByPayload<T extends PersonalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PersonalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalGroupByOutputType[P]>
        }
      >
    >


  export type PersonalSelect = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    positionId?: boolean
    listOrgId?: boolean
    departmentId?: boolean
    subDepartmentId?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | DepartmentArgs
    listOrg?: boolean | ListOrgArgs
    position?: boolean | PositionArgs
    subDepartment?: boolean | SubDepartmentArgs
  }


  export type PersonalInclude = {
    department?: boolean | DepartmentArgs
    listOrg?: boolean | ListOrgArgs
    position?: boolean | PositionArgs
    subDepartment?: boolean | SubDepartmentArgs
  }

  export type PersonalGetPayload<S extends boolean | null | undefined | PersonalArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Personal :
    S extends undefined ? never :
    S extends { include: any } & (PersonalArgs | PersonalFindManyArgs)
    ? Personal  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'department' ? DepartmentGetPayload<S['include'][P]> :
        P extends 'listOrg' ? ListOrgGetPayload<S['include'][P]> :
        P extends 'position' ? PositionGetPayload<S['include'][P]> :
        P extends 'subDepartment' ? SubDepartmentGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (PersonalArgs | PersonalFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'department' ? DepartmentGetPayload<S['select'][P]> :
        P extends 'listOrg' ? ListOrgGetPayload<S['select'][P]> :
        P extends 'position' ? PositionGetPayload<S['select'][P]> :
        P extends 'subDepartment' ? SubDepartmentGetPayload<S['select'][P]> | null :  P extends keyof Personal ? Personal[P] : never
  } 
      : Personal


  type PersonalCountArgs = 
    Omit<PersonalFindManyArgs, 'select' | 'include'> & {
      select?: PersonalCountAggregateInputType | true
    }

  export interface PersonalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Personal that matches the filter.
     * @param {PersonalFindUniqueArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PersonalFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PersonalFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Personal'> extends True ? Prisma__PersonalClient<PersonalGetPayload<T>> : Prisma__PersonalClient<PersonalGetPayload<T> | null, null>

    /**
     * Find one Personal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PersonalFindUniqueOrThrowArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PersonalFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PersonalFindUniqueOrThrowArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Find the first Personal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindFirstArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PersonalFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PersonalFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Personal'> extends True ? Prisma__PersonalClient<PersonalGetPayload<T>> : Prisma__PersonalClient<PersonalGetPayload<T> | null, null>

    /**
     * Find the first Personal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindFirstOrThrowArgs} args - Arguments to find a Personal
     * @example
     * // Get one Personal
     * const personal = await prisma.personal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PersonalFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PersonalFindFirstOrThrowArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Find zero or more Personals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Personals
     * const personals = await prisma.personal.findMany()
     * 
     * // Get first 10 Personals
     * const personals = await prisma.personal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personalWithIdOnly = await prisma.personal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PersonalFindManyArgs>(
      args?: SelectSubset<T, PersonalFindManyArgs>
    ): Prisma.PrismaPromise<Array<PersonalGetPayload<T>>>

    /**
     * Create a Personal.
     * @param {PersonalCreateArgs} args - Arguments to create a Personal.
     * @example
     * // Create one Personal
     * const Personal = await prisma.personal.create({
     *   data: {
     *     // ... data to create a Personal
     *   }
     * })
     * 
    **/
    create<T extends PersonalCreateArgs>(
      args: SelectSubset<T, PersonalCreateArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Create many Personals.
     *     @param {PersonalCreateManyArgs} args - Arguments to create many Personals.
     *     @example
     *     // Create many Personals
     *     const personal = await prisma.personal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PersonalCreateManyArgs>(
      args?: SelectSubset<T, PersonalCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Personal.
     * @param {PersonalDeleteArgs} args - Arguments to delete one Personal.
     * @example
     * // Delete one Personal
     * const Personal = await prisma.personal.delete({
     *   where: {
     *     // ... filter to delete one Personal
     *   }
     * })
     * 
    **/
    delete<T extends PersonalDeleteArgs>(
      args: SelectSubset<T, PersonalDeleteArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Update one Personal.
     * @param {PersonalUpdateArgs} args - Arguments to update one Personal.
     * @example
     * // Update one Personal
     * const personal = await prisma.personal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PersonalUpdateArgs>(
      args: SelectSubset<T, PersonalUpdateArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Delete zero or more Personals.
     * @param {PersonalDeleteManyArgs} args - Arguments to filter Personals to delete.
     * @example
     * // Delete a few Personals
     * const { count } = await prisma.personal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PersonalDeleteManyArgs>(
      args?: SelectSubset<T, PersonalDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Personals
     * const personal = await prisma.personal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PersonalUpdateManyArgs>(
      args: SelectSubset<T, PersonalUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Personal.
     * @param {PersonalUpsertArgs} args - Arguments to update or create a Personal.
     * @example
     * // Update or create a Personal
     * const personal = await prisma.personal.upsert({
     *   create: {
     *     // ... data to create a Personal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Personal we want to update
     *   }
     * })
    **/
    upsert<T extends PersonalUpsertArgs>(
      args: SelectSubset<T, PersonalUpsertArgs>
    ): Prisma__PersonalClient<PersonalGetPayload<T>>

    /**
     * Count the number of Personals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalCountArgs} args - Arguments to filter Personals to count.
     * @example
     * // Count the number of Personals
     * const count = await prisma.personal.count({
     *   where: {
     *     // ... the filter for the Personals we want to count
     *   }
     * })
    **/
    count<T extends PersonalCountArgs>(
      args?: Subset<T, PersonalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalAggregateArgs>(args: Subset<T, PersonalAggregateArgs>): Prisma.PrismaPromise<GetPersonalAggregateType<T>>

    /**
     * Group by Personal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalGroupByArgs['orderBy'] }
        : { orderBy?: PersonalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Personal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PersonalClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    department<T extends DepartmentArgs= {}>(args?: Subset<T, DepartmentArgs>): Prisma__DepartmentClient<DepartmentGetPayload<T> | Null>;

    listOrg<T extends ListOrgArgs= {}>(args?: Subset<T, ListOrgArgs>): Prisma__ListOrgClient<ListOrgGetPayload<T> | Null>;

    position<T extends PositionArgs= {}>(args?: Subset<T, PositionArgs>): Prisma__PositionClient<PositionGetPayload<T> | Null>;

    subDepartment<T extends SubDepartmentArgs= {}>(args?: Subset<T, SubDepartmentArgs>): Prisma__SubDepartmentClient<SubDepartmentGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Personal base type for findUnique actions
   */
  export type PersonalFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where: PersonalWhereUniqueInput
  }

  /**
   * Personal findUnique
   */
  export interface PersonalFindUniqueArgs extends PersonalFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personal findUniqueOrThrow
   */
  export type PersonalFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal base type for findFirst actions
   */
  export type PersonalFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personals.
     */
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }

  /**
   * Personal findFirst
   */
  export interface PersonalFindFirstArgs extends PersonalFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Personal findFirstOrThrow
   */
  export type PersonalFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personal to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Personals.
     */
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * Personal findMany
   */
  export type PersonalFindManyArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter, which Personals to fetch.
     */
    where?: PersonalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Personals to fetch.
     */
    orderBy?: Enumerable<PersonalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Personals.
     */
    cursor?: PersonalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Personals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Personals.
     */
    skip?: number
    distinct?: Enumerable<PersonalScalarFieldEnum>
  }


  /**
   * Personal create
   */
  export type PersonalCreateArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The data needed to create a Personal.
     */
    data: XOR<PersonalCreateInput, PersonalUncheckedCreateInput>
  }


  /**
   * Personal createMany
   */
  export type PersonalCreateManyArgs = {
    /**
     * The data used to create many Personals.
     */
    data: Enumerable<PersonalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Personal update
   */
  export type PersonalUpdateArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The data needed to update a Personal.
     */
    data: XOR<PersonalUpdateInput, PersonalUncheckedUpdateInput>
    /**
     * Choose, which Personal to update.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal updateMany
   */
  export type PersonalUpdateManyArgs = {
    /**
     * The data used to update Personals.
     */
    data: XOR<PersonalUpdateManyMutationInput, PersonalUncheckedUpdateManyInput>
    /**
     * Filter which Personals to update
     */
    where?: PersonalWhereInput
  }


  /**
   * Personal upsert
   */
  export type PersonalUpsertArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * The filter to search for the Personal to update in case it exists.
     */
    where: PersonalWhereUniqueInput
    /**
     * In case the Personal found by the `where` argument doesn't exist, create a new Personal with this data.
     */
    create: XOR<PersonalCreateInput, PersonalUncheckedCreateInput>
    /**
     * In case the Personal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalUpdateInput, PersonalUncheckedUpdateInput>
  }


  /**
   * Personal delete
   */
  export type PersonalDeleteArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
    /**
     * Filter which Personal to delete.
     */
    where: PersonalWhereUniqueInput
  }


  /**
   * Personal deleteMany
   */
  export type PersonalDeleteManyArgs = {
    /**
     * Filter which Personals to delete
     */
    where?: PersonalWhereInput
  }


  /**
   * Personal without action
   */
  export type PersonalArgs = {
    /**
     * Select specific fields to fetch from the Personal
     */
    select?: PersonalSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PersonalInclude | null
  }



  /**
   * Model HotLine
   */


  export type AggregateHotLine = {
    _count: HotLineCountAggregateOutputType | null
    _min: HotLineMinAggregateOutputType | null
    _max: HotLineMaxAggregateOutputType | null
  }

  export type HotLineMinAggregateOutputType = {
    id: string | null
    date: Date | null
    fullName: string | null
    contact: string | null
    description: string | null
    answer: string | null
    employeeId: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotLineMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    fullName: string | null
    contact: string | null
    description: string | null
    answer: string | null
    employeeId: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotLineCountAggregateOutputType = {
    id: number
    date: number
    fullName: number
    contact: number
    description: number
    answer: number
    employeeId: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotLineMinAggregateInputType = {
    id?: true
    date?: true
    fullName?: true
    contact?: true
    description?: true
    answer?: true
    employeeId?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotLineMaxAggregateInputType = {
    id?: true
    date?: true
    fullName?: true
    contact?: true
    description?: true
    answer?: true
    employeeId?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotLineCountAggregateInputType = {
    id?: true
    date?: true
    fullName?: true
    contact?: true
    description?: true
    answer?: true
    employeeId?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotLineAggregateArgs = {
    /**
     * Filter which HotLine to aggregate.
     */
    where?: HotLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotLines to fetch.
     */
    orderBy?: Enumerable<HotLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotLines
    **/
    _count?: true | HotLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotLineMaxAggregateInputType
  }

  export type GetHotLineAggregateType<T extends HotLineAggregateArgs> = {
        [P in keyof T & keyof AggregateHotLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotLine[P]>
      : GetScalarType<T[P], AggregateHotLine[P]>
  }




  export type HotLineGroupByArgs = {
    where?: HotLineWhereInput
    orderBy?: Enumerable<HotLineOrderByWithAggregationInput>
    by: HotLineScalarFieldEnum[]
    having?: HotLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotLineCountAggregateInputType | true
    _min?: HotLineMinAggregateInputType
    _max?: HotLineMaxAggregateInputType
  }


  export type HotLineGroupByOutputType = {
    id: string
    date: Date
    fullName: string
    contact: string
    description: string
    answer: string
    employeeId: string
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: HotLineCountAggregateOutputType | null
    _min: HotLineMinAggregateOutputType | null
    _max: HotLineMaxAggregateOutputType | null
  }

  type GetHotLineGroupByPayload<T extends HotLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HotLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotLineGroupByOutputType[P]>
            : GetScalarType<T[P], HotLineGroupByOutputType[P]>
        }
      >
    >


  export type HotLineSelect = {
    id?: boolean
    date?: boolean
    fullName?: boolean
    contact?: boolean
    description?: boolean
    answer?: boolean
    employeeId?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type HotLineGetPayload<S extends boolean | null | undefined | HotLineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HotLine :
    S extends undefined ? never :
    S extends { include: any } & (HotLineArgs | HotLineFindManyArgs)
    ? HotLine 
    : S extends { select: any } & (HotLineArgs | HotLineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HotLine ? HotLine[P] : never
  } 
      : HotLine


  type HotLineCountArgs = 
    Omit<HotLineFindManyArgs, 'select' | 'include'> & {
      select?: HotLineCountAggregateInputType | true
    }

  export interface HotLineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HotLine that matches the filter.
     * @param {HotLineFindUniqueArgs} args - Arguments to find a HotLine
     * @example
     * // Get one HotLine
     * const hotLine = await prisma.hotLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HotLineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HotLineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HotLine'> extends True ? Prisma__HotLineClient<HotLineGetPayload<T>> : Prisma__HotLineClient<HotLineGetPayload<T> | null, null>

    /**
     * Find one HotLine that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HotLineFindUniqueOrThrowArgs} args - Arguments to find a HotLine
     * @example
     * // Get one HotLine
     * const hotLine = await prisma.hotLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HotLineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HotLineFindUniqueOrThrowArgs>
    ): Prisma__HotLineClient<HotLineGetPayload<T>>

    /**
     * Find the first HotLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotLineFindFirstArgs} args - Arguments to find a HotLine
     * @example
     * // Get one HotLine
     * const hotLine = await prisma.hotLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HotLineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HotLineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HotLine'> extends True ? Prisma__HotLineClient<HotLineGetPayload<T>> : Prisma__HotLineClient<HotLineGetPayload<T> | null, null>

    /**
     * Find the first HotLine that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotLineFindFirstOrThrowArgs} args - Arguments to find a HotLine
     * @example
     * // Get one HotLine
     * const hotLine = await prisma.hotLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HotLineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HotLineFindFirstOrThrowArgs>
    ): Prisma__HotLineClient<HotLineGetPayload<T>>

    /**
     * Find zero or more HotLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotLineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotLines
     * const hotLines = await prisma.hotLine.findMany()
     * 
     * // Get first 10 HotLines
     * const hotLines = await prisma.hotLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotLineWithIdOnly = await prisma.hotLine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HotLineFindManyArgs>(
      args?: SelectSubset<T, HotLineFindManyArgs>
    ): Prisma.PrismaPromise<Array<HotLineGetPayload<T>>>

    /**
     * Create a HotLine.
     * @param {HotLineCreateArgs} args - Arguments to create a HotLine.
     * @example
     * // Create one HotLine
     * const HotLine = await prisma.hotLine.create({
     *   data: {
     *     // ... data to create a HotLine
     *   }
     * })
     * 
    **/
    create<T extends HotLineCreateArgs>(
      args: SelectSubset<T, HotLineCreateArgs>
    ): Prisma__HotLineClient<HotLineGetPayload<T>>

    /**
     * Create many HotLines.
     *     @param {HotLineCreateManyArgs} args - Arguments to create many HotLines.
     *     @example
     *     // Create many HotLines
     *     const hotLine = await prisma.hotLine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HotLineCreateManyArgs>(
      args?: SelectSubset<T, HotLineCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HotLine.
     * @param {HotLineDeleteArgs} args - Arguments to delete one HotLine.
     * @example
     * // Delete one HotLine
     * const HotLine = await prisma.hotLine.delete({
     *   where: {
     *     // ... filter to delete one HotLine
     *   }
     * })
     * 
    **/
    delete<T extends HotLineDeleteArgs>(
      args: SelectSubset<T, HotLineDeleteArgs>
    ): Prisma__HotLineClient<HotLineGetPayload<T>>

    /**
     * Update one HotLine.
     * @param {HotLineUpdateArgs} args - Arguments to update one HotLine.
     * @example
     * // Update one HotLine
     * const hotLine = await prisma.hotLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HotLineUpdateArgs>(
      args: SelectSubset<T, HotLineUpdateArgs>
    ): Prisma__HotLineClient<HotLineGetPayload<T>>

    /**
     * Delete zero or more HotLines.
     * @param {HotLineDeleteManyArgs} args - Arguments to filter HotLines to delete.
     * @example
     * // Delete a few HotLines
     * const { count } = await prisma.hotLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HotLineDeleteManyArgs>(
      args?: SelectSubset<T, HotLineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotLines
     * const hotLine = await prisma.hotLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HotLineUpdateManyArgs>(
      args: SelectSubset<T, HotLineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HotLine.
     * @param {HotLineUpsertArgs} args - Arguments to update or create a HotLine.
     * @example
     * // Update or create a HotLine
     * const hotLine = await prisma.hotLine.upsert({
     *   create: {
     *     // ... data to create a HotLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotLine we want to update
     *   }
     * })
    **/
    upsert<T extends HotLineUpsertArgs>(
      args: SelectSubset<T, HotLineUpsertArgs>
    ): Prisma__HotLineClient<HotLineGetPayload<T>>

    /**
     * Count the number of HotLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotLineCountArgs} args - Arguments to filter HotLines to count.
     * @example
     * // Count the number of HotLines
     * const count = await prisma.hotLine.count({
     *   where: {
     *     // ... the filter for the HotLines we want to count
     *   }
     * })
    **/
    count<T extends HotLineCountArgs>(
      args?: Subset<T, HotLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotLineAggregateArgs>(args: Subset<T, HotLineAggregateArgs>): Prisma.PrismaPromise<GetHotLineAggregateType<T>>

    /**
     * Group by HotLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotLineGroupByArgs['orderBy'] }
        : { orderBy?: HotLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HotLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HotLineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HotLine base type for findUnique actions
   */
  export type HotLineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * Filter, which HotLine to fetch.
     */
    where: HotLineWhereUniqueInput
  }

  /**
   * HotLine findUnique
   */
  export interface HotLineFindUniqueArgs extends HotLineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HotLine findUniqueOrThrow
   */
  export type HotLineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * Filter, which HotLine to fetch.
     */
    where: HotLineWhereUniqueInput
  }


  /**
   * HotLine base type for findFirst actions
   */
  export type HotLineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * Filter, which HotLine to fetch.
     */
    where?: HotLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotLines to fetch.
     */
    orderBy?: Enumerable<HotLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotLines.
     */
    cursor?: HotLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotLines.
     */
    distinct?: Enumerable<HotLineScalarFieldEnum>
  }

  /**
   * HotLine findFirst
   */
  export interface HotLineFindFirstArgs extends HotLineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HotLine findFirstOrThrow
   */
  export type HotLineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * Filter, which HotLine to fetch.
     */
    where?: HotLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotLines to fetch.
     */
    orderBy?: Enumerable<HotLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotLines.
     */
    cursor?: HotLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotLines.
     */
    distinct?: Enumerable<HotLineScalarFieldEnum>
  }


  /**
   * HotLine findMany
   */
  export type HotLineFindManyArgs = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * Filter, which HotLines to fetch.
     */
    where?: HotLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotLines to fetch.
     */
    orderBy?: Enumerable<HotLineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotLines.
     */
    cursor?: HotLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotLines.
     */
    skip?: number
    distinct?: Enumerable<HotLineScalarFieldEnum>
  }


  /**
   * HotLine create
   */
  export type HotLineCreateArgs = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * The data needed to create a HotLine.
     */
    data: XOR<HotLineCreateInput, HotLineUncheckedCreateInput>
  }


  /**
   * HotLine createMany
   */
  export type HotLineCreateManyArgs = {
    /**
     * The data used to create many HotLines.
     */
    data: Enumerable<HotLineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HotLine update
   */
  export type HotLineUpdateArgs = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * The data needed to update a HotLine.
     */
    data: XOR<HotLineUpdateInput, HotLineUncheckedUpdateInput>
    /**
     * Choose, which HotLine to update.
     */
    where: HotLineWhereUniqueInput
  }


  /**
   * HotLine updateMany
   */
  export type HotLineUpdateManyArgs = {
    /**
     * The data used to update HotLines.
     */
    data: XOR<HotLineUpdateManyMutationInput, HotLineUncheckedUpdateManyInput>
    /**
     * Filter which HotLines to update
     */
    where?: HotLineWhereInput
  }


  /**
   * HotLine upsert
   */
  export type HotLineUpsertArgs = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * The filter to search for the HotLine to update in case it exists.
     */
    where: HotLineWhereUniqueInput
    /**
     * In case the HotLine found by the `where` argument doesn't exist, create a new HotLine with this data.
     */
    create: XOR<HotLineCreateInput, HotLineUncheckedCreateInput>
    /**
     * In case the HotLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotLineUpdateInput, HotLineUncheckedUpdateInput>
  }


  /**
   * HotLine delete
   */
  export type HotLineDeleteArgs = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
    /**
     * Filter which HotLine to delete.
     */
    where: HotLineWhereUniqueInput
  }


  /**
   * HotLine deleteMany
   */
  export type HotLineDeleteManyArgs = {
    /**
     * Filter which HotLines to delete
     */
    where?: HotLineWhereInput
  }


  /**
   * HotLine without action
   */
  export type HotLineArgs = {
    /**
     * Select specific fields to fetch from the HotLine
     */
    select?: HotLineSelect | null
  }



  /**
   * Model ServiceSue
   */


  export type AggregateServiceSue = {
    _count: ServiceSueCountAggregateOutputType | null
    _min: ServiceSueMinAggregateOutputType | null
    _max: ServiceSueMaxAggregateOutputType | null
  }

  export type ServiceSueMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceSueMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceSueCountAggregateOutputType = {
    id: number
    name: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceSueMinAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceSueMaxAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceSueCountAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceSueAggregateArgs = {
    /**
     * Filter which ServiceSue to aggregate.
     */
    where?: ServiceSueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSues to fetch.
     */
    orderBy?: Enumerable<ServiceSueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSues
    **/
    _count?: true | ServiceSueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSueMaxAggregateInputType
  }

  export type GetServiceSueAggregateType<T extends ServiceSueAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSue[P]>
      : GetScalarType<T[P], AggregateServiceSue[P]>
  }




  export type ServiceSueGroupByArgs = {
    where?: ServiceSueWhereInput
    orderBy?: Enumerable<ServiceSueOrderByWithAggregationInput>
    by: ServiceSueScalarFieldEnum[]
    having?: ServiceSueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSueCountAggregateInputType | true
    _min?: ServiceSueMinAggregateInputType
    _max?: ServiceSueMaxAggregateInputType
  }


  export type ServiceSueGroupByOutputType = {
    id: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceSueCountAggregateOutputType | null
    _min: ServiceSueMinAggregateOutputType | null
    _max: ServiceSueMaxAggregateOutputType | null
  }

  type GetServiceSueGroupByPayload<T extends ServiceSueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ServiceSueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSueGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSueGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSueSelect = {
    id?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ServiceSueGetPayload<S extends boolean | null | undefined | ServiceSueArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ServiceSue :
    S extends undefined ? never :
    S extends { include: any } & (ServiceSueArgs | ServiceSueFindManyArgs)
    ? ServiceSue 
    : S extends { select: any } & (ServiceSueArgs | ServiceSueFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ServiceSue ? ServiceSue[P] : never
  } 
      : ServiceSue


  type ServiceSueCountArgs = 
    Omit<ServiceSueFindManyArgs, 'select' | 'include'> & {
      select?: ServiceSueCountAggregateInputType | true
    }

  export interface ServiceSueDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ServiceSue that matches the filter.
     * @param {ServiceSueFindUniqueArgs} args - Arguments to find a ServiceSue
     * @example
     * // Get one ServiceSue
     * const serviceSue = await prisma.serviceSue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceSueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServiceSueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ServiceSue'> extends True ? Prisma__ServiceSueClient<ServiceSueGetPayload<T>> : Prisma__ServiceSueClient<ServiceSueGetPayload<T> | null, null>

    /**
     * Find one ServiceSue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceSueFindUniqueOrThrowArgs} args - Arguments to find a ServiceSue
     * @example
     * // Get one ServiceSue
     * const serviceSue = await prisma.serviceSue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceSueFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ServiceSueFindUniqueOrThrowArgs>
    ): Prisma__ServiceSueClient<ServiceSueGetPayload<T>>

    /**
     * Find the first ServiceSue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSueFindFirstArgs} args - Arguments to find a ServiceSue
     * @example
     * // Get one ServiceSue
     * const serviceSue = await prisma.serviceSue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceSueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServiceSueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ServiceSue'> extends True ? Prisma__ServiceSueClient<ServiceSueGetPayload<T>> : Prisma__ServiceSueClient<ServiceSueGetPayload<T> | null, null>

    /**
     * Find the first ServiceSue that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSueFindFirstOrThrowArgs} args - Arguments to find a ServiceSue
     * @example
     * // Get one ServiceSue
     * const serviceSue = await prisma.serviceSue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceSueFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceSueFindFirstOrThrowArgs>
    ): Prisma__ServiceSueClient<ServiceSueGetPayload<T>>

    /**
     * Find zero or more ServiceSues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSues
     * const serviceSues = await prisma.serviceSue.findMany()
     * 
     * // Get first 10 ServiceSues
     * const serviceSues = await prisma.serviceSue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSueWithIdOnly = await prisma.serviceSue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceSueFindManyArgs>(
      args?: SelectSubset<T, ServiceSueFindManyArgs>
    ): Prisma.PrismaPromise<Array<ServiceSueGetPayload<T>>>

    /**
     * Create a ServiceSue.
     * @param {ServiceSueCreateArgs} args - Arguments to create a ServiceSue.
     * @example
     * // Create one ServiceSue
     * const ServiceSue = await prisma.serviceSue.create({
     *   data: {
     *     // ... data to create a ServiceSue
     *   }
     * })
     * 
    **/
    create<T extends ServiceSueCreateArgs>(
      args: SelectSubset<T, ServiceSueCreateArgs>
    ): Prisma__ServiceSueClient<ServiceSueGetPayload<T>>

    /**
     * Create many ServiceSues.
     *     @param {ServiceSueCreateManyArgs} args - Arguments to create many ServiceSues.
     *     @example
     *     // Create many ServiceSues
     *     const serviceSue = await prisma.serviceSue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceSueCreateManyArgs>(
      args?: SelectSubset<T, ServiceSueCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceSue.
     * @param {ServiceSueDeleteArgs} args - Arguments to delete one ServiceSue.
     * @example
     * // Delete one ServiceSue
     * const ServiceSue = await prisma.serviceSue.delete({
     *   where: {
     *     // ... filter to delete one ServiceSue
     *   }
     * })
     * 
    **/
    delete<T extends ServiceSueDeleteArgs>(
      args: SelectSubset<T, ServiceSueDeleteArgs>
    ): Prisma__ServiceSueClient<ServiceSueGetPayload<T>>

    /**
     * Update one ServiceSue.
     * @param {ServiceSueUpdateArgs} args - Arguments to update one ServiceSue.
     * @example
     * // Update one ServiceSue
     * const serviceSue = await prisma.serviceSue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceSueUpdateArgs>(
      args: SelectSubset<T, ServiceSueUpdateArgs>
    ): Prisma__ServiceSueClient<ServiceSueGetPayload<T>>

    /**
     * Delete zero or more ServiceSues.
     * @param {ServiceSueDeleteManyArgs} args - Arguments to filter ServiceSues to delete.
     * @example
     * // Delete a few ServiceSues
     * const { count } = await prisma.serviceSue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceSueDeleteManyArgs>(
      args?: SelectSubset<T, ServiceSueDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSues
     * const serviceSue = await prisma.serviceSue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceSueUpdateManyArgs>(
      args: SelectSubset<T, ServiceSueUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceSue.
     * @param {ServiceSueUpsertArgs} args - Arguments to update or create a ServiceSue.
     * @example
     * // Update or create a ServiceSue
     * const serviceSue = await prisma.serviceSue.upsert({
     *   create: {
     *     // ... data to create a ServiceSue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSue we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceSueUpsertArgs>(
      args: SelectSubset<T, ServiceSueUpsertArgs>
    ): Prisma__ServiceSueClient<ServiceSueGetPayload<T>>

    /**
     * Count the number of ServiceSues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSueCountArgs} args - Arguments to filter ServiceSues to count.
     * @example
     * // Count the number of ServiceSues
     * const count = await prisma.serviceSue.count({
     *   where: {
     *     // ... the filter for the ServiceSues we want to count
     *   }
     * })
    **/
    count<T extends ServiceSueCountArgs>(
      args?: Subset<T, ServiceSueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSueAggregateArgs>(args: Subset<T, ServiceSueAggregateArgs>): Prisma.PrismaPromise<GetServiceSueAggregateType<T>>

    /**
     * Group by ServiceSue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSueGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServiceSueClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ServiceSue base type for findUnique actions
   */
  export type ServiceSueFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * Filter, which ServiceSue to fetch.
     */
    where: ServiceSueWhereUniqueInput
  }

  /**
   * ServiceSue findUnique
   */
  export interface ServiceSueFindUniqueArgs extends ServiceSueFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSue findUniqueOrThrow
   */
  export type ServiceSueFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * Filter, which ServiceSue to fetch.
     */
    where: ServiceSueWhereUniqueInput
  }


  /**
   * ServiceSue base type for findFirst actions
   */
  export type ServiceSueFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * Filter, which ServiceSue to fetch.
     */
    where?: ServiceSueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSues to fetch.
     */
    orderBy?: Enumerable<ServiceSueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSues.
     */
    cursor?: ServiceSueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSues.
     */
    distinct?: Enumerable<ServiceSueScalarFieldEnum>
  }

  /**
   * ServiceSue findFirst
   */
  export interface ServiceSueFindFirstArgs extends ServiceSueFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ServiceSue findFirstOrThrow
   */
  export type ServiceSueFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * Filter, which ServiceSue to fetch.
     */
    where?: ServiceSueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSues to fetch.
     */
    orderBy?: Enumerable<ServiceSueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSues.
     */
    cursor?: ServiceSueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSues.
     */
    distinct?: Enumerable<ServiceSueScalarFieldEnum>
  }


  /**
   * ServiceSue findMany
   */
  export type ServiceSueFindManyArgs = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * Filter, which ServiceSues to fetch.
     */
    where?: ServiceSueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSues to fetch.
     */
    orderBy?: Enumerable<ServiceSueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSues.
     */
    cursor?: ServiceSueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSues.
     */
    skip?: number
    distinct?: Enumerable<ServiceSueScalarFieldEnum>
  }


  /**
   * ServiceSue create
   */
  export type ServiceSueCreateArgs = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * The data needed to create a ServiceSue.
     */
    data: XOR<ServiceSueCreateInput, ServiceSueUncheckedCreateInput>
  }


  /**
   * ServiceSue createMany
   */
  export type ServiceSueCreateManyArgs = {
    /**
     * The data used to create many ServiceSues.
     */
    data: Enumerable<ServiceSueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ServiceSue update
   */
  export type ServiceSueUpdateArgs = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * The data needed to update a ServiceSue.
     */
    data: XOR<ServiceSueUpdateInput, ServiceSueUncheckedUpdateInput>
    /**
     * Choose, which ServiceSue to update.
     */
    where: ServiceSueWhereUniqueInput
  }


  /**
   * ServiceSue updateMany
   */
  export type ServiceSueUpdateManyArgs = {
    /**
     * The data used to update ServiceSues.
     */
    data: XOR<ServiceSueUpdateManyMutationInput, ServiceSueUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSues to update
     */
    where?: ServiceSueWhereInput
  }


  /**
   * ServiceSue upsert
   */
  export type ServiceSueUpsertArgs = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * The filter to search for the ServiceSue to update in case it exists.
     */
    where: ServiceSueWhereUniqueInput
    /**
     * In case the ServiceSue found by the `where` argument doesn't exist, create a new ServiceSue with this data.
     */
    create: XOR<ServiceSueCreateInput, ServiceSueUncheckedCreateInput>
    /**
     * In case the ServiceSue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSueUpdateInput, ServiceSueUncheckedUpdateInput>
  }


  /**
   * ServiceSue delete
   */
  export type ServiceSueDeleteArgs = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
    /**
     * Filter which ServiceSue to delete.
     */
    where: ServiceSueWhereUniqueInput
  }


  /**
   * ServiceSue deleteMany
   */
  export type ServiceSueDeleteManyArgs = {
    /**
     * Filter which ServiceSues to delete
     */
    where?: ServiceSueWhereInput
  }


  /**
   * ServiceSue without action
   */
  export type ServiceSueArgs = {
    /**
     * Select specific fields to fetch from the ServiceSue
     */
    select?: ServiceSueSelect | null
  }



  /**
   * Model TypeComputer
   */


  export type AggregateTypeComputer = {
    _count: TypeComputerCountAggregateOutputType | null
    _min: TypeComputerMinAggregateOutputType | null
    _max: TypeComputerMaxAggregateOutputType | null
  }

  export type TypeComputerMinAggregateOutputType = {
    id: string | null
    incidentTypes: string | null
    code: string | null
    vector: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeComputerMaxAggregateOutputType = {
    id: string | null
    incidentTypes: string | null
    code: string | null
    vector: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeComputerCountAggregateOutputType = {
    id: number
    incidentTypes: number
    code: number
    vector: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TypeComputerMinAggregateInputType = {
    id?: true
    incidentTypes?: true
    code?: true
    vector?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeComputerMaxAggregateInputType = {
    id?: true
    incidentTypes?: true
    code?: true
    vector?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeComputerCountAggregateInputType = {
    id?: true
    incidentTypes?: true
    code?: true
    vector?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TypeComputerAggregateArgs = {
    /**
     * Filter which TypeComputer to aggregate.
     */
    where?: TypeComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeComputers to fetch.
     */
    orderBy?: Enumerable<TypeComputerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeComputers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeComputers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeComputers
    **/
    _count?: true | TypeComputerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeComputerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeComputerMaxAggregateInputType
  }

  export type GetTypeComputerAggregateType<T extends TypeComputerAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeComputer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeComputer[P]>
      : GetScalarType<T[P], AggregateTypeComputer[P]>
  }




  export type TypeComputerGroupByArgs = {
    where?: TypeComputerWhereInput
    orderBy?: Enumerable<TypeComputerOrderByWithAggregationInput>
    by: TypeComputerScalarFieldEnum[]
    having?: TypeComputerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeComputerCountAggregateInputType | true
    _min?: TypeComputerMinAggregateInputType
    _max?: TypeComputerMaxAggregateInputType
  }


  export type TypeComputerGroupByOutputType = {
    id: string
    incidentTypes: string
    code: string
    vector: string
    nameuz: string
    nameru: string
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TypeComputerCountAggregateOutputType | null
    _min: TypeComputerMinAggregateOutputType | null
    _max: TypeComputerMaxAggregateOutputType | null
  }

  type GetTypeComputerGroupByPayload<T extends TypeComputerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypeComputerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeComputerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeComputerGroupByOutputType[P]>
            : GetScalarType<T[P], TypeComputerGroupByOutputType[P]>
        }
      >
    >


  export type TypeComputerSelect = {
    id?: boolean
    incidentTypes?: boolean
    code?: boolean
    vector?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TypeComputerGetPayload<S extends boolean | null | undefined | TypeComputerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TypeComputer :
    S extends undefined ? never :
    S extends { include: any } & (TypeComputerArgs | TypeComputerFindManyArgs)
    ? TypeComputer 
    : S extends { select: any } & (TypeComputerArgs | TypeComputerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TypeComputer ? TypeComputer[P] : never
  } 
      : TypeComputer


  type TypeComputerCountArgs = 
    Omit<TypeComputerFindManyArgs, 'select' | 'include'> & {
      select?: TypeComputerCountAggregateInputType | true
    }

  export interface TypeComputerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TypeComputer that matches the filter.
     * @param {TypeComputerFindUniqueArgs} args - Arguments to find a TypeComputer
     * @example
     * // Get one TypeComputer
     * const typeComputer = await prisma.typeComputer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypeComputerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypeComputerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TypeComputer'> extends True ? Prisma__TypeComputerClient<TypeComputerGetPayload<T>> : Prisma__TypeComputerClient<TypeComputerGetPayload<T> | null, null>

    /**
     * Find one TypeComputer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypeComputerFindUniqueOrThrowArgs} args - Arguments to find a TypeComputer
     * @example
     * // Get one TypeComputer
     * const typeComputer = await prisma.typeComputer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypeComputerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TypeComputerFindUniqueOrThrowArgs>
    ): Prisma__TypeComputerClient<TypeComputerGetPayload<T>>

    /**
     * Find the first TypeComputer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComputerFindFirstArgs} args - Arguments to find a TypeComputer
     * @example
     * // Get one TypeComputer
     * const typeComputer = await prisma.typeComputer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypeComputerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypeComputerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TypeComputer'> extends True ? Prisma__TypeComputerClient<TypeComputerGetPayload<T>> : Prisma__TypeComputerClient<TypeComputerGetPayload<T> | null, null>

    /**
     * Find the first TypeComputer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComputerFindFirstOrThrowArgs} args - Arguments to find a TypeComputer
     * @example
     * // Get one TypeComputer
     * const typeComputer = await prisma.typeComputer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypeComputerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TypeComputerFindFirstOrThrowArgs>
    ): Prisma__TypeComputerClient<TypeComputerGetPayload<T>>

    /**
     * Find zero or more TypeComputers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComputerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeComputers
     * const typeComputers = await prisma.typeComputer.findMany()
     * 
     * // Get first 10 TypeComputers
     * const typeComputers = await prisma.typeComputer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeComputerWithIdOnly = await prisma.typeComputer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypeComputerFindManyArgs>(
      args?: SelectSubset<T, TypeComputerFindManyArgs>
    ): Prisma.PrismaPromise<Array<TypeComputerGetPayload<T>>>

    /**
     * Create a TypeComputer.
     * @param {TypeComputerCreateArgs} args - Arguments to create a TypeComputer.
     * @example
     * // Create one TypeComputer
     * const TypeComputer = await prisma.typeComputer.create({
     *   data: {
     *     // ... data to create a TypeComputer
     *   }
     * })
     * 
    **/
    create<T extends TypeComputerCreateArgs>(
      args: SelectSubset<T, TypeComputerCreateArgs>
    ): Prisma__TypeComputerClient<TypeComputerGetPayload<T>>

    /**
     * Create many TypeComputers.
     *     @param {TypeComputerCreateManyArgs} args - Arguments to create many TypeComputers.
     *     @example
     *     // Create many TypeComputers
     *     const typeComputer = await prisma.typeComputer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypeComputerCreateManyArgs>(
      args?: SelectSubset<T, TypeComputerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypeComputer.
     * @param {TypeComputerDeleteArgs} args - Arguments to delete one TypeComputer.
     * @example
     * // Delete one TypeComputer
     * const TypeComputer = await prisma.typeComputer.delete({
     *   where: {
     *     // ... filter to delete one TypeComputer
     *   }
     * })
     * 
    **/
    delete<T extends TypeComputerDeleteArgs>(
      args: SelectSubset<T, TypeComputerDeleteArgs>
    ): Prisma__TypeComputerClient<TypeComputerGetPayload<T>>

    /**
     * Update one TypeComputer.
     * @param {TypeComputerUpdateArgs} args - Arguments to update one TypeComputer.
     * @example
     * // Update one TypeComputer
     * const typeComputer = await prisma.typeComputer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypeComputerUpdateArgs>(
      args: SelectSubset<T, TypeComputerUpdateArgs>
    ): Prisma__TypeComputerClient<TypeComputerGetPayload<T>>

    /**
     * Delete zero or more TypeComputers.
     * @param {TypeComputerDeleteManyArgs} args - Arguments to filter TypeComputers to delete.
     * @example
     * // Delete a few TypeComputers
     * const { count } = await prisma.typeComputer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypeComputerDeleteManyArgs>(
      args?: SelectSubset<T, TypeComputerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeComputers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComputerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeComputers
     * const typeComputer = await prisma.typeComputer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypeComputerUpdateManyArgs>(
      args: SelectSubset<T, TypeComputerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeComputer.
     * @param {TypeComputerUpsertArgs} args - Arguments to update or create a TypeComputer.
     * @example
     * // Update or create a TypeComputer
     * const typeComputer = await prisma.typeComputer.upsert({
     *   create: {
     *     // ... data to create a TypeComputer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeComputer we want to update
     *   }
     * })
    **/
    upsert<T extends TypeComputerUpsertArgs>(
      args: SelectSubset<T, TypeComputerUpsertArgs>
    ): Prisma__TypeComputerClient<TypeComputerGetPayload<T>>

    /**
     * Count the number of TypeComputers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComputerCountArgs} args - Arguments to filter TypeComputers to count.
     * @example
     * // Count the number of TypeComputers
     * const count = await prisma.typeComputer.count({
     *   where: {
     *     // ... the filter for the TypeComputers we want to count
     *   }
     * })
    **/
    count<T extends TypeComputerCountArgs>(
      args?: Subset<T, TypeComputerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeComputerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeComputer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComputerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeComputerAggregateArgs>(args: Subset<T, TypeComputerAggregateArgs>): Prisma.PrismaPromise<GetTypeComputerAggregateType<T>>

    /**
     * Group by TypeComputer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComputerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeComputerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeComputerGroupByArgs['orderBy'] }
        : { orderBy?: TypeComputerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeComputerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeComputerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeComputer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypeComputerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TypeComputer base type for findUnique actions
   */
  export type TypeComputerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * Filter, which TypeComputer to fetch.
     */
    where: TypeComputerWhereUniqueInput
  }

  /**
   * TypeComputer findUnique
   */
  export interface TypeComputerFindUniqueArgs extends TypeComputerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypeComputer findUniqueOrThrow
   */
  export type TypeComputerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * Filter, which TypeComputer to fetch.
     */
    where: TypeComputerWhereUniqueInput
  }


  /**
   * TypeComputer base type for findFirst actions
   */
  export type TypeComputerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * Filter, which TypeComputer to fetch.
     */
    where?: TypeComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeComputers to fetch.
     */
    orderBy?: Enumerable<TypeComputerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeComputers.
     */
    cursor?: TypeComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeComputers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeComputers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeComputers.
     */
    distinct?: Enumerable<TypeComputerScalarFieldEnum>
  }

  /**
   * TypeComputer findFirst
   */
  export interface TypeComputerFindFirstArgs extends TypeComputerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypeComputer findFirstOrThrow
   */
  export type TypeComputerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * Filter, which TypeComputer to fetch.
     */
    where?: TypeComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeComputers to fetch.
     */
    orderBy?: Enumerable<TypeComputerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeComputers.
     */
    cursor?: TypeComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeComputers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeComputers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeComputers.
     */
    distinct?: Enumerable<TypeComputerScalarFieldEnum>
  }


  /**
   * TypeComputer findMany
   */
  export type TypeComputerFindManyArgs = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * Filter, which TypeComputers to fetch.
     */
    where?: TypeComputerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeComputers to fetch.
     */
    orderBy?: Enumerable<TypeComputerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeComputers.
     */
    cursor?: TypeComputerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeComputers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeComputers.
     */
    skip?: number
    distinct?: Enumerable<TypeComputerScalarFieldEnum>
  }


  /**
   * TypeComputer create
   */
  export type TypeComputerCreateArgs = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * The data needed to create a TypeComputer.
     */
    data: XOR<TypeComputerCreateInput, TypeComputerUncheckedCreateInput>
  }


  /**
   * TypeComputer createMany
   */
  export type TypeComputerCreateManyArgs = {
    /**
     * The data used to create many TypeComputers.
     */
    data: Enumerable<TypeComputerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TypeComputer update
   */
  export type TypeComputerUpdateArgs = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * The data needed to update a TypeComputer.
     */
    data: XOR<TypeComputerUpdateInput, TypeComputerUncheckedUpdateInput>
    /**
     * Choose, which TypeComputer to update.
     */
    where: TypeComputerWhereUniqueInput
  }


  /**
   * TypeComputer updateMany
   */
  export type TypeComputerUpdateManyArgs = {
    /**
     * The data used to update TypeComputers.
     */
    data: XOR<TypeComputerUpdateManyMutationInput, TypeComputerUncheckedUpdateManyInput>
    /**
     * Filter which TypeComputers to update
     */
    where?: TypeComputerWhereInput
  }


  /**
   * TypeComputer upsert
   */
  export type TypeComputerUpsertArgs = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * The filter to search for the TypeComputer to update in case it exists.
     */
    where: TypeComputerWhereUniqueInput
    /**
     * In case the TypeComputer found by the `where` argument doesn't exist, create a new TypeComputer with this data.
     */
    create: XOR<TypeComputerCreateInput, TypeComputerUncheckedCreateInput>
    /**
     * In case the TypeComputer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeComputerUpdateInput, TypeComputerUncheckedUpdateInput>
  }


  /**
   * TypeComputer delete
   */
  export type TypeComputerDeleteArgs = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
    /**
     * Filter which TypeComputer to delete.
     */
    where: TypeComputerWhereUniqueInput
  }


  /**
   * TypeComputer deleteMany
   */
  export type TypeComputerDeleteManyArgs = {
    /**
     * Filter which TypeComputers to delete
     */
    where?: TypeComputerWhereInput
  }


  /**
   * TypeComputer without action
   */
  export type TypeComputerArgs = {
    /**
     * Select specific fields to fetch from the TypeComputer
     */
    select?: TypeComputerSelect | null
  }



  /**
   * Model AboutMeans
   */


  export type AggregateAboutMeans = {
    _count: AboutMeansCountAggregateOutputType | null
    _min: AboutMeansMinAggregateOutputType | null
    _max: AboutMeansMaxAggregateOutputType | null
  }

  export type AboutMeansMinAggregateOutputType = {
    id: string | null
    code: string | null
    toolDetails: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutMeansMaxAggregateOutputType = {
    id: string | null
    code: string | null
    toolDetails: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AboutMeansCountAggregateOutputType = {
    id: number
    code: number
    toolDetails: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AboutMeansMinAggregateInputType = {
    id?: true
    code?: true
    toolDetails?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutMeansMaxAggregateInputType = {
    id?: true
    code?: true
    toolDetails?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AboutMeansCountAggregateInputType = {
    id?: true
    code?: true
    toolDetails?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AboutMeansAggregateArgs = {
    /**
     * Filter which AboutMeans to aggregate.
     */
    where?: AboutMeansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutMeans to fetch.
     */
    orderBy?: Enumerable<AboutMeansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AboutMeansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutMeans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutMeans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AboutMeans
    **/
    _count?: true | AboutMeansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutMeansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutMeansMaxAggregateInputType
  }

  export type GetAboutMeansAggregateType<T extends AboutMeansAggregateArgs> = {
        [P in keyof T & keyof AggregateAboutMeans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAboutMeans[P]>
      : GetScalarType<T[P], AggregateAboutMeans[P]>
  }




  export type AboutMeansGroupByArgs = {
    where?: AboutMeansWhereInput
    orderBy?: Enumerable<AboutMeansOrderByWithAggregationInput>
    by: AboutMeansScalarFieldEnum[]
    having?: AboutMeansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutMeansCountAggregateInputType | true
    _min?: AboutMeansMinAggregateInputType
    _max?: AboutMeansMaxAggregateInputType
  }


  export type AboutMeansGroupByOutputType = {
    id: string
    code: string
    toolDetails: string
    nameuz: string
    nameru: string
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AboutMeansCountAggregateOutputType | null
    _min: AboutMeansMinAggregateOutputType | null
    _max: AboutMeansMaxAggregateOutputType | null
  }

  type GetAboutMeansGroupByPayload<T extends AboutMeansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AboutMeansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutMeansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutMeansGroupByOutputType[P]>
            : GetScalarType<T[P], AboutMeansGroupByOutputType[P]>
        }
      >
    >


  export type AboutMeansSelect = {
    id?: boolean
    code?: boolean
    toolDetails?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AboutMeansGetPayload<S extends boolean | null | undefined | AboutMeansArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AboutMeans :
    S extends undefined ? never :
    S extends { include: any } & (AboutMeansArgs | AboutMeansFindManyArgs)
    ? AboutMeans 
    : S extends { select: any } & (AboutMeansArgs | AboutMeansFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AboutMeans ? AboutMeans[P] : never
  } 
      : AboutMeans


  type AboutMeansCountArgs = 
    Omit<AboutMeansFindManyArgs, 'select' | 'include'> & {
      select?: AboutMeansCountAggregateInputType | true
    }

  export interface AboutMeansDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AboutMeans that matches the filter.
     * @param {AboutMeansFindUniqueArgs} args - Arguments to find a AboutMeans
     * @example
     * // Get one AboutMeans
     * const aboutMeans = await prisma.aboutMeans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AboutMeansFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AboutMeansFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AboutMeans'> extends True ? Prisma__AboutMeansClient<AboutMeansGetPayload<T>> : Prisma__AboutMeansClient<AboutMeansGetPayload<T> | null, null>

    /**
     * Find one AboutMeans that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AboutMeansFindUniqueOrThrowArgs} args - Arguments to find a AboutMeans
     * @example
     * // Get one AboutMeans
     * const aboutMeans = await prisma.aboutMeans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AboutMeansFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AboutMeansFindUniqueOrThrowArgs>
    ): Prisma__AboutMeansClient<AboutMeansGetPayload<T>>

    /**
     * Find the first AboutMeans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutMeansFindFirstArgs} args - Arguments to find a AboutMeans
     * @example
     * // Get one AboutMeans
     * const aboutMeans = await prisma.aboutMeans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AboutMeansFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AboutMeansFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AboutMeans'> extends True ? Prisma__AboutMeansClient<AboutMeansGetPayload<T>> : Prisma__AboutMeansClient<AboutMeansGetPayload<T> | null, null>

    /**
     * Find the first AboutMeans that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutMeansFindFirstOrThrowArgs} args - Arguments to find a AboutMeans
     * @example
     * // Get one AboutMeans
     * const aboutMeans = await prisma.aboutMeans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AboutMeansFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AboutMeansFindFirstOrThrowArgs>
    ): Prisma__AboutMeansClient<AboutMeansGetPayload<T>>

    /**
     * Find zero or more AboutMeans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutMeansFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AboutMeans
     * const aboutMeans = await prisma.aboutMeans.findMany()
     * 
     * // Get first 10 AboutMeans
     * const aboutMeans = await prisma.aboutMeans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutMeansWithIdOnly = await prisma.aboutMeans.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AboutMeansFindManyArgs>(
      args?: SelectSubset<T, AboutMeansFindManyArgs>
    ): Prisma.PrismaPromise<Array<AboutMeansGetPayload<T>>>

    /**
     * Create a AboutMeans.
     * @param {AboutMeansCreateArgs} args - Arguments to create a AboutMeans.
     * @example
     * // Create one AboutMeans
     * const AboutMeans = await prisma.aboutMeans.create({
     *   data: {
     *     // ... data to create a AboutMeans
     *   }
     * })
     * 
    **/
    create<T extends AboutMeansCreateArgs>(
      args: SelectSubset<T, AboutMeansCreateArgs>
    ): Prisma__AboutMeansClient<AboutMeansGetPayload<T>>

    /**
     * Create many AboutMeans.
     *     @param {AboutMeansCreateManyArgs} args - Arguments to create many AboutMeans.
     *     @example
     *     // Create many AboutMeans
     *     const aboutMeans = await prisma.aboutMeans.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AboutMeansCreateManyArgs>(
      args?: SelectSubset<T, AboutMeansCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AboutMeans.
     * @param {AboutMeansDeleteArgs} args - Arguments to delete one AboutMeans.
     * @example
     * // Delete one AboutMeans
     * const AboutMeans = await prisma.aboutMeans.delete({
     *   where: {
     *     // ... filter to delete one AboutMeans
     *   }
     * })
     * 
    **/
    delete<T extends AboutMeansDeleteArgs>(
      args: SelectSubset<T, AboutMeansDeleteArgs>
    ): Prisma__AboutMeansClient<AboutMeansGetPayload<T>>

    /**
     * Update one AboutMeans.
     * @param {AboutMeansUpdateArgs} args - Arguments to update one AboutMeans.
     * @example
     * // Update one AboutMeans
     * const aboutMeans = await prisma.aboutMeans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AboutMeansUpdateArgs>(
      args: SelectSubset<T, AboutMeansUpdateArgs>
    ): Prisma__AboutMeansClient<AboutMeansGetPayload<T>>

    /**
     * Delete zero or more AboutMeans.
     * @param {AboutMeansDeleteManyArgs} args - Arguments to filter AboutMeans to delete.
     * @example
     * // Delete a few AboutMeans
     * const { count } = await prisma.aboutMeans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AboutMeansDeleteManyArgs>(
      args?: SelectSubset<T, AboutMeansDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AboutMeans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutMeansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AboutMeans
     * const aboutMeans = await prisma.aboutMeans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AboutMeansUpdateManyArgs>(
      args: SelectSubset<T, AboutMeansUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AboutMeans.
     * @param {AboutMeansUpsertArgs} args - Arguments to update or create a AboutMeans.
     * @example
     * // Update or create a AboutMeans
     * const aboutMeans = await prisma.aboutMeans.upsert({
     *   create: {
     *     // ... data to create a AboutMeans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AboutMeans we want to update
     *   }
     * })
    **/
    upsert<T extends AboutMeansUpsertArgs>(
      args: SelectSubset<T, AboutMeansUpsertArgs>
    ): Prisma__AboutMeansClient<AboutMeansGetPayload<T>>

    /**
     * Count the number of AboutMeans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutMeansCountArgs} args - Arguments to filter AboutMeans to count.
     * @example
     * // Count the number of AboutMeans
     * const count = await prisma.aboutMeans.count({
     *   where: {
     *     // ... the filter for the AboutMeans we want to count
     *   }
     * })
    **/
    count<T extends AboutMeansCountArgs>(
      args?: Subset<T, AboutMeansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutMeansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AboutMeans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutMeansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutMeansAggregateArgs>(args: Subset<T, AboutMeansAggregateArgs>): Prisma.PrismaPromise<GetAboutMeansAggregateType<T>>

    /**
     * Group by AboutMeans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutMeansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AboutMeansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AboutMeansGroupByArgs['orderBy'] }
        : { orderBy?: AboutMeansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AboutMeansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutMeansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AboutMeans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AboutMeansClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AboutMeans base type for findUnique actions
   */
  export type AboutMeansFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * Filter, which AboutMeans to fetch.
     */
    where: AboutMeansWhereUniqueInput
  }

  /**
   * AboutMeans findUnique
   */
  export interface AboutMeansFindUniqueArgs extends AboutMeansFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AboutMeans findUniqueOrThrow
   */
  export type AboutMeansFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * Filter, which AboutMeans to fetch.
     */
    where: AboutMeansWhereUniqueInput
  }


  /**
   * AboutMeans base type for findFirst actions
   */
  export type AboutMeansFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * Filter, which AboutMeans to fetch.
     */
    where?: AboutMeansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutMeans to fetch.
     */
    orderBy?: Enumerable<AboutMeansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutMeans.
     */
    cursor?: AboutMeansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutMeans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutMeans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutMeans.
     */
    distinct?: Enumerable<AboutMeansScalarFieldEnum>
  }

  /**
   * AboutMeans findFirst
   */
  export interface AboutMeansFindFirstArgs extends AboutMeansFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AboutMeans findFirstOrThrow
   */
  export type AboutMeansFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * Filter, which AboutMeans to fetch.
     */
    where?: AboutMeansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutMeans to fetch.
     */
    orderBy?: Enumerable<AboutMeansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AboutMeans.
     */
    cursor?: AboutMeansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutMeans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutMeans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AboutMeans.
     */
    distinct?: Enumerable<AboutMeansScalarFieldEnum>
  }


  /**
   * AboutMeans findMany
   */
  export type AboutMeansFindManyArgs = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * Filter, which AboutMeans to fetch.
     */
    where?: AboutMeansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AboutMeans to fetch.
     */
    orderBy?: Enumerable<AboutMeansOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AboutMeans.
     */
    cursor?: AboutMeansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AboutMeans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AboutMeans.
     */
    skip?: number
    distinct?: Enumerable<AboutMeansScalarFieldEnum>
  }


  /**
   * AboutMeans create
   */
  export type AboutMeansCreateArgs = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * The data needed to create a AboutMeans.
     */
    data: XOR<AboutMeansCreateInput, AboutMeansUncheckedCreateInput>
  }


  /**
   * AboutMeans createMany
   */
  export type AboutMeansCreateManyArgs = {
    /**
     * The data used to create many AboutMeans.
     */
    data: Enumerable<AboutMeansCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AboutMeans update
   */
  export type AboutMeansUpdateArgs = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * The data needed to update a AboutMeans.
     */
    data: XOR<AboutMeansUpdateInput, AboutMeansUncheckedUpdateInput>
    /**
     * Choose, which AboutMeans to update.
     */
    where: AboutMeansWhereUniqueInput
  }


  /**
   * AboutMeans updateMany
   */
  export type AboutMeansUpdateManyArgs = {
    /**
     * The data used to update AboutMeans.
     */
    data: XOR<AboutMeansUpdateManyMutationInput, AboutMeansUncheckedUpdateManyInput>
    /**
     * Filter which AboutMeans to update
     */
    where?: AboutMeansWhereInput
  }


  /**
   * AboutMeans upsert
   */
  export type AboutMeansUpsertArgs = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * The filter to search for the AboutMeans to update in case it exists.
     */
    where: AboutMeansWhereUniqueInput
    /**
     * In case the AboutMeans found by the `where` argument doesn't exist, create a new AboutMeans with this data.
     */
    create: XOR<AboutMeansCreateInput, AboutMeansUncheckedCreateInput>
    /**
     * In case the AboutMeans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AboutMeansUpdateInput, AboutMeansUncheckedUpdateInput>
  }


  /**
   * AboutMeans delete
   */
  export type AboutMeansDeleteArgs = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
    /**
     * Filter which AboutMeans to delete.
     */
    where: AboutMeansWhereUniqueInput
  }


  /**
   * AboutMeans deleteMany
   */
  export type AboutMeansDeleteManyArgs = {
    /**
     * Filter which AboutMeans to delete
     */
    where?: AboutMeansWhereInput
  }


  /**
   * AboutMeans without action
   */
  export type AboutMeansArgs = {
    /**
     * Select specific fields to fetch from the AboutMeans
     */
    select?: AboutMeansSelect | null
  }



  /**
   * Model SeverityLevel
   */


  export type AggregateSeverityLevel = {
    _count: SeverityLevelCountAggregateOutputType | null
    _min: SeverityLevelMinAggregateOutputType | null
    _max: SeverityLevelMaxAggregateOutputType | null
  }

  export type SeverityLevelMinAggregateOutputType = {
    id: string | null
    code: string | null
    severityLevel: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeverityLevelMaxAggregateOutputType = {
    id: string | null
    code: string | null
    severityLevel: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeverityLevelCountAggregateOutputType = {
    id: number
    code: number
    severityLevel: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeverityLevelMinAggregateInputType = {
    id?: true
    code?: true
    severityLevel?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeverityLevelMaxAggregateInputType = {
    id?: true
    code?: true
    severityLevel?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeverityLevelCountAggregateInputType = {
    id?: true
    code?: true
    severityLevel?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeverityLevelAggregateArgs = {
    /**
     * Filter which SeverityLevel to aggregate.
     */
    where?: SeverityLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeverityLevels to fetch.
     */
    orderBy?: Enumerable<SeverityLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeverityLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeverityLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeverityLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SeverityLevels
    **/
    _count?: true | SeverityLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeverityLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeverityLevelMaxAggregateInputType
  }

  export type GetSeverityLevelAggregateType<T extends SeverityLevelAggregateArgs> = {
        [P in keyof T & keyof AggregateSeverityLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeverityLevel[P]>
      : GetScalarType<T[P], AggregateSeverityLevel[P]>
  }




  export type SeverityLevelGroupByArgs = {
    where?: SeverityLevelWhereInput
    orderBy?: Enumerable<SeverityLevelOrderByWithAggregationInput>
    by: SeverityLevelScalarFieldEnum[]
    having?: SeverityLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeverityLevelCountAggregateInputType | true
    _min?: SeverityLevelMinAggregateInputType
    _max?: SeverityLevelMaxAggregateInputType
  }


  export type SeverityLevelGroupByOutputType = {
    id: string
    code: string
    severityLevel: string
    nameuz: string
    nameru: string
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SeverityLevelCountAggregateOutputType | null
    _min: SeverityLevelMinAggregateOutputType | null
    _max: SeverityLevelMaxAggregateOutputType | null
  }

  type GetSeverityLevelGroupByPayload<T extends SeverityLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SeverityLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeverityLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeverityLevelGroupByOutputType[P]>
            : GetScalarType<T[P], SeverityLevelGroupByOutputType[P]>
        }
      >
    >


  export type SeverityLevelSelect = {
    id?: boolean
    code?: boolean
    severityLevel?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type SeverityLevelGetPayload<S extends boolean | null | undefined | SeverityLevelArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SeverityLevel :
    S extends undefined ? never :
    S extends { include: any } & (SeverityLevelArgs | SeverityLevelFindManyArgs)
    ? SeverityLevel 
    : S extends { select: any } & (SeverityLevelArgs | SeverityLevelFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SeverityLevel ? SeverityLevel[P] : never
  } 
      : SeverityLevel


  type SeverityLevelCountArgs = 
    Omit<SeverityLevelFindManyArgs, 'select' | 'include'> & {
      select?: SeverityLevelCountAggregateInputType | true
    }

  export interface SeverityLevelDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SeverityLevel that matches the filter.
     * @param {SeverityLevelFindUniqueArgs} args - Arguments to find a SeverityLevel
     * @example
     * // Get one SeverityLevel
     * const severityLevel = await prisma.severityLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SeverityLevelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SeverityLevelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SeverityLevel'> extends True ? Prisma__SeverityLevelClient<SeverityLevelGetPayload<T>> : Prisma__SeverityLevelClient<SeverityLevelGetPayload<T> | null, null>

    /**
     * Find one SeverityLevel that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SeverityLevelFindUniqueOrThrowArgs} args - Arguments to find a SeverityLevel
     * @example
     * // Get one SeverityLevel
     * const severityLevel = await prisma.severityLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SeverityLevelFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SeverityLevelFindUniqueOrThrowArgs>
    ): Prisma__SeverityLevelClient<SeverityLevelGetPayload<T>>

    /**
     * Find the first SeverityLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelFindFirstArgs} args - Arguments to find a SeverityLevel
     * @example
     * // Get one SeverityLevel
     * const severityLevel = await prisma.severityLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SeverityLevelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SeverityLevelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SeverityLevel'> extends True ? Prisma__SeverityLevelClient<SeverityLevelGetPayload<T>> : Prisma__SeverityLevelClient<SeverityLevelGetPayload<T> | null, null>

    /**
     * Find the first SeverityLevel that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelFindFirstOrThrowArgs} args - Arguments to find a SeverityLevel
     * @example
     * // Get one SeverityLevel
     * const severityLevel = await prisma.severityLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SeverityLevelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SeverityLevelFindFirstOrThrowArgs>
    ): Prisma__SeverityLevelClient<SeverityLevelGetPayload<T>>

    /**
     * Find zero or more SeverityLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SeverityLevels
     * const severityLevels = await prisma.severityLevel.findMany()
     * 
     * // Get first 10 SeverityLevels
     * const severityLevels = await prisma.severityLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const severityLevelWithIdOnly = await prisma.severityLevel.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SeverityLevelFindManyArgs>(
      args?: SelectSubset<T, SeverityLevelFindManyArgs>
    ): Prisma.PrismaPromise<Array<SeverityLevelGetPayload<T>>>

    /**
     * Create a SeverityLevel.
     * @param {SeverityLevelCreateArgs} args - Arguments to create a SeverityLevel.
     * @example
     * // Create one SeverityLevel
     * const SeverityLevel = await prisma.severityLevel.create({
     *   data: {
     *     // ... data to create a SeverityLevel
     *   }
     * })
     * 
    **/
    create<T extends SeverityLevelCreateArgs>(
      args: SelectSubset<T, SeverityLevelCreateArgs>
    ): Prisma__SeverityLevelClient<SeverityLevelGetPayload<T>>

    /**
     * Create many SeverityLevels.
     *     @param {SeverityLevelCreateManyArgs} args - Arguments to create many SeverityLevels.
     *     @example
     *     // Create many SeverityLevels
     *     const severityLevel = await prisma.severityLevel.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SeverityLevelCreateManyArgs>(
      args?: SelectSubset<T, SeverityLevelCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SeverityLevel.
     * @param {SeverityLevelDeleteArgs} args - Arguments to delete one SeverityLevel.
     * @example
     * // Delete one SeverityLevel
     * const SeverityLevel = await prisma.severityLevel.delete({
     *   where: {
     *     // ... filter to delete one SeverityLevel
     *   }
     * })
     * 
    **/
    delete<T extends SeverityLevelDeleteArgs>(
      args: SelectSubset<T, SeverityLevelDeleteArgs>
    ): Prisma__SeverityLevelClient<SeverityLevelGetPayload<T>>

    /**
     * Update one SeverityLevel.
     * @param {SeverityLevelUpdateArgs} args - Arguments to update one SeverityLevel.
     * @example
     * // Update one SeverityLevel
     * const severityLevel = await prisma.severityLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SeverityLevelUpdateArgs>(
      args: SelectSubset<T, SeverityLevelUpdateArgs>
    ): Prisma__SeverityLevelClient<SeverityLevelGetPayload<T>>

    /**
     * Delete zero or more SeverityLevels.
     * @param {SeverityLevelDeleteManyArgs} args - Arguments to filter SeverityLevels to delete.
     * @example
     * // Delete a few SeverityLevels
     * const { count } = await prisma.severityLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SeverityLevelDeleteManyArgs>(
      args?: SelectSubset<T, SeverityLevelDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SeverityLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SeverityLevels
     * const severityLevel = await prisma.severityLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SeverityLevelUpdateManyArgs>(
      args: SelectSubset<T, SeverityLevelUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SeverityLevel.
     * @param {SeverityLevelUpsertArgs} args - Arguments to update or create a SeverityLevel.
     * @example
     * // Update or create a SeverityLevel
     * const severityLevel = await prisma.severityLevel.upsert({
     *   create: {
     *     // ... data to create a SeverityLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SeverityLevel we want to update
     *   }
     * })
    **/
    upsert<T extends SeverityLevelUpsertArgs>(
      args: SelectSubset<T, SeverityLevelUpsertArgs>
    ): Prisma__SeverityLevelClient<SeverityLevelGetPayload<T>>

    /**
     * Count the number of SeverityLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelCountArgs} args - Arguments to filter SeverityLevels to count.
     * @example
     * // Count the number of SeverityLevels
     * const count = await prisma.severityLevel.count({
     *   where: {
     *     // ... the filter for the SeverityLevels we want to count
     *   }
     * })
    **/
    count<T extends SeverityLevelCountArgs>(
      args?: Subset<T, SeverityLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeverityLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SeverityLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeverityLevelAggregateArgs>(args: Subset<T, SeverityLevelAggregateArgs>): Prisma.PrismaPromise<GetSeverityLevelAggregateType<T>>

    /**
     * Group by SeverityLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeverityLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeverityLevelGroupByArgs['orderBy'] }
        : { orderBy?: SeverityLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeverityLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeverityLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SeverityLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SeverityLevelClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SeverityLevel base type for findUnique actions
   */
  export type SeverityLevelFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * Filter, which SeverityLevel to fetch.
     */
    where: SeverityLevelWhereUniqueInput
  }

  /**
   * SeverityLevel findUnique
   */
  export interface SeverityLevelFindUniqueArgs extends SeverityLevelFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SeverityLevel findUniqueOrThrow
   */
  export type SeverityLevelFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * Filter, which SeverityLevel to fetch.
     */
    where: SeverityLevelWhereUniqueInput
  }


  /**
   * SeverityLevel base type for findFirst actions
   */
  export type SeverityLevelFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * Filter, which SeverityLevel to fetch.
     */
    where?: SeverityLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeverityLevels to fetch.
     */
    orderBy?: Enumerable<SeverityLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeverityLevels.
     */
    cursor?: SeverityLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeverityLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeverityLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeverityLevels.
     */
    distinct?: Enumerable<SeverityLevelScalarFieldEnum>
  }

  /**
   * SeverityLevel findFirst
   */
  export interface SeverityLevelFindFirstArgs extends SeverityLevelFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SeverityLevel findFirstOrThrow
   */
  export type SeverityLevelFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * Filter, which SeverityLevel to fetch.
     */
    where?: SeverityLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeverityLevels to fetch.
     */
    orderBy?: Enumerable<SeverityLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SeverityLevels.
     */
    cursor?: SeverityLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeverityLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeverityLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SeverityLevels.
     */
    distinct?: Enumerable<SeverityLevelScalarFieldEnum>
  }


  /**
   * SeverityLevel findMany
   */
  export type SeverityLevelFindManyArgs = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * Filter, which SeverityLevels to fetch.
     */
    where?: SeverityLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SeverityLevels to fetch.
     */
    orderBy?: Enumerable<SeverityLevelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SeverityLevels.
     */
    cursor?: SeverityLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SeverityLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SeverityLevels.
     */
    skip?: number
    distinct?: Enumerable<SeverityLevelScalarFieldEnum>
  }


  /**
   * SeverityLevel create
   */
  export type SeverityLevelCreateArgs = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * The data needed to create a SeverityLevel.
     */
    data: XOR<SeverityLevelCreateInput, SeverityLevelUncheckedCreateInput>
  }


  /**
   * SeverityLevel createMany
   */
  export type SeverityLevelCreateManyArgs = {
    /**
     * The data used to create many SeverityLevels.
     */
    data: Enumerable<SeverityLevelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SeverityLevel update
   */
  export type SeverityLevelUpdateArgs = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * The data needed to update a SeverityLevel.
     */
    data: XOR<SeverityLevelUpdateInput, SeverityLevelUncheckedUpdateInput>
    /**
     * Choose, which SeverityLevel to update.
     */
    where: SeverityLevelWhereUniqueInput
  }


  /**
   * SeverityLevel updateMany
   */
  export type SeverityLevelUpdateManyArgs = {
    /**
     * The data used to update SeverityLevels.
     */
    data: XOR<SeverityLevelUpdateManyMutationInput, SeverityLevelUncheckedUpdateManyInput>
    /**
     * Filter which SeverityLevels to update
     */
    where?: SeverityLevelWhereInput
  }


  /**
   * SeverityLevel upsert
   */
  export type SeverityLevelUpsertArgs = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * The filter to search for the SeverityLevel to update in case it exists.
     */
    where: SeverityLevelWhereUniqueInput
    /**
     * In case the SeverityLevel found by the `where` argument doesn't exist, create a new SeverityLevel with this data.
     */
    create: XOR<SeverityLevelCreateInput, SeverityLevelUncheckedCreateInput>
    /**
     * In case the SeverityLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeverityLevelUpdateInput, SeverityLevelUncheckedUpdateInput>
  }


  /**
   * SeverityLevel delete
   */
  export type SeverityLevelDeleteArgs = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
    /**
     * Filter which SeverityLevel to delete.
     */
    where: SeverityLevelWhereUniqueInput
  }


  /**
   * SeverityLevel deleteMany
   */
  export type SeverityLevelDeleteManyArgs = {
    /**
     * Filter which SeverityLevels to delete
     */
    where?: SeverityLevelWhereInput
  }


  /**
   * SeverityLevel without action
   */
  export type SeverityLevelArgs = {
    /**
     * Select specific fields to fetch from the SeverityLevel
     */
    select?: SeverityLevelSelect | null
  }



  /**
   * Model SortForce
   */


  export type AggregateSortForce = {
    _count: SortForceCountAggregateOutputType | null
    _min: SortForceMinAggregateOutputType | null
    _max: SortForceMaxAggregateOutputType | null
  }

  export type SortForceMinAggregateOutputType = {
    id: string | null
    code: string | null
    incidentSeverity: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SortForceMaxAggregateOutputType = {
    id: string | null
    code: string | null
    incidentSeverity: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SortForceCountAggregateOutputType = {
    id: number
    code: number
    incidentSeverity: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SortForceMinAggregateInputType = {
    id?: true
    code?: true
    incidentSeverity?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SortForceMaxAggregateInputType = {
    id?: true
    code?: true
    incidentSeverity?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SortForceCountAggregateInputType = {
    id?: true
    code?: true
    incidentSeverity?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SortForceAggregateArgs = {
    /**
     * Filter which SortForce to aggregate.
     */
    where?: SortForceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortForces to fetch.
     */
    orderBy?: Enumerable<SortForceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SortForceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortForces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortForces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SortForces
    **/
    _count?: true | SortForceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SortForceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SortForceMaxAggregateInputType
  }

  export type GetSortForceAggregateType<T extends SortForceAggregateArgs> = {
        [P in keyof T & keyof AggregateSortForce]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSortForce[P]>
      : GetScalarType<T[P], AggregateSortForce[P]>
  }




  export type SortForceGroupByArgs = {
    where?: SortForceWhereInput
    orderBy?: Enumerable<SortForceOrderByWithAggregationInput>
    by: SortForceScalarFieldEnum[]
    having?: SortForceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SortForceCountAggregateInputType | true
    _min?: SortForceMinAggregateInputType
    _max?: SortForceMaxAggregateInputType
  }


  export type SortForceGroupByOutputType = {
    id: string
    code: string
    incidentSeverity: string
    nameuz: string
    nameru: string
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SortForceCountAggregateOutputType | null
    _min: SortForceMinAggregateOutputType | null
    _max: SortForceMaxAggregateOutputType | null
  }

  type GetSortForceGroupByPayload<T extends SortForceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SortForceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SortForceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SortForceGroupByOutputType[P]>
            : GetScalarType<T[P], SortForceGroupByOutputType[P]>
        }
      >
    >


  export type SortForceSelect = {
    id?: boolean
    code?: boolean
    incidentSeverity?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type SortForceGetPayload<S extends boolean | null | undefined | SortForceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SortForce :
    S extends undefined ? never :
    S extends { include: any } & (SortForceArgs | SortForceFindManyArgs)
    ? SortForce 
    : S extends { select: any } & (SortForceArgs | SortForceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SortForce ? SortForce[P] : never
  } 
      : SortForce


  type SortForceCountArgs = 
    Omit<SortForceFindManyArgs, 'select' | 'include'> & {
      select?: SortForceCountAggregateInputType | true
    }

  export interface SortForceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SortForce that matches the filter.
     * @param {SortForceFindUniqueArgs} args - Arguments to find a SortForce
     * @example
     * // Get one SortForce
     * const sortForce = await prisma.sortForce.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SortForceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SortForceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SortForce'> extends True ? Prisma__SortForceClient<SortForceGetPayload<T>> : Prisma__SortForceClient<SortForceGetPayload<T> | null, null>

    /**
     * Find one SortForce that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SortForceFindUniqueOrThrowArgs} args - Arguments to find a SortForce
     * @example
     * // Get one SortForce
     * const sortForce = await prisma.sortForce.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SortForceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SortForceFindUniqueOrThrowArgs>
    ): Prisma__SortForceClient<SortForceGetPayload<T>>

    /**
     * Find the first SortForce that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortForceFindFirstArgs} args - Arguments to find a SortForce
     * @example
     * // Get one SortForce
     * const sortForce = await prisma.sortForce.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SortForceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SortForceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SortForce'> extends True ? Prisma__SortForceClient<SortForceGetPayload<T>> : Prisma__SortForceClient<SortForceGetPayload<T> | null, null>

    /**
     * Find the first SortForce that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortForceFindFirstOrThrowArgs} args - Arguments to find a SortForce
     * @example
     * // Get one SortForce
     * const sortForce = await prisma.sortForce.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SortForceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SortForceFindFirstOrThrowArgs>
    ): Prisma__SortForceClient<SortForceGetPayload<T>>

    /**
     * Find zero or more SortForces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortForceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SortForces
     * const sortForces = await prisma.sortForce.findMany()
     * 
     * // Get first 10 SortForces
     * const sortForces = await prisma.sortForce.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sortForceWithIdOnly = await prisma.sortForce.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SortForceFindManyArgs>(
      args?: SelectSubset<T, SortForceFindManyArgs>
    ): Prisma.PrismaPromise<Array<SortForceGetPayload<T>>>

    /**
     * Create a SortForce.
     * @param {SortForceCreateArgs} args - Arguments to create a SortForce.
     * @example
     * // Create one SortForce
     * const SortForce = await prisma.sortForce.create({
     *   data: {
     *     // ... data to create a SortForce
     *   }
     * })
     * 
    **/
    create<T extends SortForceCreateArgs>(
      args: SelectSubset<T, SortForceCreateArgs>
    ): Prisma__SortForceClient<SortForceGetPayload<T>>

    /**
     * Create many SortForces.
     *     @param {SortForceCreateManyArgs} args - Arguments to create many SortForces.
     *     @example
     *     // Create many SortForces
     *     const sortForce = await prisma.sortForce.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SortForceCreateManyArgs>(
      args?: SelectSubset<T, SortForceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SortForce.
     * @param {SortForceDeleteArgs} args - Arguments to delete one SortForce.
     * @example
     * // Delete one SortForce
     * const SortForce = await prisma.sortForce.delete({
     *   where: {
     *     // ... filter to delete one SortForce
     *   }
     * })
     * 
    **/
    delete<T extends SortForceDeleteArgs>(
      args: SelectSubset<T, SortForceDeleteArgs>
    ): Prisma__SortForceClient<SortForceGetPayload<T>>

    /**
     * Update one SortForce.
     * @param {SortForceUpdateArgs} args - Arguments to update one SortForce.
     * @example
     * // Update one SortForce
     * const sortForce = await prisma.sortForce.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SortForceUpdateArgs>(
      args: SelectSubset<T, SortForceUpdateArgs>
    ): Prisma__SortForceClient<SortForceGetPayload<T>>

    /**
     * Delete zero or more SortForces.
     * @param {SortForceDeleteManyArgs} args - Arguments to filter SortForces to delete.
     * @example
     * // Delete a few SortForces
     * const { count } = await prisma.sortForce.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SortForceDeleteManyArgs>(
      args?: SelectSubset<T, SortForceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SortForces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortForceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SortForces
     * const sortForce = await prisma.sortForce.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SortForceUpdateManyArgs>(
      args: SelectSubset<T, SortForceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SortForce.
     * @param {SortForceUpsertArgs} args - Arguments to update or create a SortForce.
     * @example
     * // Update or create a SortForce
     * const sortForce = await prisma.sortForce.upsert({
     *   create: {
     *     // ... data to create a SortForce
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SortForce we want to update
     *   }
     * })
    **/
    upsert<T extends SortForceUpsertArgs>(
      args: SelectSubset<T, SortForceUpsertArgs>
    ): Prisma__SortForceClient<SortForceGetPayload<T>>

    /**
     * Count the number of SortForces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortForceCountArgs} args - Arguments to filter SortForces to count.
     * @example
     * // Count the number of SortForces
     * const count = await prisma.sortForce.count({
     *   where: {
     *     // ... the filter for the SortForces we want to count
     *   }
     * })
    **/
    count<T extends SortForceCountArgs>(
      args?: Subset<T, SortForceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SortForceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SortForce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortForceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SortForceAggregateArgs>(args: Subset<T, SortForceAggregateArgs>): Prisma.PrismaPromise<GetSortForceAggregateType<T>>

    /**
     * Group by SortForce.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortForceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SortForceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SortForceGroupByArgs['orderBy'] }
        : { orderBy?: SortForceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SortForceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSortForceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SortForce.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SortForceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SortForce base type for findUnique actions
   */
  export type SortForceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * Filter, which SortForce to fetch.
     */
    where: SortForceWhereUniqueInput
  }

  /**
   * SortForce findUnique
   */
  export interface SortForceFindUniqueArgs extends SortForceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SortForce findUniqueOrThrow
   */
  export type SortForceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * Filter, which SortForce to fetch.
     */
    where: SortForceWhereUniqueInput
  }


  /**
   * SortForce base type for findFirst actions
   */
  export type SortForceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * Filter, which SortForce to fetch.
     */
    where?: SortForceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortForces to fetch.
     */
    orderBy?: Enumerable<SortForceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SortForces.
     */
    cursor?: SortForceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortForces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortForces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SortForces.
     */
    distinct?: Enumerable<SortForceScalarFieldEnum>
  }

  /**
   * SortForce findFirst
   */
  export interface SortForceFindFirstArgs extends SortForceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SortForce findFirstOrThrow
   */
  export type SortForceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * Filter, which SortForce to fetch.
     */
    where?: SortForceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortForces to fetch.
     */
    orderBy?: Enumerable<SortForceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SortForces.
     */
    cursor?: SortForceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortForces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortForces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SortForces.
     */
    distinct?: Enumerable<SortForceScalarFieldEnum>
  }


  /**
   * SortForce findMany
   */
  export type SortForceFindManyArgs = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * Filter, which SortForces to fetch.
     */
    where?: SortForceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortForces to fetch.
     */
    orderBy?: Enumerable<SortForceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SortForces.
     */
    cursor?: SortForceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortForces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortForces.
     */
    skip?: number
    distinct?: Enumerable<SortForceScalarFieldEnum>
  }


  /**
   * SortForce create
   */
  export type SortForceCreateArgs = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * The data needed to create a SortForce.
     */
    data: XOR<SortForceCreateInput, SortForceUncheckedCreateInput>
  }


  /**
   * SortForce createMany
   */
  export type SortForceCreateManyArgs = {
    /**
     * The data used to create many SortForces.
     */
    data: Enumerable<SortForceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SortForce update
   */
  export type SortForceUpdateArgs = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * The data needed to update a SortForce.
     */
    data: XOR<SortForceUpdateInput, SortForceUncheckedUpdateInput>
    /**
     * Choose, which SortForce to update.
     */
    where: SortForceWhereUniqueInput
  }


  /**
   * SortForce updateMany
   */
  export type SortForceUpdateManyArgs = {
    /**
     * The data used to update SortForces.
     */
    data: XOR<SortForceUpdateManyMutationInput, SortForceUncheckedUpdateManyInput>
    /**
     * Filter which SortForces to update
     */
    where?: SortForceWhereInput
  }


  /**
   * SortForce upsert
   */
  export type SortForceUpsertArgs = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * The filter to search for the SortForce to update in case it exists.
     */
    where: SortForceWhereUniqueInput
    /**
     * In case the SortForce found by the `where` argument doesn't exist, create a new SortForce with this data.
     */
    create: XOR<SortForceCreateInput, SortForceUncheckedCreateInput>
    /**
     * In case the SortForce was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SortForceUpdateInput, SortForceUncheckedUpdateInput>
  }


  /**
   * SortForce delete
   */
  export type SortForceDeleteArgs = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
    /**
     * Filter which SortForce to delete.
     */
    where: SortForceWhereUniqueInput
  }


  /**
   * SortForce deleteMany
   */
  export type SortForceDeleteManyArgs = {
    /**
     * Filter which SortForces to delete
     */
    where?: SortForceWhereInput
  }


  /**
   * SortForce without action
   */
  export type SortForceArgs = {
    /**
     * Select specific fields to fetch from the SortForce
     */
    select?: SortForceSelect | null
  }



  /**
   * Model SortGravity
   */


  export type AggregateSortGravity = {
    _count: SortGravityCountAggregateOutputType | null
    _min: SortGravityMinAggregateOutputType | null
    _max: SortGravityMaxAggregateOutputType | null
  }

  export type SortGravityMinAggregateOutputType = {
    id: string | null
    code: string | null
    incidentSeverity: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SortGravityMaxAggregateOutputType = {
    id: string | null
    code: string | null
    incidentSeverity: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SortGravityCountAggregateOutputType = {
    id: number
    code: number
    incidentSeverity: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SortGravityMinAggregateInputType = {
    id?: true
    code?: true
    incidentSeverity?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SortGravityMaxAggregateInputType = {
    id?: true
    code?: true
    incidentSeverity?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SortGravityCountAggregateInputType = {
    id?: true
    code?: true
    incidentSeverity?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SortGravityAggregateArgs = {
    /**
     * Filter which SortGravity to aggregate.
     */
    where?: SortGravityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortGravities to fetch.
     */
    orderBy?: Enumerable<SortGravityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SortGravityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortGravities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortGravities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SortGravities
    **/
    _count?: true | SortGravityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SortGravityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SortGravityMaxAggregateInputType
  }

  export type GetSortGravityAggregateType<T extends SortGravityAggregateArgs> = {
        [P in keyof T & keyof AggregateSortGravity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSortGravity[P]>
      : GetScalarType<T[P], AggregateSortGravity[P]>
  }




  export type SortGravityGroupByArgs = {
    where?: SortGravityWhereInput
    orderBy?: Enumerable<SortGravityOrderByWithAggregationInput>
    by: SortGravityScalarFieldEnum[]
    having?: SortGravityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SortGravityCountAggregateInputType | true
    _min?: SortGravityMinAggregateInputType
    _max?: SortGravityMaxAggregateInputType
  }


  export type SortGravityGroupByOutputType = {
    id: string
    code: string
    incidentSeverity: string
    nameuz: string
    nameru: string
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SortGravityCountAggregateOutputType | null
    _min: SortGravityMinAggregateOutputType | null
    _max: SortGravityMaxAggregateOutputType | null
  }

  type GetSortGravityGroupByPayload<T extends SortGravityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SortGravityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SortGravityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SortGravityGroupByOutputType[P]>
            : GetScalarType<T[P], SortGravityGroupByOutputType[P]>
        }
      >
    >


  export type SortGravitySelect = {
    id?: boolean
    code?: boolean
    incidentSeverity?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type SortGravityGetPayload<S extends boolean | null | undefined | SortGravityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SortGravity :
    S extends undefined ? never :
    S extends { include: any } & (SortGravityArgs | SortGravityFindManyArgs)
    ? SortGravity 
    : S extends { select: any } & (SortGravityArgs | SortGravityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SortGravity ? SortGravity[P] : never
  } 
      : SortGravity


  type SortGravityCountArgs = 
    Omit<SortGravityFindManyArgs, 'select' | 'include'> & {
      select?: SortGravityCountAggregateInputType | true
    }

  export interface SortGravityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SortGravity that matches the filter.
     * @param {SortGravityFindUniqueArgs} args - Arguments to find a SortGravity
     * @example
     * // Get one SortGravity
     * const sortGravity = await prisma.sortGravity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SortGravityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SortGravityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SortGravity'> extends True ? Prisma__SortGravityClient<SortGravityGetPayload<T>> : Prisma__SortGravityClient<SortGravityGetPayload<T> | null, null>

    /**
     * Find one SortGravity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SortGravityFindUniqueOrThrowArgs} args - Arguments to find a SortGravity
     * @example
     * // Get one SortGravity
     * const sortGravity = await prisma.sortGravity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SortGravityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SortGravityFindUniqueOrThrowArgs>
    ): Prisma__SortGravityClient<SortGravityGetPayload<T>>

    /**
     * Find the first SortGravity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortGravityFindFirstArgs} args - Arguments to find a SortGravity
     * @example
     * // Get one SortGravity
     * const sortGravity = await prisma.sortGravity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SortGravityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SortGravityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SortGravity'> extends True ? Prisma__SortGravityClient<SortGravityGetPayload<T>> : Prisma__SortGravityClient<SortGravityGetPayload<T> | null, null>

    /**
     * Find the first SortGravity that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortGravityFindFirstOrThrowArgs} args - Arguments to find a SortGravity
     * @example
     * // Get one SortGravity
     * const sortGravity = await prisma.sortGravity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SortGravityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SortGravityFindFirstOrThrowArgs>
    ): Prisma__SortGravityClient<SortGravityGetPayload<T>>

    /**
     * Find zero or more SortGravities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortGravityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SortGravities
     * const sortGravities = await prisma.sortGravity.findMany()
     * 
     * // Get first 10 SortGravities
     * const sortGravities = await prisma.sortGravity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sortGravityWithIdOnly = await prisma.sortGravity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SortGravityFindManyArgs>(
      args?: SelectSubset<T, SortGravityFindManyArgs>
    ): Prisma.PrismaPromise<Array<SortGravityGetPayload<T>>>

    /**
     * Create a SortGravity.
     * @param {SortGravityCreateArgs} args - Arguments to create a SortGravity.
     * @example
     * // Create one SortGravity
     * const SortGravity = await prisma.sortGravity.create({
     *   data: {
     *     // ... data to create a SortGravity
     *   }
     * })
     * 
    **/
    create<T extends SortGravityCreateArgs>(
      args: SelectSubset<T, SortGravityCreateArgs>
    ): Prisma__SortGravityClient<SortGravityGetPayload<T>>

    /**
     * Create many SortGravities.
     *     @param {SortGravityCreateManyArgs} args - Arguments to create many SortGravities.
     *     @example
     *     // Create many SortGravities
     *     const sortGravity = await prisma.sortGravity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SortGravityCreateManyArgs>(
      args?: SelectSubset<T, SortGravityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SortGravity.
     * @param {SortGravityDeleteArgs} args - Arguments to delete one SortGravity.
     * @example
     * // Delete one SortGravity
     * const SortGravity = await prisma.sortGravity.delete({
     *   where: {
     *     // ... filter to delete one SortGravity
     *   }
     * })
     * 
    **/
    delete<T extends SortGravityDeleteArgs>(
      args: SelectSubset<T, SortGravityDeleteArgs>
    ): Prisma__SortGravityClient<SortGravityGetPayload<T>>

    /**
     * Update one SortGravity.
     * @param {SortGravityUpdateArgs} args - Arguments to update one SortGravity.
     * @example
     * // Update one SortGravity
     * const sortGravity = await prisma.sortGravity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SortGravityUpdateArgs>(
      args: SelectSubset<T, SortGravityUpdateArgs>
    ): Prisma__SortGravityClient<SortGravityGetPayload<T>>

    /**
     * Delete zero or more SortGravities.
     * @param {SortGravityDeleteManyArgs} args - Arguments to filter SortGravities to delete.
     * @example
     * // Delete a few SortGravities
     * const { count } = await prisma.sortGravity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SortGravityDeleteManyArgs>(
      args?: SelectSubset<T, SortGravityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SortGravities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortGravityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SortGravities
     * const sortGravity = await prisma.sortGravity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SortGravityUpdateManyArgs>(
      args: SelectSubset<T, SortGravityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SortGravity.
     * @param {SortGravityUpsertArgs} args - Arguments to update or create a SortGravity.
     * @example
     * // Update or create a SortGravity
     * const sortGravity = await prisma.sortGravity.upsert({
     *   create: {
     *     // ... data to create a SortGravity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SortGravity we want to update
     *   }
     * })
    **/
    upsert<T extends SortGravityUpsertArgs>(
      args: SelectSubset<T, SortGravityUpsertArgs>
    ): Prisma__SortGravityClient<SortGravityGetPayload<T>>

    /**
     * Count the number of SortGravities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortGravityCountArgs} args - Arguments to filter SortGravities to count.
     * @example
     * // Count the number of SortGravities
     * const count = await prisma.sortGravity.count({
     *   where: {
     *     // ... the filter for the SortGravities we want to count
     *   }
     * })
    **/
    count<T extends SortGravityCountArgs>(
      args?: Subset<T, SortGravityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SortGravityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SortGravity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortGravityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SortGravityAggregateArgs>(args: Subset<T, SortGravityAggregateArgs>): Prisma.PrismaPromise<GetSortGravityAggregateType<T>>

    /**
     * Group by SortGravity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SortGravityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SortGravityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SortGravityGroupByArgs['orderBy'] }
        : { orderBy?: SortGravityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SortGravityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSortGravityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SortGravity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SortGravityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SortGravity base type for findUnique actions
   */
  export type SortGravityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * Filter, which SortGravity to fetch.
     */
    where: SortGravityWhereUniqueInput
  }

  /**
   * SortGravity findUnique
   */
  export interface SortGravityFindUniqueArgs extends SortGravityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SortGravity findUniqueOrThrow
   */
  export type SortGravityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * Filter, which SortGravity to fetch.
     */
    where: SortGravityWhereUniqueInput
  }


  /**
   * SortGravity base type for findFirst actions
   */
  export type SortGravityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * Filter, which SortGravity to fetch.
     */
    where?: SortGravityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortGravities to fetch.
     */
    orderBy?: Enumerable<SortGravityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SortGravities.
     */
    cursor?: SortGravityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortGravities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortGravities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SortGravities.
     */
    distinct?: Enumerable<SortGravityScalarFieldEnum>
  }

  /**
   * SortGravity findFirst
   */
  export interface SortGravityFindFirstArgs extends SortGravityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SortGravity findFirstOrThrow
   */
  export type SortGravityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * Filter, which SortGravity to fetch.
     */
    where?: SortGravityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortGravities to fetch.
     */
    orderBy?: Enumerable<SortGravityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SortGravities.
     */
    cursor?: SortGravityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortGravities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortGravities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SortGravities.
     */
    distinct?: Enumerable<SortGravityScalarFieldEnum>
  }


  /**
   * SortGravity findMany
   */
  export type SortGravityFindManyArgs = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * Filter, which SortGravities to fetch.
     */
    where?: SortGravityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SortGravities to fetch.
     */
    orderBy?: Enumerable<SortGravityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SortGravities.
     */
    cursor?: SortGravityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SortGravities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SortGravities.
     */
    skip?: number
    distinct?: Enumerable<SortGravityScalarFieldEnum>
  }


  /**
   * SortGravity create
   */
  export type SortGravityCreateArgs = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * The data needed to create a SortGravity.
     */
    data: XOR<SortGravityCreateInput, SortGravityUncheckedCreateInput>
  }


  /**
   * SortGravity createMany
   */
  export type SortGravityCreateManyArgs = {
    /**
     * The data used to create many SortGravities.
     */
    data: Enumerable<SortGravityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SortGravity update
   */
  export type SortGravityUpdateArgs = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * The data needed to update a SortGravity.
     */
    data: XOR<SortGravityUpdateInput, SortGravityUncheckedUpdateInput>
    /**
     * Choose, which SortGravity to update.
     */
    where: SortGravityWhereUniqueInput
  }


  /**
   * SortGravity updateMany
   */
  export type SortGravityUpdateManyArgs = {
    /**
     * The data used to update SortGravities.
     */
    data: XOR<SortGravityUpdateManyMutationInput, SortGravityUncheckedUpdateManyInput>
    /**
     * Filter which SortGravities to update
     */
    where?: SortGravityWhereInput
  }


  /**
   * SortGravity upsert
   */
  export type SortGravityUpsertArgs = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * The filter to search for the SortGravity to update in case it exists.
     */
    where: SortGravityWhereUniqueInput
    /**
     * In case the SortGravity found by the `where` argument doesn't exist, create a new SortGravity with this data.
     */
    create: XOR<SortGravityCreateInput, SortGravityUncheckedCreateInput>
    /**
     * In case the SortGravity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SortGravityUpdateInput, SortGravityUncheckedUpdateInput>
  }


  /**
   * SortGravity delete
   */
  export type SortGravityDeleteArgs = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
    /**
     * Filter which SortGravity to delete.
     */
    where: SortGravityWhereUniqueInput
  }


  /**
   * SortGravity deleteMany
   */
  export type SortGravityDeleteManyArgs = {
    /**
     * Filter which SortGravities to delete
     */
    where?: SortGravityWhereInput
  }


  /**
   * SortGravity without action
   */
  export type SortGravityArgs = {
    /**
     * Select specific fields to fetch from the SortGravity
     */
    select?: SortGravitySelect | null
  }



  /**
   * Model MarkLimit
   */


  export type AggregateMarkLimit = {
    _count: MarkLimitCountAggregateOutputType | null
    _min: MarkLimitMinAggregateOutputType | null
    _max: MarkLimitMaxAggregateOutputType | null
  }

  export type MarkLimitMinAggregateOutputType = {
    id: string | null
    code: string | null
    privacySymbol: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarkLimitMaxAggregateOutputType = {
    id: string | null
    code: string | null
    privacySymbol: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarkLimitCountAggregateOutputType = {
    id: number
    code: number
    privacySymbol: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarkLimitMinAggregateInputType = {
    id?: true
    code?: true
    privacySymbol?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarkLimitMaxAggregateInputType = {
    id?: true
    code?: true
    privacySymbol?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarkLimitCountAggregateInputType = {
    id?: true
    code?: true
    privacySymbol?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarkLimitAggregateArgs = {
    /**
     * Filter which MarkLimit to aggregate.
     */
    where?: MarkLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarkLimits to fetch.
     */
    orderBy?: Enumerable<MarkLimitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarkLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarkLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarkLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarkLimits
    **/
    _count?: true | MarkLimitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarkLimitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarkLimitMaxAggregateInputType
  }

  export type GetMarkLimitAggregateType<T extends MarkLimitAggregateArgs> = {
        [P in keyof T & keyof AggregateMarkLimit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarkLimit[P]>
      : GetScalarType<T[P], AggregateMarkLimit[P]>
  }




  export type MarkLimitGroupByArgs = {
    where?: MarkLimitWhereInput
    orderBy?: Enumerable<MarkLimitOrderByWithAggregationInput>
    by: MarkLimitScalarFieldEnum[]
    having?: MarkLimitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarkLimitCountAggregateInputType | true
    _min?: MarkLimitMinAggregateInputType
    _max?: MarkLimitMaxAggregateInputType
  }


  export type MarkLimitGroupByOutputType = {
    id: string
    code: string
    privacySymbol: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MarkLimitCountAggregateOutputType | null
    _min: MarkLimitMinAggregateOutputType | null
    _max: MarkLimitMaxAggregateOutputType | null
  }

  type GetMarkLimitGroupByPayload<T extends MarkLimitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MarkLimitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarkLimitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarkLimitGroupByOutputType[P]>
            : GetScalarType<T[P], MarkLimitGroupByOutputType[P]>
        }
      >
    >


  export type MarkLimitSelect = {
    id?: boolean
    code?: boolean
    privacySymbol?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type MarkLimitGetPayload<S extends boolean | null | undefined | MarkLimitArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MarkLimit :
    S extends undefined ? never :
    S extends { include: any } & (MarkLimitArgs | MarkLimitFindManyArgs)
    ? MarkLimit 
    : S extends { select: any } & (MarkLimitArgs | MarkLimitFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MarkLimit ? MarkLimit[P] : never
  } 
      : MarkLimit


  type MarkLimitCountArgs = 
    Omit<MarkLimitFindManyArgs, 'select' | 'include'> & {
      select?: MarkLimitCountAggregateInputType | true
    }

  export interface MarkLimitDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MarkLimit that matches the filter.
     * @param {MarkLimitFindUniqueArgs} args - Arguments to find a MarkLimit
     * @example
     * // Get one MarkLimit
     * const markLimit = await prisma.markLimit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MarkLimitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MarkLimitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MarkLimit'> extends True ? Prisma__MarkLimitClient<MarkLimitGetPayload<T>> : Prisma__MarkLimitClient<MarkLimitGetPayload<T> | null, null>

    /**
     * Find one MarkLimit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MarkLimitFindUniqueOrThrowArgs} args - Arguments to find a MarkLimit
     * @example
     * // Get one MarkLimit
     * const markLimit = await prisma.markLimit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MarkLimitFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MarkLimitFindUniqueOrThrowArgs>
    ): Prisma__MarkLimitClient<MarkLimitGetPayload<T>>

    /**
     * Find the first MarkLimit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkLimitFindFirstArgs} args - Arguments to find a MarkLimit
     * @example
     * // Get one MarkLimit
     * const markLimit = await prisma.markLimit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MarkLimitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MarkLimitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MarkLimit'> extends True ? Prisma__MarkLimitClient<MarkLimitGetPayload<T>> : Prisma__MarkLimitClient<MarkLimitGetPayload<T> | null, null>

    /**
     * Find the first MarkLimit that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkLimitFindFirstOrThrowArgs} args - Arguments to find a MarkLimit
     * @example
     * // Get one MarkLimit
     * const markLimit = await prisma.markLimit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MarkLimitFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MarkLimitFindFirstOrThrowArgs>
    ): Prisma__MarkLimitClient<MarkLimitGetPayload<T>>

    /**
     * Find zero or more MarkLimits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkLimitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarkLimits
     * const markLimits = await prisma.markLimit.findMany()
     * 
     * // Get first 10 MarkLimits
     * const markLimits = await prisma.markLimit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const markLimitWithIdOnly = await prisma.markLimit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MarkLimitFindManyArgs>(
      args?: SelectSubset<T, MarkLimitFindManyArgs>
    ): Prisma.PrismaPromise<Array<MarkLimitGetPayload<T>>>

    /**
     * Create a MarkLimit.
     * @param {MarkLimitCreateArgs} args - Arguments to create a MarkLimit.
     * @example
     * // Create one MarkLimit
     * const MarkLimit = await prisma.markLimit.create({
     *   data: {
     *     // ... data to create a MarkLimit
     *   }
     * })
     * 
    **/
    create<T extends MarkLimitCreateArgs>(
      args: SelectSubset<T, MarkLimitCreateArgs>
    ): Prisma__MarkLimitClient<MarkLimitGetPayload<T>>

    /**
     * Create many MarkLimits.
     *     @param {MarkLimitCreateManyArgs} args - Arguments to create many MarkLimits.
     *     @example
     *     // Create many MarkLimits
     *     const markLimit = await prisma.markLimit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MarkLimitCreateManyArgs>(
      args?: SelectSubset<T, MarkLimitCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MarkLimit.
     * @param {MarkLimitDeleteArgs} args - Arguments to delete one MarkLimit.
     * @example
     * // Delete one MarkLimit
     * const MarkLimit = await prisma.markLimit.delete({
     *   where: {
     *     // ... filter to delete one MarkLimit
     *   }
     * })
     * 
    **/
    delete<T extends MarkLimitDeleteArgs>(
      args: SelectSubset<T, MarkLimitDeleteArgs>
    ): Prisma__MarkLimitClient<MarkLimitGetPayload<T>>

    /**
     * Update one MarkLimit.
     * @param {MarkLimitUpdateArgs} args - Arguments to update one MarkLimit.
     * @example
     * // Update one MarkLimit
     * const markLimit = await prisma.markLimit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MarkLimitUpdateArgs>(
      args: SelectSubset<T, MarkLimitUpdateArgs>
    ): Prisma__MarkLimitClient<MarkLimitGetPayload<T>>

    /**
     * Delete zero or more MarkLimits.
     * @param {MarkLimitDeleteManyArgs} args - Arguments to filter MarkLimits to delete.
     * @example
     * // Delete a few MarkLimits
     * const { count } = await prisma.markLimit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MarkLimitDeleteManyArgs>(
      args?: SelectSubset<T, MarkLimitDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarkLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkLimitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarkLimits
     * const markLimit = await prisma.markLimit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MarkLimitUpdateManyArgs>(
      args: SelectSubset<T, MarkLimitUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarkLimit.
     * @param {MarkLimitUpsertArgs} args - Arguments to update or create a MarkLimit.
     * @example
     * // Update or create a MarkLimit
     * const markLimit = await prisma.markLimit.upsert({
     *   create: {
     *     // ... data to create a MarkLimit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarkLimit we want to update
     *   }
     * })
    **/
    upsert<T extends MarkLimitUpsertArgs>(
      args: SelectSubset<T, MarkLimitUpsertArgs>
    ): Prisma__MarkLimitClient<MarkLimitGetPayload<T>>

    /**
     * Count the number of MarkLimits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkLimitCountArgs} args - Arguments to filter MarkLimits to count.
     * @example
     * // Count the number of MarkLimits
     * const count = await prisma.markLimit.count({
     *   where: {
     *     // ... the filter for the MarkLimits we want to count
     *   }
     * })
    **/
    count<T extends MarkLimitCountArgs>(
      args?: Subset<T, MarkLimitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarkLimitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarkLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkLimitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarkLimitAggregateArgs>(args: Subset<T, MarkLimitAggregateArgs>): Prisma.PrismaPromise<GetMarkLimitAggregateType<T>>

    /**
     * Group by MarkLimit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarkLimitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarkLimitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarkLimitGroupByArgs['orderBy'] }
        : { orderBy?: MarkLimitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarkLimitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarkLimitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MarkLimit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MarkLimitClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MarkLimit base type for findUnique actions
   */
  export type MarkLimitFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * Filter, which MarkLimit to fetch.
     */
    where: MarkLimitWhereUniqueInput
  }

  /**
   * MarkLimit findUnique
   */
  export interface MarkLimitFindUniqueArgs extends MarkLimitFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarkLimit findUniqueOrThrow
   */
  export type MarkLimitFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * Filter, which MarkLimit to fetch.
     */
    where: MarkLimitWhereUniqueInput
  }


  /**
   * MarkLimit base type for findFirst actions
   */
  export type MarkLimitFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * Filter, which MarkLimit to fetch.
     */
    where?: MarkLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarkLimits to fetch.
     */
    orderBy?: Enumerable<MarkLimitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarkLimits.
     */
    cursor?: MarkLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarkLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarkLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarkLimits.
     */
    distinct?: Enumerable<MarkLimitScalarFieldEnum>
  }

  /**
   * MarkLimit findFirst
   */
  export interface MarkLimitFindFirstArgs extends MarkLimitFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MarkLimit findFirstOrThrow
   */
  export type MarkLimitFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * Filter, which MarkLimit to fetch.
     */
    where?: MarkLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarkLimits to fetch.
     */
    orderBy?: Enumerable<MarkLimitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarkLimits.
     */
    cursor?: MarkLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarkLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarkLimits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarkLimits.
     */
    distinct?: Enumerable<MarkLimitScalarFieldEnum>
  }


  /**
   * MarkLimit findMany
   */
  export type MarkLimitFindManyArgs = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * Filter, which MarkLimits to fetch.
     */
    where?: MarkLimitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarkLimits to fetch.
     */
    orderBy?: Enumerable<MarkLimitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarkLimits.
     */
    cursor?: MarkLimitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarkLimits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarkLimits.
     */
    skip?: number
    distinct?: Enumerable<MarkLimitScalarFieldEnum>
  }


  /**
   * MarkLimit create
   */
  export type MarkLimitCreateArgs = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * The data needed to create a MarkLimit.
     */
    data: XOR<MarkLimitCreateInput, MarkLimitUncheckedCreateInput>
  }


  /**
   * MarkLimit createMany
   */
  export type MarkLimitCreateManyArgs = {
    /**
     * The data used to create many MarkLimits.
     */
    data: Enumerable<MarkLimitCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MarkLimit update
   */
  export type MarkLimitUpdateArgs = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * The data needed to update a MarkLimit.
     */
    data: XOR<MarkLimitUpdateInput, MarkLimitUncheckedUpdateInput>
    /**
     * Choose, which MarkLimit to update.
     */
    where: MarkLimitWhereUniqueInput
  }


  /**
   * MarkLimit updateMany
   */
  export type MarkLimitUpdateManyArgs = {
    /**
     * The data used to update MarkLimits.
     */
    data: XOR<MarkLimitUpdateManyMutationInput, MarkLimitUncheckedUpdateManyInput>
    /**
     * Filter which MarkLimits to update
     */
    where?: MarkLimitWhereInput
  }


  /**
   * MarkLimit upsert
   */
  export type MarkLimitUpsertArgs = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * The filter to search for the MarkLimit to update in case it exists.
     */
    where: MarkLimitWhereUniqueInput
    /**
     * In case the MarkLimit found by the `where` argument doesn't exist, create a new MarkLimit with this data.
     */
    create: XOR<MarkLimitCreateInput, MarkLimitUncheckedCreateInput>
    /**
     * In case the MarkLimit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarkLimitUpdateInput, MarkLimitUncheckedUpdateInput>
  }


  /**
   * MarkLimit delete
   */
  export type MarkLimitDeleteArgs = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
    /**
     * Filter which MarkLimit to delete.
     */
    where: MarkLimitWhereUniqueInput
  }


  /**
   * MarkLimit deleteMany
   */
  export type MarkLimitDeleteManyArgs = {
    /**
     * Filter which MarkLimits to delete
     */
    where?: MarkLimitWhereInput
  }


  /**
   * MarkLimit without action
   */
  export type MarkLimitArgs = {
    /**
     * Select specific fields to fetch from the MarkLimit
     */
    select?: MarkLimitSelect | null
  }



  /**
   * Model AttackedDomain
   */


  export type AggregateAttackedDomain = {
    _count: AttackedDomainCountAggregateOutputType | null
    _min: AttackedDomainMinAggregateOutputType | null
    _max: AttackedDomainMaxAggregateOutputType | null
  }

  export type AttackedDomainMinAggregateOutputType = {
    id: string | null
    hosting: string | null
    domainSupport: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttackedDomainMaxAggregateOutputType = {
    id: string | null
    hosting: string | null
    domainSupport: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttackedDomainCountAggregateOutputType = {
    id: number
    hosting: number
    domainSupport: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttackedDomainMinAggregateInputType = {
    id?: true
    hosting?: true
    domainSupport?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttackedDomainMaxAggregateInputType = {
    id?: true
    hosting?: true
    domainSupport?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttackedDomainCountAggregateInputType = {
    id?: true
    hosting?: true
    domainSupport?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttackedDomainAggregateArgs = {
    /**
     * Filter which AttackedDomain to aggregate.
     */
    where?: AttackedDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomains to fetch.
     */
    orderBy?: Enumerable<AttackedDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttackedDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttackedDomains
    **/
    _count?: true | AttackedDomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttackedDomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttackedDomainMaxAggregateInputType
  }

  export type GetAttackedDomainAggregateType<T extends AttackedDomainAggregateArgs> = {
        [P in keyof T & keyof AggregateAttackedDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttackedDomain[P]>
      : GetScalarType<T[P], AggregateAttackedDomain[P]>
  }




  export type AttackedDomainGroupByArgs = {
    where?: AttackedDomainWhereInput
    orderBy?: Enumerable<AttackedDomainOrderByWithAggregationInput>
    by: AttackedDomainScalarFieldEnum[]
    having?: AttackedDomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttackedDomainCountAggregateInputType | true
    _min?: AttackedDomainMinAggregateInputType
    _max?: AttackedDomainMaxAggregateInputType
  }


  export type AttackedDomainGroupByOutputType = {
    id: string
    hosting: string
    domainSupport: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttackedDomainCountAggregateOutputType | null
    _min: AttackedDomainMinAggregateOutputType | null
    _max: AttackedDomainMaxAggregateOutputType | null
  }

  type GetAttackedDomainGroupByPayload<T extends AttackedDomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AttackedDomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttackedDomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttackedDomainGroupByOutputType[P]>
            : GetScalarType<T[P], AttackedDomainGroupByOutputType[P]>
        }
      >
    >


  export type AttackedDomainSelect = {
    id?: boolean
    hosting?: boolean
    domainSupport?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AttackedDomainGetPayload<S extends boolean | null | undefined | AttackedDomainArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AttackedDomain :
    S extends undefined ? never :
    S extends { include: any } & (AttackedDomainArgs | AttackedDomainFindManyArgs)
    ? AttackedDomain 
    : S extends { select: any } & (AttackedDomainArgs | AttackedDomainFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AttackedDomain ? AttackedDomain[P] : never
  } 
      : AttackedDomain


  type AttackedDomainCountArgs = 
    Omit<AttackedDomainFindManyArgs, 'select' | 'include'> & {
      select?: AttackedDomainCountAggregateInputType | true
    }

  export interface AttackedDomainDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AttackedDomain that matches the filter.
     * @param {AttackedDomainFindUniqueArgs} args - Arguments to find a AttackedDomain
     * @example
     * // Get one AttackedDomain
     * const attackedDomain = await prisma.attackedDomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttackedDomainFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttackedDomainFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AttackedDomain'> extends True ? Prisma__AttackedDomainClient<AttackedDomainGetPayload<T>> : Prisma__AttackedDomainClient<AttackedDomainGetPayload<T> | null, null>

    /**
     * Find one AttackedDomain that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AttackedDomainFindUniqueOrThrowArgs} args - Arguments to find a AttackedDomain
     * @example
     * // Get one AttackedDomain
     * const attackedDomain = await prisma.attackedDomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AttackedDomainFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AttackedDomainFindUniqueOrThrowArgs>
    ): Prisma__AttackedDomainClient<AttackedDomainGetPayload<T>>

    /**
     * Find the first AttackedDomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainFindFirstArgs} args - Arguments to find a AttackedDomain
     * @example
     * // Get one AttackedDomain
     * const attackedDomain = await prisma.attackedDomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttackedDomainFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttackedDomainFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AttackedDomain'> extends True ? Prisma__AttackedDomainClient<AttackedDomainGetPayload<T>> : Prisma__AttackedDomainClient<AttackedDomainGetPayload<T> | null, null>

    /**
     * Find the first AttackedDomain that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainFindFirstOrThrowArgs} args - Arguments to find a AttackedDomain
     * @example
     * // Get one AttackedDomain
     * const attackedDomain = await prisma.attackedDomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AttackedDomainFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AttackedDomainFindFirstOrThrowArgs>
    ): Prisma__AttackedDomainClient<AttackedDomainGetPayload<T>>

    /**
     * Find zero or more AttackedDomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttackedDomains
     * const attackedDomains = await prisma.attackedDomain.findMany()
     * 
     * // Get first 10 AttackedDomains
     * const attackedDomains = await prisma.attackedDomain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attackedDomainWithIdOnly = await prisma.attackedDomain.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttackedDomainFindManyArgs>(
      args?: SelectSubset<T, AttackedDomainFindManyArgs>
    ): Prisma.PrismaPromise<Array<AttackedDomainGetPayload<T>>>

    /**
     * Create a AttackedDomain.
     * @param {AttackedDomainCreateArgs} args - Arguments to create a AttackedDomain.
     * @example
     * // Create one AttackedDomain
     * const AttackedDomain = await prisma.attackedDomain.create({
     *   data: {
     *     // ... data to create a AttackedDomain
     *   }
     * })
     * 
    **/
    create<T extends AttackedDomainCreateArgs>(
      args: SelectSubset<T, AttackedDomainCreateArgs>
    ): Prisma__AttackedDomainClient<AttackedDomainGetPayload<T>>

    /**
     * Create many AttackedDomains.
     *     @param {AttackedDomainCreateManyArgs} args - Arguments to create many AttackedDomains.
     *     @example
     *     // Create many AttackedDomains
     *     const attackedDomain = await prisma.attackedDomain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttackedDomainCreateManyArgs>(
      args?: SelectSubset<T, AttackedDomainCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AttackedDomain.
     * @param {AttackedDomainDeleteArgs} args - Arguments to delete one AttackedDomain.
     * @example
     * // Delete one AttackedDomain
     * const AttackedDomain = await prisma.attackedDomain.delete({
     *   where: {
     *     // ... filter to delete one AttackedDomain
     *   }
     * })
     * 
    **/
    delete<T extends AttackedDomainDeleteArgs>(
      args: SelectSubset<T, AttackedDomainDeleteArgs>
    ): Prisma__AttackedDomainClient<AttackedDomainGetPayload<T>>

    /**
     * Update one AttackedDomain.
     * @param {AttackedDomainUpdateArgs} args - Arguments to update one AttackedDomain.
     * @example
     * // Update one AttackedDomain
     * const attackedDomain = await prisma.attackedDomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttackedDomainUpdateArgs>(
      args: SelectSubset<T, AttackedDomainUpdateArgs>
    ): Prisma__AttackedDomainClient<AttackedDomainGetPayload<T>>

    /**
     * Delete zero or more AttackedDomains.
     * @param {AttackedDomainDeleteManyArgs} args - Arguments to filter AttackedDomains to delete.
     * @example
     * // Delete a few AttackedDomains
     * const { count } = await prisma.attackedDomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttackedDomainDeleteManyArgs>(
      args?: SelectSubset<T, AttackedDomainDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackedDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttackedDomains
     * const attackedDomain = await prisma.attackedDomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttackedDomainUpdateManyArgs>(
      args: SelectSubset<T, AttackedDomainUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttackedDomain.
     * @param {AttackedDomainUpsertArgs} args - Arguments to update or create a AttackedDomain.
     * @example
     * // Update or create a AttackedDomain
     * const attackedDomain = await prisma.attackedDomain.upsert({
     *   create: {
     *     // ... data to create a AttackedDomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttackedDomain we want to update
     *   }
     * })
    **/
    upsert<T extends AttackedDomainUpsertArgs>(
      args: SelectSubset<T, AttackedDomainUpsertArgs>
    ): Prisma__AttackedDomainClient<AttackedDomainGetPayload<T>>

    /**
     * Count the number of AttackedDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainCountArgs} args - Arguments to filter AttackedDomains to count.
     * @example
     * // Count the number of AttackedDomains
     * const count = await prisma.attackedDomain.count({
     *   where: {
     *     // ... the filter for the AttackedDomains we want to count
     *   }
     * })
    **/
    count<T extends AttackedDomainCountArgs>(
      args?: Subset<T, AttackedDomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttackedDomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttackedDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttackedDomainAggregateArgs>(args: Subset<T, AttackedDomainAggregateArgs>): Prisma.PrismaPromise<GetAttackedDomainAggregateType<T>>

    /**
     * Group by AttackedDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttackedDomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttackedDomainGroupByArgs['orderBy'] }
        : { orderBy?: AttackedDomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttackedDomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttackedDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AttackedDomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttackedDomainClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AttackedDomain base type for findUnique actions
   */
  export type AttackedDomainFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * Filter, which AttackedDomain to fetch.
     */
    where: AttackedDomainWhereUniqueInput
  }

  /**
   * AttackedDomain findUnique
   */
  export interface AttackedDomainFindUniqueArgs extends AttackedDomainFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttackedDomain findUniqueOrThrow
   */
  export type AttackedDomainFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * Filter, which AttackedDomain to fetch.
     */
    where: AttackedDomainWhereUniqueInput
  }


  /**
   * AttackedDomain base type for findFirst actions
   */
  export type AttackedDomainFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * Filter, which AttackedDomain to fetch.
     */
    where?: AttackedDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomains to fetch.
     */
    orderBy?: Enumerable<AttackedDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackedDomains.
     */
    cursor?: AttackedDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackedDomains.
     */
    distinct?: Enumerable<AttackedDomainScalarFieldEnum>
  }

  /**
   * AttackedDomain findFirst
   */
  export interface AttackedDomainFindFirstArgs extends AttackedDomainFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttackedDomain findFirstOrThrow
   */
  export type AttackedDomainFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * Filter, which AttackedDomain to fetch.
     */
    where?: AttackedDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomains to fetch.
     */
    orderBy?: Enumerable<AttackedDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackedDomains.
     */
    cursor?: AttackedDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackedDomains.
     */
    distinct?: Enumerable<AttackedDomainScalarFieldEnum>
  }


  /**
   * AttackedDomain findMany
   */
  export type AttackedDomainFindManyArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * Filter, which AttackedDomains to fetch.
     */
    where?: AttackedDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomains to fetch.
     */
    orderBy?: Enumerable<AttackedDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttackedDomains.
     */
    cursor?: AttackedDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomains.
     */
    skip?: number
    distinct?: Enumerable<AttackedDomainScalarFieldEnum>
  }


  /**
   * AttackedDomain create
   */
  export type AttackedDomainCreateArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * The data needed to create a AttackedDomain.
     */
    data: XOR<AttackedDomainCreateInput, AttackedDomainUncheckedCreateInput>
  }


  /**
   * AttackedDomain createMany
   */
  export type AttackedDomainCreateManyArgs = {
    /**
     * The data used to create many AttackedDomains.
     */
    data: Enumerable<AttackedDomainCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AttackedDomain update
   */
  export type AttackedDomainUpdateArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * The data needed to update a AttackedDomain.
     */
    data: XOR<AttackedDomainUpdateInput, AttackedDomainUncheckedUpdateInput>
    /**
     * Choose, which AttackedDomain to update.
     */
    where: AttackedDomainWhereUniqueInput
  }


  /**
   * AttackedDomain updateMany
   */
  export type AttackedDomainUpdateManyArgs = {
    /**
     * The data used to update AttackedDomains.
     */
    data: XOR<AttackedDomainUpdateManyMutationInput, AttackedDomainUncheckedUpdateManyInput>
    /**
     * Filter which AttackedDomains to update
     */
    where?: AttackedDomainWhereInput
  }


  /**
   * AttackedDomain upsert
   */
  export type AttackedDomainUpsertArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * The filter to search for the AttackedDomain to update in case it exists.
     */
    where: AttackedDomainWhereUniqueInput
    /**
     * In case the AttackedDomain found by the `where` argument doesn't exist, create a new AttackedDomain with this data.
     */
    create: XOR<AttackedDomainCreateInput, AttackedDomainUncheckedCreateInput>
    /**
     * In case the AttackedDomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttackedDomainUpdateInput, AttackedDomainUncheckedUpdateInput>
  }


  /**
   * AttackedDomain delete
   */
  export type AttackedDomainDeleteArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
    /**
     * Filter which AttackedDomain to delete.
     */
    where: AttackedDomainWhereUniqueInput
  }


  /**
   * AttackedDomain deleteMany
   */
  export type AttackedDomainDeleteManyArgs = {
    /**
     * Filter which AttackedDomains to delete
     */
    where?: AttackedDomainWhereInput
  }


  /**
   * AttackedDomain without action
   */
  export type AttackedDomainArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomain
     */
    select?: AttackedDomainSelect | null
  }



  /**
   * Model AttackedDomainUri
   */


  export type AggregateAttackedDomainUri = {
    _count: AttackedDomainUriCountAggregateOutputType | null
    _min: AttackedDomainUriMinAggregateOutputType | null
    _max: AttackedDomainUriMaxAggregateOutputType | null
  }

  export type AttackedDomainUriMinAggregateOutputType = {
    id: string | null
    code: string | null
    organizationWebsite: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttackedDomainUriMaxAggregateOutputType = {
    id: string | null
    code: string | null
    organizationWebsite: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttackedDomainUriCountAggregateOutputType = {
    id: number
    code: number
    organizationWebsite: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttackedDomainUriMinAggregateInputType = {
    id?: true
    code?: true
    organizationWebsite?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttackedDomainUriMaxAggregateInputType = {
    id?: true
    code?: true
    organizationWebsite?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttackedDomainUriCountAggregateInputType = {
    id?: true
    code?: true
    organizationWebsite?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttackedDomainUriAggregateArgs = {
    /**
     * Filter which AttackedDomainUri to aggregate.
     */
    where?: AttackedDomainUriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomainUris to fetch.
     */
    orderBy?: Enumerable<AttackedDomainUriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttackedDomainUriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomainUris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomainUris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttackedDomainUris
    **/
    _count?: true | AttackedDomainUriCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttackedDomainUriMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttackedDomainUriMaxAggregateInputType
  }

  export type GetAttackedDomainUriAggregateType<T extends AttackedDomainUriAggregateArgs> = {
        [P in keyof T & keyof AggregateAttackedDomainUri]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttackedDomainUri[P]>
      : GetScalarType<T[P], AggregateAttackedDomainUri[P]>
  }




  export type AttackedDomainUriGroupByArgs = {
    where?: AttackedDomainUriWhereInput
    orderBy?: Enumerable<AttackedDomainUriOrderByWithAggregationInput>
    by: AttackedDomainUriScalarFieldEnum[]
    having?: AttackedDomainUriScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttackedDomainUriCountAggregateInputType | true
    _min?: AttackedDomainUriMinAggregateInputType
    _max?: AttackedDomainUriMaxAggregateInputType
  }


  export type AttackedDomainUriGroupByOutputType = {
    id: string
    code: string
    organizationWebsite: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttackedDomainUriCountAggregateOutputType | null
    _min: AttackedDomainUriMinAggregateOutputType | null
    _max: AttackedDomainUriMaxAggregateOutputType | null
  }

  type GetAttackedDomainUriGroupByPayload<T extends AttackedDomainUriGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AttackedDomainUriGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttackedDomainUriGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttackedDomainUriGroupByOutputType[P]>
            : GetScalarType<T[P], AttackedDomainUriGroupByOutputType[P]>
        }
      >
    >


  export type AttackedDomainUriSelect = {
    id?: boolean
    code?: boolean
    organizationWebsite?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AttackedDomainUriGetPayload<S extends boolean | null | undefined | AttackedDomainUriArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AttackedDomainUri :
    S extends undefined ? never :
    S extends { include: any } & (AttackedDomainUriArgs | AttackedDomainUriFindManyArgs)
    ? AttackedDomainUri 
    : S extends { select: any } & (AttackedDomainUriArgs | AttackedDomainUriFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AttackedDomainUri ? AttackedDomainUri[P] : never
  } 
      : AttackedDomainUri


  type AttackedDomainUriCountArgs = 
    Omit<AttackedDomainUriFindManyArgs, 'select' | 'include'> & {
      select?: AttackedDomainUriCountAggregateInputType | true
    }

  export interface AttackedDomainUriDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AttackedDomainUri that matches the filter.
     * @param {AttackedDomainUriFindUniqueArgs} args - Arguments to find a AttackedDomainUri
     * @example
     * // Get one AttackedDomainUri
     * const attackedDomainUri = await prisma.attackedDomainUri.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttackedDomainUriFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttackedDomainUriFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AttackedDomainUri'> extends True ? Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T>> : Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T> | null, null>

    /**
     * Find one AttackedDomainUri that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AttackedDomainUriFindUniqueOrThrowArgs} args - Arguments to find a AttackedDomainUri
     * @example
     * // Get one AttackedDomainUri
     * const attackedDomainUri = await prisma.attackedDomainUri.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AttackedDomainUriFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AttackedDomainUriFindUniqueOrThrowArgs>
    ): Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T>>

    /**
     * Find the first AttackedDomainUri that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainUriFindFirstArgs} args - Arguments to find a AttackedDomainUri
     * @example
     * // Get one AttackedDomainUri
     * const attackedDomainUri = await prisma.attackedDomainUri.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttackedDomainUriFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttackedDomainUriFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AttackedDomainUri'> extends True ? Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T>> : Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T> | null, null>

    /**
     * Find the first AttackedDomainUri that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainUriFindFirstOrThrowArgs} args - Arguments to find a AttackedDomainUri
     * @example
     * // Get one AttackedDomainUri
     * const attackedDomainUri = await prisma.attackedDomainUri.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AttackedDomainUriFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AttackedDomainUriFindFirstOrThrowArgs>
    ): Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T>>

    /**
     * Find zero or more AttackedDomainUris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainUriFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttackedDomainUris
     * const attackedDomainUris = await prisma.attackedDomainUri.findMany()
     * 
     * // Get first 10 AttackedDomainUris
     * const attackedDomainUris = await prisma.attackedDomainUri.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attackedDomainUriWithIdOnly = await prisma.attackedDomainUri.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttackedDomainUriFindManyArgs>(
      args?: SelectSubset<T, AttackedDomainUriFindManyArgs>
    ): Prisma.PrismaPromise<Array<AttackedDomainUriGetPayload<T>>>

    /**
     * Create a AttackedDomainUri.
     * @param {AttackedDomainUriCreateArgs} args - Arguments to create a AttackedDomainUri.
     * @example
     * // Create one AttackedDomainUri
     * const AttackedDomainUri = await prisma.attackedDomainUri.create({
     *   data: {
     *     // ... data to create a AttackedDomainUri
     *   }
     * })
     * 
    **/
    create<T extends AttackedDomainUriCreateArgs>(
      args: SelectSubset<T, AttackedDomainUriCreateArgs>
    ): Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T>>

    /**
     * Create many AttackedDomainUris.
     *     @param {AttackedDomainUriCreateManyArgs} args - Arguments to create many AttackedDomainUris.
     *     @example
     *     // Create many AttackedDomainUris
     *     const attackedDomainUri = await prisma.attackedDomainUri.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttackedDomainUriCreateManyArgs>(
      args?: SelectSubset<T, AttackedDomainUriCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AttackedDomainUri.
     * @param {AttackedDomainUriDeleteArgs} args - Arguments to delete one AttackedDomainUri.
     * @example
     * // Delete one AttackedDomainUri
     * const AttackedDomainUri = await prisma.attackedDomainUri.delete({
     *   where: {
     *     // ... filter to delete one AttackedDomainUri
     *   }
     * })
     * 
    **/
    delete<T extends AttackedDomainUriDeleteArgs>(
      args: SelectSubset<T, AttackedDomainUriDeleteArgs>
    ): Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T>>

    /**
     * Update one AttackedDomainUri.
     * @param {AttackedDomainUriUpdateArgs} args - Arguments to update one AttackedDomainUri.
     * @example
     * // Update one AttackedDomainUri
     * const attackedDomainUri = await prisma.attackedDomainUri.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttackedDomainUriUpdateArgs>(
      args: SelectSubset<T, AttackedDomainUriUpdateArgs>
    ): Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T>>

    /**
     * Delete zero or more AttackedDomainUris.
     * @param {AttackedDomainUriDeleteManyArgs} args - Arguments to filter AttackedDomainUris to delete.
     * @example
     * // Delete a few AttackedDomainUris
     * const { count } = await prisma.attackedDomainUri.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttackedDomainUriDeleteManyArgs>(
      args?: SelectSubset<T, AttackedDomainUriDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackedDomainUris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainUriUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttackedDomainUris
     * const attackedDomainUri = await prisma.attackedDomainUri.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttackedDomainUriUpdateManyArgs>(
      args: SelectSubset<T, AttackedDomainUriUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttackedDomainUri.
     * @param {AttackedDomainUriUpsertArgs} args - Arguments to update or create a AttackedDomainUri.
     * @example
     * // Update or create a AttackedDomainUri
     * const attackedDomainUri = await prisma.attackedDomainUri.upsert({
     *   create: {
     *     // ... data to create a AttackedDomainUri
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttackedDomainUri we want to update
     *   }
     * })
    **/
    upsert<T extends AttackedDomainUriUpsertArgs>(
      args: SelectSubset<T, AttackedDomainUriUpsertArgs>
    ): Prisma__AttackedDomainUriClient<AttackedDomainUriGetPayload<T>>

    /**
     * Count the number of AttackedDomainUris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainUriCountArgs} args - Arguments to filter AttackedDomainUris to count.
     * @example
     * // Count the number of AttackedDomainUris
     * const count = await prisma.attackedDomainUri.count({
     *   where: {
     *     // ... the filter for the AttackedDomainUris we want to count
     *   }
     * })
    **/
    count<T extends AttackedDomainUriCountArgs>(
      args?: Subset<T, AttackedDomainUriCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttackedDomainUriCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttackedDomainUri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainUriAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttackedDomainUriAggregateArgs>(args: Subset<T, AttackedDomainUriAggregateArgs>): Prisma.PrismaPromise<GetAttackedDomainUriAggregateType<T>>

    /**
     * Group by AttackedDomainUri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainUriGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttackedDomainUriGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttackedDomainUriGroupByArgs['orderBy'] }
        : { orderBy?: AttackedDomainUriGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttackedDomainUriGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttackedDomainUriGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AttackedDomainUri.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttackedDomainUriClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AttackedDomainUri base type for findUnique actions
   */
  export type AttackedDomainUriFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * Filter, which AttackedDomainUri to fetch.
     */
    where: AttackedDomainUriWhereUniqueInput
  }

  /**
   * AttackedDomainUri findUnique
   */
  export interface AttackedDomainUriFindUniqueArgs extends AttackedDomainUriFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttackedDomainUri findUniqueOrThrow
   */
  export type AttackedDomainUriFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * Filter, which AttackedDomainUri to fetch.
     */
    where: AttackedDomainUriWhereUniqueInput
  }


  /**
   * AttackedDomainUri base type for findFirst actions
   */
  export type AttackedDomainUriFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * Filter, which AttackedDomainUri to fetch.
     */
    where?: AttackedDomainUriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomainUris to fetch.
     */
    orderBy?: Enumerable<AttackedDomainUriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackedDomainUris.
     */
    cursor?: AttackedDomainUriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomainUris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomainUris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackedDomainUris.
     */
    distinct?: Enumerable<AttackedDomainUriScalarFieldEnum>
  }

  /**
   * AttackedDomainUri findFirst
   */
  export interface AttackedDomainUriFindFirstArgs extends AttackedDomainUriFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttackedDomainUri findFirstOrThrow
   */
  export type AttackedDomainUriFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * Filter, which AttackedDomainUri to fetch.
     */
    where?: AttackedDomainUriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomainUris to fetch.
     */
    orderBy?: Enumerable<AttackedDomainUriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackedDomainUris.
     */
    cursor?: AttackedDomainUriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomainUris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomainUris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackedDomainUris.
     */
    distinct?: Enumerable<AttackedDomainUriScalarFieldEnum>
  }


  /**
   * AttackedDomainUri findMany
   */
  export type AttackedDomainUriFindManyArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * Filter, which AttackedDomainUris to fetch.
     */
    where?: AttackedDomainUriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomainUris to fetch.
     */
    orderBy?: Enumerable<AttackedDomainUriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttackedDomainUris.
     */
    cursor?: AttackedDomainUriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomainUris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomainUris.
     */
    skip?: number
    distinct?: Enumerable<AttackedDomainUriScalarFieldEnum>
  }


  /**
   * AttackedDomainUri create
   */
  export type AttackedDomainUriCreateArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * The data needed to create a AttackedDomainUri.
     */
    data: XOR<AttackedDomainUriCreateInput, AttackedDomainUriUncheckedCreateInput>
  }


  /**
   * AttackedDomainUri createMany
   */
  export type AttackedDomainUriCreateManyArgs = {
    /**
     * The data used to create many AttackedDomainUris.
     */
    data: Enumerable<AttackedDomainUriCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AttackedDomainUri update
   */
  export type AttackedDomainUriUpdateArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * The data needed to update a AttackedDomainUri.
     */
    data: XOR<AttackedDomainUriUpdateInput, AttackedDomainUriUncheckedUpdateInput>
    /**
     * Choose, which AttackedDomainUri to update.
     */
    where: AttackedDomainUriWhereUniqueInput
  }


  /**
   * AttackedDomainUri updateMany
   */
  export type AttackedDomainUriUpdateManyArgs = {
    /**
     * The data used to update AttackedDomainUris.
     */
    data: XOR<AttackedDomainUriUpdateManyMutationInput, AttackedDomainUriUncheckedUpdateManyInput>
    /**
     * Filter which AttackedDomainUris to update
     */
    where?: AttackedDomainUriWhereInput
  }


  /**
   * AttackedDomainUri upsert
   */
  export type AttackedDomainUriUpsertArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * The filter to search for the AttackedDomainUri to update in case it exists.
     */
    where: AttackedDomainUriWhereUniqueInput
    /**
     * In case the AttackedDomainUri found by the `where` argument doesn't exist, create a new AttackedDomainUri with this data.
     */
    create: XOR<AttackedDomainUriCreateInput, AttackedDomainUriUncheckedCreateInput>
    /**
     * In case the AttackedDomainUri was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttackedDomainUriUpdateInput, AttackedDomainUriUncheckedUpdateInput>
  }


  /**
   * AttackedDomainUri delete
   */
  export type AttackedDomainUriDeleteArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
    /**
     * Filter which AttackedDomainUri to delete.
     */
    where: AttackedDomainUriWhereUniqueInput
  }


  /**
   * AttackedDomainUri deleteMany
   */
  export type AttackedDomainUriDeleteManyArgs = {
    /**
     * Filter which AttackedDomainUris to delete
     */
    where?: AttackedDomainUriWhereInput
  }


  /**
   * AttackedDomainUri without action
   */
  export type AttackedDomainUriArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainUri
     */
    select?: AttackedDomainUriSelect | null
  }



  /**
   * Model AttackedDomainEmail
   */


  export type AggregateAttackedDomainEmail = {
    _count: AttackedDomainEmailCountAggregateOutputType | null
    _min: AttackedDomainEmailMinAggregateOutputType | null
    _max: AttackedDomainEmailMaxAggregateOutputType | null
  }

  export type AttackedDomainEmailMinAggregateOutputType = {
    id: string | null
    code: string | null
    email: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttackedDomainEmailMaxAggregateOutputType = {
    id: string | null
    code: string | null
    email: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttackedDomainEmailCountAggregateOutputType = {
    id: number
    code: number
    email: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttackedDomainEmailMinAggregateInputType = {
    id?: true
    code?: true
    email?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttackedDomainEmailMaxAggregateInputType = {
    id?: true
    code?: true
    email?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttackedDomainEmailCountAggregateInputType = {
    id?: true
    code?: true
    email?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttackedDomainEmailAggregateArgs = {
    /**
     * Filter which AttackedDomainEmail to aggregate.
     */
    where?: AttackedDomainEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomainEmails to fetch.
     */
    orderBy?: Enumerable<AttackedDomainEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttackedDomainEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomainEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomainEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttackedDomainEmails
    **/
    _count?: true | AttackedDomainEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttackedDomainEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttackedDomainEmailMaxAggregateInputType
  }

  export type GetAttackedDomainEmailAggregateType<T extends AttackedDomainEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateAttackedDomainEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttackedDomainEmail[P]>
      : GetScalarType<T[P], AggregateAttackedDomainEmail[P]>
  }




  export type AttackedDomainEmailGroupByArgs = {
    where?: AttackedDomainEmailWhereInput
    orderBy?: Enumerable<AttackedDomainEmailOrderByWithAggregationInput>
    by: AttackedDomainEmailScalarFieldEnum[]
    having?: AttackedDomainEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttackedDomainEmailCountAggregateInputType | true
    _min?: AttackedDomainEmailMinAggregateInputType
    _max?: AttackedDomainEmailMaxAggregateInputType
  }


  export type AttackedDomainEmailGroupByOutputType = {
    id: string
    code: string
    email: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AttackedDomainEmailCountAggregateOutputType | null
    _min: AttackedDomainEmailMinAggregateOutputType | null
    _max: AttackedDomainEmailMaxAggregateOutputType | null
  }

  type GetAttackedDomainEmailGroupByPayload<T extends AttackedDomainEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AttackedDomainEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttackedDomainEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttackedDomainEmailGroupByOutputType[P]>
            : GetScalarType<T[P], AttackedDomainEmailGroupByOutputType[P]>
        }
      >
    >


  export type AttackedDomainEmailSelect = {
    id?: boolean
    code?: boolean
    email?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AttackedDomainEmailGetPayload<S extends boolean | null | undefined | AttackedDomainEmailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AttackedDomainEmail :
    S extends undefined ? never :
    S extends { include: any } & (AttackedDomainEmailArgs | AttackedDomainEmailFindManyArgs)
    ? AttackedDomainEmail 
    : S extends { select: any } & (AttackedDomainEmailArgs | AttackedDomainEmailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AttackedDomainEmail ? AttackedDomainEmail[P] : never
  } 
      : AttackedDomainEmail


  type AttackedDomainEmailCountArgs = 
    Omit<AttackedDomainEmailFindManyArgs, 'select' | 'include'> & {
      select?: AttackedDomainEmailCountAggregateInputType | true
    }

  export interface AttackedDomainEmailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AttackedDomainEmail that matches the filter.
     * @param {AttackedDomainEmailFindUniqueArgs} args - Arguments to find a AttackedDomainEmail
     * @example
     * // Get one AttackedDomainEmail
     * const attackedDomainEmail = await prisma.attackedDomainEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AttackedDomainEmailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AttackedDomainEmailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AttackedDomainEmail'> extends True ? Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T>> : Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T> | null, null>

    /**
     * Find one AttackedDomainEmail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AttackedDomainEmailFindUniqueOrThrowArgs} args - Arguments to find a AttackedDomainEmail
     * @example
     * // Get one AttackedDomainEmail
     * const attackedDomainEmail = await prisma.attackedDomainEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AttackedDomainEmailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AttackedDomainEmailFindUniqueOrThrowArgs>
    ): Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T>>

    /**
     * Find the first AttackedDomainEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainEmailFindFirstArgs} args - Arguments to find a AttackedDomainEmail
     * @example
     * // Get one AttackedDomainEmail
     * const attackedDomainEmail = await prisma.attackedDomainEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AttackedDomainEmailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AttackedDomainEmailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AttackedDomainEmail'> extends True ? Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T>> : Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T> | null, null>

    /**
     * Find the first AttackedDomainEmail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainEmailFindFirstOrThrowArgs} args - Arguments to find a AttackedDomainEmail
     * @example
     * // Get one AttackedDomainEmail
     * const attackedDomainEmail = await prisma.attackedDomainEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AttackedDomainEmailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AttackedDomainEmailFindFirstOrThrowArgs>
    ): Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T>>

    /**
     * Find zero or more AttackedDomainEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainEmailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttackedDomainEmails
     * const attackedDomainEmails = await prisma.attackedDomainEmail.findMany()
     * 
     * // Get first 10 AttackedDomainEmails
     * const attackedDomainEmails = await prisma.attackedDomainEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attackedDomainEmailWithIdOnly = await prisma.attackedDomainEmail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AttackedDomainEmailFindManyArgs>(
      args?: SelectSubset<T, AttackedDomainEmailFindManyArgs>
    ): Prisma.PrismaPromise<Array<AttackedDomainEmailGetPayload<T>>>

    /**
     * Create a AttackedDomainEmail.
     * @param {AttackedDomainEmailCreateArgs} args - Arguments to create a AttackedDomainEmail.
     * @example
     * // Create one AttackedDomainEmail
     * const AttackedDomainEmail = await prisma.attackedDomainEmail.create({
     *   data: {
     *     // ... data to create a AttackedDomainEmail
     *   }
     * })
     * 
    **/
    create<T extends AttackedDomainEmailCreateArgs>(
      args: SelectSubset<T, AttackedDomainEmailCreateArgs>
    ): Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T>>

    /**
     * Create many AttackedDomainEmails.
     *     @param {AttackedDomainEmailCreateManyArgs} args - Arguments to create many AttackedDomainEmails.
     *     @example
     *     // Create many AttackedDomainEmails
     *     const attackedDomainEmail = await prisma.attackedDomainEmail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AttackedDomainEmailCreateManyArgs>(
      args?: SelectSubset<T, AttackedDomainEmailCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AttackedDomainEmail.
     * @param {AttackedDomainEmailDeleteArgs} args - Arguments to delete one AttackedDomainEmail.
     * @example
     * // Delete one AttackedDomainEmail
     * const AttackedDomainEmail = await prisma.attackedDomainEmail.delete({
     *   where: {
     *     // ... filter to delete one AttackedDomainEmail
     *   }
     * })
     * 
    **/
    delete<T extends AttackedDomainEmailDeleteArgs>(
      args: SelectSubset<T, AttackedDomainEmailDeleteArgs>
    ): Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T>>

    /**
     * Update one AttackedDomainEmail.
     * @param {AttackedDomainEmailUpdateArgs} args - Arguments to update one AttackedDomainEmail.
     * @example
     * // Update one AttackedDomainEmail
     * const attackedDomainEmail = await prisma.attackedDomainEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AttackedDomainEmailUpdateArgs>(
      args: SelectSubset<T, AttackedDomainEmailUpdateArgs>
    ): Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T>>

    /**
     * Delete zero or more AttackedDomainEmails.
     * @param {AttackedDomainEmailDeleteManyArgs} args - Arguments to filter AttackedDomainEmails to delete.
     * @example
     * // Delete a few AttackedDomainEmails
     * const { count } = await prisma.attackedDomainEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AttackedDomainEmailDeleteManyArgs>(
      args?: SelectSubset<T, AttackedDomainEmailDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttackedDomainEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttackedDomainEmails
     * const attackedDomainEmail = await prisma.attackedDomainEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AttackedDomainEmailUpdateManyArgs>(
      args: SelectSubset<T, AttackedDomainEmailUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttackedDomainEmail.
     * @param {AttackedDomainEmailUpsertArgs} args - Arguments to update or create a AttackedDomainEmail.
     * @example
     * // Update or create a AttackedDomainEmail
     * const attackedDomainEmail = await prisma.attackedDomainEmail.upsert({
     *   create: {
     *     // ... data to create a AttackedDomainEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttackedDomainEmail we want to update
     *   }
     * })
    **/
    upsert<T extends AttackedDomainEmailUpsertArgs>(
      args: SelectSubset<T, AttackedDomainEmailUpsertArgs>
    ): Prisma__AttackedDomainEmailClient<AttackedDomainEmailGetPayload<T>>

    /**
     * Count the number of AttackedDomainEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainEmailCountArgs} args - Arguments to filter AttackedDomainEmails to count.
     * @example
     * // Count the number of AttackedDomainEmails
     * const count = await prisma.attackedDomainEmail.count({
     *   where: {
     *     // ... the filter for the AttackedDomainEmails we want to count
     *   }
     * })
    **/
    count<T extends AttackedDomainEmailCountArgs>(
      args?: Subset<T, AttackedDomainEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttackedDomainEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttackedDomainEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttackedDomainEmailAggregateArgs>(args: Subset<T, AttackedDomainEmailAggregateArgs>): Prisma.PrismaPromise<GetAttackedDomainEmailAggregateType<T>>

    /**
     * Group by AttackedDomainEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttackedDomainEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttackedDomainEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttackedDomainEmailGroupByArgs['orderBy'] }
        : { orderBy?: AttackedDomainEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttackedDomainEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttackedDomainEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AttackedDomainEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AttackedDomainEmailClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AttackedDomainEmail base type for findUnique actions
   */
  export type AttackedDomainEmailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * Filter, which AttackedDomainEmail to fetch.
     */
    where: AttackedDomainEmailWhereUniqueInput
  }

  /**
   * AttackedDomainEmail findUnique
   */
  export interface AttackedDomainEmailFindUniqueArgs extends AttackedDomainEmailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttackedDomainEmail findUniqueOrThrow
   */
  export type AttackedDomainEmailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * Filter, which AttackedDomainEmail to fetch.
     */
    where: AttackedDomainEmailWhereUniqueInput
  }


  /**
   * AttackedDomainEmail base type for findFirst actions
   */
  export type AttackedDomainEmailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * Filter, which AttackedDomainEmail to fetch.
     */
    where?: AttackedDomainEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomainEmails to fetch.
     */
    orderBy?: Enumerable<AttackedDomainEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackedDomainEmails.
     */
    cursor?: AttackedDomainEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomainEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomainEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackedDomainEmails.
     */
    distinct?: Enumerable<AttackedDomainEmailScalarFieldEnum>
  }

  /**
   * AttackedDomainEmail findFirst
   */
  export interface AttackedDomainEmailFindFirstArgs extends AttackedDomainEmailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AttackedDomainEmail findFirstOrThrow
   */
  export type AttackedDomainEmailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * Filter, which AttackedDomainEmail to fetch.
     */
    where?: AttackedDomainEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomainEmails to fetch.
     */
    orderBy?: Enumerable<AttackedDomainEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttackedDomainEmails.
     */
    cursor?: AttackedDomainEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomainEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomainEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttackedDomainEmails.
     */
    distinct?: Enumerable<AttackedDomainEmailScalarFieldEnum>
  }


  /**
   * AttackedDomainEmail findMany
   */
  export type AttackedDomainEmailFindManyArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * Filter, which AttackedDomainEmails to fetch.
     */
    where?: AttackedDomainEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttackedDomainEmails to fetch.
     */
    orderBy?: Enumerable<AttackedDomainEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttackedDomainEmails.
     */
    cursor?: AttackedDomainEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttackedDomainEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttackedDomainEmails.
     */
    skip?: number
    distinct?: Enumerable<AttackedDomainEmailScalarFieldEnum>
  }


  /**
   * AttackedDomainEmail create
   */
  export type AttackedDomainEmailCreateArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * The data needed to create a AttackedDomainEmail.
     */
    data: XOR<AttackedDomainEmailCreateInput, AttackedDomainEmailUncheckedCreateInput>
  }


  /**
   * AttackedDomainEmail createMany
   */
  export type AttackedDomainEmailCreateManyArgs = {
    /**
     * The data used to create many AttackedDomainEmails.
     */
    data: Enumerable<AttackedDomainEmailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AttackedDomainEmail update
   */
  export type AttackedDomainEmailUpdateArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * The data needed to update a AttackedDomainEmail.
     */
    data: XOR<AttackedDomainEmailUpdateInput, AttackedDomainEmailUncheckedUpdateInput>
    /**
     * Choose, which AttackedDomainEmail to update.
     */
    where: AttackedDomainEmailWhereUniqueInput
  }


  /**
   * AttackedDomainEmail updateMany
   */
  export type AttackedDomainEmailUpdateManyArgs = {
    /**
     * The data used to update AttackedDomainEmails.
     */
    data: XOR<AttackedDomainEmailUpdateManyMutationInput, AttackedDomainEmailUncheckedUpdateManyInput>
    /**
     * Filter which AttackedDomainEmails to update
     */
    where?: AttackedDomainEmailWhereInput
  }


  /**
   * AttackedDomainEmail upsert
   */
  export type AttackedDomainEmailUpsertArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * The filter to search for the AttackedDomainEmail to update in case it exists.
     */
    where: AttackedDomainEmailWhereUniqueInput
    /**
     * In case the AttackedDomainEmail found by the `where` argument doesn't exist, create a new AttackedDomainEmail with this data.
     */
    create: XOR<AttackedDomainEmailCreateInput, AttackedDomainEmailUncheckedCreateInput>
    /**
     * In case the AttackedDomainEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttackedDomainEmailUpdateInput, AttackedDomainEmailUncheckedUpdateInput>
  }


  /**
   * AttackedDomainEmail delete
   */
  export type AttackedDomainEmailDeleteArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
    /**
     * Filter which AttackedDomainEmail to delete.
     */
    where: AttackedDomainEmailWhereUniqueInput
  }


  /**
   * AttackedDomainEmail deleteMany
   */
  export type AttackedDomainEmailDeleteManyArgs = {
    /**
     * Filter which AttackedDomainEmails to delete
     */
    where?: AttackedDomainEmailWhereInput
  }


  /**
   * AttackedDomainEmail without action
   */
  export type AttackedDomainEmailArgs = {
    /**
     * Select specific fields to fetch from the AttackedDomainEmail
     */
    select?: AttackedDomainEmailSelect | null
  }



  /**
   * Model HarmfulDomain
   */


  export type AggregateHarmfulDomain = {
    _count: HarmfulDomainCountAggregateOutputType | null
    _min: HarmfulDomainMinAggregateOutputType | null
    _max: HarmfulDomainMaxAggregateOutputType | null
  }

  export type HarmfulDomainMinAggregateOutputType = {
    id: string | null
    hosting: string | null
    domainSupport: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HarmfulDomainMaxAggregateOutputType = {
    id: string | null
    hosting: string | null
    domainSupport: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HarmfulDomainCountAggregateOutputType = {
    id: number
    hosting: number
    domainSupport: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HarmfulDomainMinAggregateInputType = {
    id?: true
    hosting?: true
    domainSupport?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HarmfulDomainMaxAggregateInputType = {
    id?: true
    hosting?: true
    domainSupport?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HarmfulDomainCountAggregateInputType = {
    id?: true
    hosting?: true
    domainSupport?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HarmfulDomainAggregateArgs = {
    /**
     * Filter which HarmfulDomain to aggregate.
     */
    where?: HarmfulDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomains to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HarmfulDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HarmfulDomains
    **/
    _count?: true | HarmfulDomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HarmfulDomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HarmfulDomainMaxAggregateInputType
  }

  export type GetHarmfulDomainAggregateType<T extends HarmfulDomainAggregateArgs> = {
        [P in keyof T & keyof AggregateHarmfulDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHarmfulDomain[P]>
      : GetScalarType<T[P], AggregateHarmfulDomain[P]>
  }




  export type HarmfulDomainGroupByArgs = {
    where?: HarmfulDomainWhereInput
    orderBy?: Enumerable<HarmfulDomainOrderByWithAggregationInput>
    by: HarmfulDomainScalarFieldEnum[]
    having?: HarmfulDomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HarmfulDomainCountAggregateInputType | true
    _min?: HarmfulDomainMinAggregateInputType
    _max?: HarmfulDomainMaxAggregateInputType
  }


  export type HarmfulDomainGroupByOutputType = {
    id: string
    hosting: string
    domainSupport: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: HarmfulDomainCountAggregateOutputType | null
    _min: HarmfulDomainMinAggregateOutputType | null
    _max: HarmfulDomainMaxAggregateOutputType | null
  }

  type GetHarmfulDomainGroupByPayload<T extends HarmfulDomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HarmfulDomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HarmfulDomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HarmfulDomainGroupByOutputType[P]>
            : GetScalarType<T[P], HarmfulDomainGroupByOutputType[P]>
        }
      >
    >


  export type HarmfulDomainSelect = {
    id?: boolean
    hosting?: boolean
    domainSupport?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type HarmfulDomainGetPayload<S extends boolean | null | undefined | HarmfulDomainArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HarmfulDomain :
    S extends undefined ? never :
    S extends { include: any } & (HarmfulDomainArgs | HarmfulDomainFindManyArgs)
    ? HarmfulDomain 
    : S extends { select: any } & (HarmfulDomainArgs | HarmfulDomainFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HarmfulDomain ? HarmfulDomain[P] : never
  } 
      : HarmfulDomain


  type HarmfulDomainCountArgs = 
    Omit<HarmfulDomainFindManyArgs, 'select' | 'include'> & {
      select?: HarmfulDomainCountAggregateInputType | true
    }

  export interface HarmfulDomainDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HarmfulDomain that matches the filter.
     * @param {HarmfulDomainFindUniqueArgs} args - Arguments to find a HarmfulDomain
     * @example
     * // Get one HarmfulDomain
     * const harmfulDomain = await prisma.harmfulDomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HarmfulDomainFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HarmfulDomainFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HarmfulDomain'> extends True ? Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T>> : Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T> | null, null>

    /**
     * Find one HarmfulDomain that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HarmfulDomainFindUniqueOrThrowArgs} args - Arguments to find a HarmfulDomain
     * @example
     * // Get one HarmfulDomain
     * const harmfulDomain = await prisma.harmfulDomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HarmfulDomainFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HarmfulDomainFindUniqueOrThrowArgs>
    ): Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T>>

    /**
     * Find the first HarmfulDomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainFindFirstArgs} args - Arguments to find a HarmfulDomain
     * @example
     * // Get one HarmfulDomain
     * const harmfulDomain = await prisma.harmfulDomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HarmfulDomainFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HarmfulDomainFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HarmfulDomain'> extends True ? Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T>> : Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T> | null, null>

    /**
     * Find the first HarmfulDomain that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainFindFirstOrThrowArgs} args - Arguments to find a HarmfulDomain
     * @example
     * // Get one HarmfulDomain
     * const harmfulDomain = await prisma.harmfulDomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HarmfulDomainFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HarmfulDomainFindFirstOrThrowArgs>
    ): Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T>>

    /**
     * Find zero or more HarmfulDomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HarmfulDomains
     * const harmfulDomains = await prisma.harmfulDomain.findMany()
     * 
     * // Get first 10 HarmfulDomains
     * const harmfulDomains = await prisma.harmfulDomain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const harmfulDomainWithIdOnly = await prisma.harmfulDomain.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HarmfulDomainFindManyArgs>(
      args?: SelectSubset<T, HarmfulDomainFindManyArgs>
    ): Prisma.PrismaPromise<Array<HarmfulDomainGetPayload<T>>>

    /**
     * Create a HarmfulDomain.
     * @param {HarmfulDomainCreateArgs} args - Arguments to create a HarmfulDomain.
     * @example
     * // Create one HarmfulDomain
     * const HarmfulDomain = await prisma.harmfulDomain.create({
     *   data: {
     *     // ... data to create a HarmfulDomain
     *   }
     * })
     * 
    **/
    create<T extends HarmfulDomainCreateArgs>(
      args: SelectSubset<T, HarmfulDomainCreateArgs>
    ): Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T>>

    /**
     * Create many HarmfulDomains.
     *     @param {HarmfulDomainCreateManyArgs} args - Arguments to create many HarmfulDomains.
     *     @example
     *     // Create many HarmfulDomains
     *     const harmfulDomain = await prisma.harmfulDomain.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HarmfulDomainCreateManyArgs>(
      args?: SelectSubset<T, HarmfulDomainCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HarmfulDomain.
     * @param {HarmfulDomainDeleteArgs} args - Arguments to delete one HarmfulDomain.
     * @example
     * // Delete one HarmfulDomain
     * const HarmfulDomain = await prisma.harmfulDomain.delete({
     *   where: {
     *     // ... filter to delete one HarmfulDomain
     *   }
     * })
     * 
    **/
    delete<T extends HarmfulDomainDeleteArgs>(
      args: SelectSubset<T, HarmfulDomainDeleteArgs>
    ): Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T>>

    /**
     * Update one HarmfulDomain.
     * @param {HarmfulDomainUpdateArgs} args - Arguments to update one HarmfulDomain.
     * @example
     * // Update one HarmfulDomain
     * const harmfulDomain = await prisma.harmfulDomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HarmfulDomainUpdateArgs>(
      args: SelectSubset<T, HarmfulDomainUpdateArgs>
    ): Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T>>

    /**
     * Delete zero or more HarmfulDomains.
     * @param {HarmfulDomainDeleteManyArgs} args - Arguments to filter HarmfulDomains to delete.
     * @example
     * // Delete a few HarmfulDomains
     * const { count } = await prisma.harmfulDomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HarmfulDomainDeleteManyArgs>(
      args?: SelectSubset<T, HarmfulDomainDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HarmfulDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HarmfulDomains
     * const harmfulDomain = await prisma.harmfulDomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HarmfulDomainUpdateManyArgs>(
      args: SelectSubset<T, HarmfulDomainUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HarmfulDomain.
     * @param {HarmfulDomainUpsertArgs} args - Arguments to update or create a HarmfulDomain.
     * @example
     * // Update or create a HarmfulDomain
     * const harmfulDomain = await prisma.harmfulDomain.upsert({
     *   create: {
     *     // ... data to create a HarmfulDomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HarmfulDomain we want to update
     *   }
     * })
    **/
    upsert<T extends HarmfulDomainUpsertArgs>(
      args: SelectSubset<T, HarmfulDomainUpsertArgs>
    ): Prisma__HarmfulDomainClient<HarmfulDomainGetPayload<T>>

    /**
     * Count the number of HarmfulDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainCountArgs} args - Arguments to filter HarmfulDomains to count.
     * @example
     * // Count the number of HarmfulDomains
     * const count = await prisma.harmfulDomain.count({
     *   where: {
     *     // ... the filter for the HarmfulDomains we want to count
     *   }
     * })
    **/
    count<T extends HarmfulDomainCountArgs>(
      args?: Subset<T, HarmfulDomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HarmfulDomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HarmfulDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HarmfulDomainAggregateArgs>(args: Subset<T, HarmfulDomainAggregateArgs>): Prisma.PrismaPromise<GetHarmfulDomainAggregateType<T>>

    /**
     * Group by HarmfulDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HarmfulDomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HarmfulDomainGroupByArgs['orderBy'] }
        : { orderBy?: HarmfulDomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HarmfulDomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHarmfulDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HarmfulDomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HarmfulDomainClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HarmfulDomain base type for findUnique actions
   */
  export type HarmfulDomainFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * Filter, which HarmfulDomain to fetch.
     */
    where: HarmfulDomainWhereUniqueInput
  }

  /**
   * HarmfulDomain findUnique
   */
  export interface HarmfulDomainFindUniqueArgs extends HarmfulDomainFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HarmfulDomain findUniqueOrThrow
   */
  export type HarmfulDomainFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * Filter, which HarmfulDomain to fetch.
     */
    where: HarmfulDomainWhereUniqueInput
  }


  /**
   * HarmfulDomain base type for findFirst actions
   */
  export type HarmfulDomainFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * Filter, which HarmfulDomain to fetch.
     */
    where?: HarmfulDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomains to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HarmfulDomains.
     */
    cursor?: HarmfulDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HarmfulDomains.
     */
    distinct?: Enumerable<HarmfulDomainScalarFieldEnum>
  }

  /**
   * HarmfulDomain findFirst
   */
  export interface HarmfulDomainFindFirstArgs extends HarmfulDomainFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HarmfulDomain findFirstOrThrow
   */
  export type HarmfulDomainFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * Filter, which HarmfulDomain to fetch.
     */
    where?: HarmfulDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomains to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HarmfulDomains.
     */
    cursor?: HarmfulDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HarmfulDomains.
     */
    distinct?: Enumerable<HarmfulDomainScalarFieldEnum>
  }


  /**
   * HarmfulDomain findMany
   */
  export type HarmfulDomainFindManyArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * Filter, which HarmfulDomains to fetch.
     */
    where?: HarmfulDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomains to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HarmfulDomains.
     */
    cursor?: HarmfulDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomains.
     */
    skip?: number
    distinct?: Enumerable<HarmfulDomainScalarFieldEnum>
  }


  /**
   * HarmfulDomain create
   */
  export type HarmfulDomainCreateArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * The data needed to create a HarmfulDomain.
     */
    data: XOR<HarmfulDomainCreateInput, HarmfulDomainUncheckedCreateInput>
  }


  /**
   * HarmfulDomain createMany
   */
  export type HarmfulDomainCreateManyArgs = {
    /**
     * The data used to create many HarmfulDomains.
     */
    data: Enumerable<HarmfulDomainCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HarmfulDomain update
   */
  export type HarmfulDomainUpdateArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * The data needed to update a HarmfulDomain.
     */
    data: XOR<HarmfulDomainUpdateInput, HarmfulDomainUncheckedUpdateInput>
    /**
     * Choose, which HarmfulDomain to update.
     */
    where: HarmfulDomainWhereUniqueInput
  }


  /**
   * HarmfulDomain updateMany
   */
  export type HarmfulDomainUpdateManyArgs = {
    /**
     * The data used to update HarmfulDomains.
     */
    data: XOR<HarmfulDomainUpdateManyMutationInput, HarmfulDomainUncheckedUpdateManyInput>
    /**
     * Filter which HarmfulDomains to update
     */
    where?: HarmfulDomainWhereInput
  }


  /**
   * HarmfulDomain upsert
   */
  export type HarmfulDomainUpsertArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * The filter to search for the HarmfulDomain to update in case it exists.
     */
    where: HarmfulDomainWhereUniqueInput
    /**
     * In case the HarmfulDomain found by the `where` argument doesn't exist, create a new HarmfulDomain with this data.
     */
    create: XOR<HarmfulDomainCreateInput, HarmfulDomainUncheckedCreateInput>
    /**
     * In case the HarmfulDomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HarmfulDomainUpdateInput, HarmfulDomainUncheckedUpdateInput>
  }


  /**
   * HarmfulDomain delete
   */
  export type HarmfulDomainDeleteArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
    /**
     * Filter which HarmfulDomain to delete.
     */
    where: HarmfulDomainWhereUniqueInput
  }


  /**
   * HarmfulDomain deleteMany
   */
  export type HarmfulDomainDeleteManyArgs = {
    /**
     * Filter which HarmfulDomains to delete
     */
    where?: HarmfulDomainWhereInput
  }


  /**
   * HarmfulDomain without action
   */
  export type HarmfulDomainArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomain
     */
    select?: HarmfulDomainSelect | null
  }



  /**
   * Model HarmfulDomainUri
   */


  export type AggregateHarmfulDomainUri = {
    _count: HarmfulDomainUriCountAggregateOutputType | null
    _min: HarmfulDomainUriMinAggregateOutputType | null
    _max: HarmfulDomainUriMaxAggregateOutputType | null
  }

  export type HarmfulDomainUriMinAggregateOutputType = {
    id: string | null
    code: string | null
    organizationWebsite: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HarmfulDomainUriMaxAggregateOutputType = {
    id: string | null
    code: string | null
    organizationWebsite: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HarmfulDomainUriCountAggregateOutputType = {
    id: number
    code: number
    organizationWebsite: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HarmfulDomainUriMinAggregateInputType = {
    id?: true
    code?: true
    organizationWebsite?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HarmfulDomainUriMaxAggregateInputType = {
    id?: true
    code?: true
    organizationWebsite?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HarmfulDomainUriCountAggregateInputType = {
    id?: true
    code?: true
    organizationWebsite?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HarmfulDomainUriAggregateArgs = {
    /**
     * Filter which HarmfulDomainUri to aggregate.
     */
    where?: HarmfulDomainUriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomainUris to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainUriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HarmfulDomainUriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomainUris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomainUris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HarmfulDomainUris
    **/
    _count?: true | HarmfulDomainUriCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HarmfulDomainUriMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HarmfulDomainUriMaxAggregateInputType
  }

  export type GetHarmfulDomainUriAggregateType<T extends HarmfulDomainUriAggregateArgs> = {
        [P in keyof T & keyof AggregateHarmfulDomainUri]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHarmfulDomainUri[P]>
      : GetScalarType<T[P], AggregateHarmfulDomainUri[P]>
  }




  export type HarmfulDomainUriGroupByArgs = {
    where?: HarmfulDomainUriWhereInput
    orderBy?: Enumerable<HarmfulDomainUriOrderByWithAggregationInput>
    by: HarmfulDomainUriScalarFieldEnum[]
    having?: HarmfulDomainUriScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HarmfulDomainUriCountAggregateInputType | true
    _min?: HarmfulDomainUriMinAggregateInputType
    _max?: HarmfulDomainUriMaxAggregateInputType
  }


  export type HarmfulDomainUriGroupByOutputType = {
    id: string
    code: string
    organizationWebsite: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: HarmfulDomainUriCountAggregateOutputType | null
    _min: HarmfulDomainUriMinAggregateOutputType | null
    _max: HarmfulDomainUriMaxAggregateOutputType | null
  }

  type GetHarmfulDomainUriGroupByPayload<T extends HarmfulDomainUriGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HarmfulDomainUriGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HarmfulDomainUriGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HarmfulDomainUriGroupByOutputType[P]>
            : GetScalarType<T[P], HarmfulDomainUriGroupByOutputType[P]>
        }
      >
    >


  export type HarmfulDomainUriSelect = {
    id?: boolean
    code?: boolean
    organizationWebsite?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type HarmfulDomainUriGetPayload<S extends boolean | null | undefined | HarmfulDomainUriArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HarmfulDomainUri :
    S extends undefined ? never :
    S extends { include: any } & (HarmfulDomainUriArgs | HarmfulDomainUriFindManyArgs)
    ? HarmfulDomainUri 
    : S extends { select: any } & (HarmfulDomainUriArgs | HarmfulDomainUriFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HarmfulDomainUri ? HarmfulDomainUri[P] : never
  } 
      : HarmfulDomainUri


  type HarmfulDomainUriCountArgs = 
    Omit<HarmfulDomainUriFindManyArgs, 'select' | 'include'> & {
      select?: HarmfulDomainUriCountAggregateInputType | true
    }

  export interface HarmfulDomainUriDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HarmfulDomainUri that matches the filter.
     * @param {HarmfulDomainUriFindUniqueArgs} args - Arguments to find a HarmfulDomainUri
     * @example
     * // Get one HarmfulDomainUri
     * const harmfulDomainUri = await prisma.harmfulDomainUri.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HarmfulDomainUriFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HarmfulDomainUriFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HarmfulDomainUri'> extends True ? Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T>> : Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T> | null, null>

    /**
     * Find one HarmfulDomainUri that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HarmfulDomainUriFindUniqueOrThrowArgs} args - Arguments to find a HarmfulDomainUri
     * @example
     * // Get one HarmfulDomainUri
     * const harmfulDomainUri = await prisma.harmfulDomainUri.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HarmfulDomainUriFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HarmfulDomainUriFindUniqueOrThrowArgs>
    ): Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T>>

    /**
     * Find the first HarmfulDomainUri that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainUriFindFirstArgs} args - Arguments to find a HarmfulDomainUri
     * @example
     * // Get one HarmfulDomainUri
     * const harmfulDomainUri = await prisma.harmfulDomainUri.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HarmfulDomainUriFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HarmfulDomainUriFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HarmfulDomainUri'> extends True ? Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T>> : Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T> | null, null>

    /**
     * Find the first HarmfulDomainUri that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainUriFindFirstOrThrowArgs} args - Arguments to find a HarmfulDomainUri
     * @example
     * // Get one HarmfulDomainUri
     * const harmfulDomainUri = await prisma.harmfulDomainUri.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HarmfulDomainUriFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HarmfulDomainUriFindFirstOrThrowArgs>
    ): Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T>>

    /**
     * Find zero or more HarmfulDomainUris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainUriFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HarmfulDomainUris
     * const harmfulDomainUris = await prisma.harmfulDomainUri.findMany()
     * 
     * // Get first 10 HarmfulDomainUris
     * const harmfulDomainUris = await prisma.harmfulDomainUri.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const harmfulDomainUriWithIdOnly = await prisma.harmfulDomainUri.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HarmfulDomainUriFindManyArgs>(
      args?: SelectSubset<T, HarmfulDomainUriFindManyArgs>
    ): Prisma.PrismaPromise<Array<HarmfulDomainUriGetPayload<T>>>

    /**
     * Create a HarmfulDomainUri.
     * @param {HarmfulDomainUriCreateArgs} args - Arguments to create a HarmfulDomainUri.
     * @example
     * // Create one HarmfulDomainUri
     * const HarmfulDomainUri = await prisma.harmfulDomainUri.create({
     *   data: {
     *     // ... data to create a HarmfulDomainUri
     *   }
     * })
     * 
    **/
    create<T extends HarmfulDomainUriCreateArgs>(
      args: SelectSubset<T, HarmfulDomainUriCreateArgs>
    ): Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T>>

    /**
     * Create many HarmfulDomainUris.
     *     @param {HarmfulDomainUriCreateManyArgs} args - Arguments to create many HarmfulDomainUris.
     *     @example
     *     // Create many HarmfulDomainUris
     *     const harmfulDomainUri = await prisma.harmfulDomainUri.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HarmfulDomainUriCreateManyArgs>(
      args?: SelectSubset<T, HarmfulDomainUriCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HarmfulDomainUri.
     * @param {HarmfulDomainUriDeleteArgs} args - Arguments to delete one HarmfulDomainUri.
     * @example
     * // Delete one HarmfulDomainUri
     * const HarmfulDomainUri = await prisma.harmfulDomainUri.delete({
     *   where: {
     *     // ... filter to delete one HarmfulDomainUri
     *   }
     * })
     * 
    **/
    delete<T extends HarmfulDomainUriDeleteArgs>(
      args: SelectSubset<T, HarmfulDomainUriDeleteArgs>
    ): Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T>>

    /**
     * Update one HarmfulDomainUri.
     * @param {HarmfulDomainUriUpdateArgs} args - Arguments to update one HarmfulDomainUri.
     * @example
     * // Update one HarmfulDomainUri
     * const harmfulDomainUri = await prisma.harmfulDomainUri.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HarmfulDomainUriUpdateArgs>(
      args: SelectSubset<T, HarmfulDomainUriUpdateArgs>
    ): Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T>>

    /**
     * Delete zero or more HarmfulDomainUris.
     * @param {HarmfulDomainUriDeleteManyArgs} args - Arguments to filter HarmfulDomainUris to delete.
     * @example
     * // Delete a few HarmfulDomainUris
     * const { count } = await prisma.harmfulDomainUri.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HarmfulDomainUriDeleteManyArgs>(
      args?: SelectSubset<T, HarmfulDomainUriDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HarmfulDomainUris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainUriUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HarmfulDomainUris
     * const harmfulDomainUri = await prisma.harmfulDomainUri.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HarmfulDomainUriUpdateManyArgs>(
      args: SelectSubset<T, HarmfulDomainUriUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HarmfulDomainUri.
     * @param {HarmfulDomainUriUpsertArgs} args - Arguments to update or create a HarmfulDomainUri.
     * @example
     * // Update or create a HarmfulDomainUri
     * const harmfulDomainUri = await prisma.harmfulDomainUri.upsert({
     *   create: {
     *     // ... data to create a HarmfulDomainUri
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HarmfulDomainUri we want to update
     *   }
     * })
    **/
    upsert<T extends HarmfulDomainUriUpsertArgs>(
      args: SelectSubset<T, HarmfulDomainUriUpsertArgs>
    ): Prisma__HarmfulDomainUriClient<HarmfulDomainUriGetPayload<T>>

    /**
     * Count the number of HarmfulDomainUris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainUriCountArgs} args - Arguments to filter HarmfulDomainUris to count.
     * @example
     * // Count the number of HarmfulDomainUris
     * const count = await prisma.harmfulDomainUri.count({
     *   where: {
     *     // ... the filter for the HarmfulDomainUris we want to count
     *   }
     * })
    **/
    count<T extends HarmfulDomainUriCountArgs>(
      args?: Subset<T, HarmfulDomainUriCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HarmfulDomainUriCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HarmfulDomainUri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainUriAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HarmfulDomainUriAggregateArgs>(args: Subset<T, HarmfulDomainUriAggregateArgs>): Prisma.PrismaPromise<GetHarmfulDomainUriAggregateType<T>>

    /**
     * Group by HarmfulDomainUri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainUriGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HarmfulDomainUriGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HarmfulDomainUriGroupByArgs['orderBy'] }
        : { orderBy?: HarmfulDomainUriGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HarmfulDomainUriGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHarmfulDomainUriGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HarmfulDomainUri.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HarmfulDomainUriClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HarmfulDomainUri base type for findUnique actions
   */
  export type HarmfulDomainUriFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * Filter, which HarmfulDomainUri to fetch.
     */
    where: HarmfulDomainUriWhereUniqueInput
  }

  /**
   * HarmfulDomainUri findUnique
   */
  export interface HarmfulDomainUriFindUniqueArgs extends HarmfulDomainUriFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HarmfulDomainUri findUniqueOrThrow
   */
  export type HarmfulDomainUriFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * Filter, which HarmfulDomainUri to fetch.
     */
    where: HarmfulDomainUriWhereUniqueInput
  }


  /**
   * HarmfulDomainUri base type for findFirst actions
   */
  export type HarmfulDomainUriFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * Filter, which HarmfulDomainUri to fetch.
     */
    where?: HarmfulDomainUriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomainUris to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainUriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HarmfulDomainUris.
     */
    cursor?: HarmfulDomainUriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomainUris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomainUris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HarmfulDomainUris.
     */
    distinct?: Enumerable<HarmfulDomainUriScalarFieldEnum>
  }

  /**
   * HarmfulDomainUri findFirst
   */
  export interface HarmfulDomainUriFindFirstArgs extends HarmfulDomainUriFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HarmfulDomainUri findFirstOrThrow
   */
  export type HarmfulDomainUriFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * Filter, which HarmfulDomainUri to fetch.
     */
    where?: HarmfulDomainUriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomainUris to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainUriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HarmfulDomainUris.
     */
    cursor?: HarmfulDomainUriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomainUris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomainUris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HarmfulDomainUris.
     */
    distinct?: Enumerable<HarmfulDomainUriScalarFieldEnum>
  }


  /**
   * HarmfulDomainUri findMany
   */
  export type HarmfulDomainUriFindManyArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * Filter, which HarmfulDomainUris to fetch.
     */
    where?: HarmfulDomainUriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomainUris to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainUriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HarmfulDomainUris.
     */
    cursor?: HarmfulDomainUriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomainUris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomainUris.
     */
    skip?: number
    distinct?: Enumerable<HarmfulDomainUriScalarFieldEnum>
  }


  /**
   * HarmfulDomainUri create
   */
  export type HarmfulDomainUriCreateArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * The data needed to create a HarmfulDomainUri.
     */
    data: XOR<HarmfulDomainUriCreateInput, HarmfulDomainUriUncheckedCreateInput>
  }


  /**
   * HarmfulDomainUri createMany
   */
  export type HarmfulDomainUriCreateManyArgs = {
    /**
     * The data used to create many HarmfulDomainUris.
     */
    data: Enumerable<HarmfulDomainUriCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HarmfulDomainUri update
   */
  export type HarmfulDomainUriUpdateArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * The data needed to update a HarmfulDomainUri.
     */
    data: XOR<HarmfulDomainUriUpdateInput, HarmfulDomainUriUncheckedUpdateInput>
    /**
     * Choose, which HarmfulDomainUri to update.
     */
    where: HarmfulDomainUriWhereUniqueInput
  }


  /**
   * HarmfulDomainUri updateMany
   */
  export type HarmfulDomainUriUpdateManyArgs = {
    /**
     * The data used to update HarmfulDomainUris.
     */
    data: XOR<HarmfulDomainUriUpdateManyMutationInput, HarmfulDomainUriUncheckedUpdateManyInput>
    /**
     * Filter which HarmfulDomainUris to update
     */
    where?: HarmfulDomainUriWhereInput
  }


  /**
   * HarmfulDomainUri upsert
   */
  export type HarmfulDomainUriUpsertArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * The filter to search for the HarmfulDomainUri to update in case it exists.
     */
    where: HarmfulDomainUriWhereUniqueInput
    /**
     * In case the HarmfulDomainUri found by the `where` argument doesn't exist, create a new HarmfulDomainUri with this data.
     */
    create: XOR<HarmfulDomainUriCreateInput, HarmfulDomainUriUncheckedCreateInput>
    /**
     * In case the HarmfulDomainUri was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HarmfulDomainUriUpdateInput, HarmfulDomainUriUncheckedUpdateInput>
  }


  /**
   * HarmfulDomainUri delete
   */
  export type HarmfulDomainUriDeleteArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
    /**
     * Filter which HarmfulDomainUri to delete.
     */
    where: HarmfulDomainUriWhereUniqueInput
  }


  /**
   * HarmfulDomainUri deleteMany
   */
  export type HarmfulDomainUriDeleteManyArgs = {
    /**
     * Filter which HarmfulDomainUris to delete
     */
    where?: HarmfulDomainUriWhereInput
  }


  /**
   * HarmfulDomainUri without action
   */
  export type HarmfulDomainUriArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainUri
     */
    select?: HarmfulDomainUriSelect | null
  }



  /**
   * Model HarmfulDomainEmail
   */


  export type AggregateHarmfulDomainEmail = {
    _count: HarmfulDomainEmailCountAggregateOutputType | null
    _min: HarmfulDomainEmailMinAggregateOutputType | null
    _max: HarmfulDomainEmailMaxAggregateOutputType | null
  }

  export type HarmfulDomainEmailMinAggregateOutputType = {
    id: string | null
    code: string | null
    email: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HarmfulDomainEmailMaxAggregateOutputType = {
    id: string | null
    code: string | null
    email: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HarmfulDomainEmailCountAggregateOutputType = {
    id: number
    code: number
    email: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HarmfulDomainEmailMinAggregateInputType = {
    id?: true
    code?: true
    email?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HarmfulDomainEmailMaxAggregateInputType = {
    id?: true
    code?: true
    email?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HarmfulDomainEmailCountAggregateInputType = {
    id?: true
    code?: true
    email?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HarmfulDomainEmailAggregateArgs = {
    /**
     * Filter which HarmfulDomainEmail to aggregate.
     */
    where?: HarmfulDomainEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomainEmails to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HarmfulDomainEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomainEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomainEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HarmfulDomainEmails
    **/
    _count?: true | HarmfulDomainEmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HarmfulDomainEmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HarmfulDomainEmailMaxAggregateInputType
  }

  export type GetHarmfulDomainEmailAggregateType<T extends HarmfulDomainEmailAggregateArgs> = {
        [P in keyof T & keyof AggregateHarmfulDomainEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHarmfulDomainEmail[P]>
      : GetScalarType<T[P], AggregateHarmfulDomainEmail[P]>
  }




  export type HarmfulDomainEmailGroupByArgs = {
    where?: HarmfulDomainEmailWhereInput
    orderBy?: Enumerable<HarmfulDomainEmailOrderByWithAggregationInput>
    by: HarmfulDomainEmailScalarFieldEnum[]
    having?: HarmfulDomainEmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HarmfulDomainEmailCountAggregateInputType | true
    _min?: HarmfulDomainEmailMinAggregateInputType
    _max?: HarmfulDomainEmailMaxAggregateInputType
  }


  export type HarmfulDomainEmailGroupByOutputType = {
    id: string
    code: string
    email: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: HarmfulDomainEmailCountAggregateOutputType | null
    _min: HarmfulDomainEmailMinAggregateOutputType | null
    _max: HarmfulDomainEmailMaxAggregateOutputType | null
  }

  type GetHarmfulDomainEmailGroupByPayload<T extends HarmfulDomainEmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HarmfulDomainEmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HarmfulDomainEmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HarmfulDomainEmailGroupByOutputType[P]>
            : GetScalarType<T[P], HarmfulDomainEmailGroupByOutputType[P]>
        }
      >
    >


  export type HarmfulDomainEmailSelect = {
    id?: boolean
    code?: boolean
    email?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type HarmfulDomainEmailGetPayload<S extends boolean | null | undefined | HarmfulDomainEmailArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? HarmfulDomainEmail :
    S extends undefined ? never :
    S extends { include: any } & (HarmfulDomainEmailArgs | HarmfulDomainEmailFindManyArgs)
    ? HarmfulDomainEmail 
    : S extends { select: any } & (HarmfulDomainEmailArgs | HarmfulDomainEmailFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof HarmfulDomainEmail ? HarmfulDomainEmail[P] : never
  } 
      : HarmfulDomainEmail


  type HarmfulDomainEmailCountArgs = 
    Omit<HarmfulDomainEmailFindManyArgs, 'select' | 'include'> & {
      select?: HarmfulDomainEmailCountAggregateInputType | true
    }

  export interface HarmfulDomainEmailDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one HarmfulDomainEmail that matches the filter.
     * @param {HarmfulDomainEmailFindUniqueArgs} args - Arguments to find a HarmfulDomainEmail
     * @example
     * // Get one HarmfulDomainEmail
     * const harmfulDomainEmail = await prisma.harmfulDomainEmail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HarmfulDomainEmailFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HarmfulDomainEmailFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'HarmfulDomainEmail'> extends True ? Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T>> : Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T> | null, null>

    /**
     * Find one HarmfulDomainEmail that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HarmfulDomainEmailFindUniqueOrThrowArgs} args - Arguments to find a HarmfulDomainEmail
     * @example
     * // Get one HarmfulDomainEmail
     * const harmfulDomainEmail = await prisma.harmfulDomainEmail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HarmfulDomainEmailFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HarmfulDomainEmailFindUniqueOrThrowArgs>
    ): Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T>>

    /**
     * Find the first HarmfulDomainEmail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainEmailFindFirstArgs} args - Arguments to find a HarmfulDomainEmail
     * @example
     * // Get one HarmfulDomainEmail
     * const harmfulDomainEmail = await prisma.harmfulDomainEmail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HarmfulDomainEmailFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HarmfulDomainEmailFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'HarmfulDomainEmail'> extends True ? Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T>> : Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T> | null, null>

    /**
     * Find the first HarmfulDomainEmail that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainEmailFindFirstOrThrowArgs} args - Arguments to find a HarmfulDomainEmail
     * @example
     * // Get one HarmfulDomainEmail
     * const harmfulDomainEmail = await prisma.harmfulDomainEmail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HarmfulDomainEmailFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HarmfulDomainEmailFindFirstOrThrowArgs>
    ): Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T>>

    /**
     * Find zero or more HarmfulDomainEmails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainEmailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HarmfulDomainEmails
     * const harmfulDomainEmails = await prisma.harmfulDomainEmail.findMany()
     * 
     * // Get first 10 HarmfulDomainEmails
     * const harmfulDomainEmails = await prisma.harmfulDomainEmail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const harmfulDomainEmailWithIdOnly = await prisma.harmfulDomainEmail.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HarmfulDomainEmailFindManyArgs>(
      args?: SelectSubset<T, HarmfulDomainEmailFindManyArgs>
    ): Prisma.PrismaPromise<Array<HarmfulDomainEmailGetPayload<T>>>

    /**
     * Create a HarmfulDomainEmail.
     * @param {HarmfulDomainEmailCreateArgs} args - Arguments to create a HarmfulDomainEmail.
     * @example
     * // Create one HarmfulDomainEmail
     * const HarmfulDomainEmail = await prisma.harmfulDomainEmail.create({
     *   data: {
     *     // ... data to create a HarmfulDomainEmail
     *   }
     * })
     * 
    **/
    create<T extends HarmfulDomainEmailCreateArgs>(
      args: SelectSubset<T, HarmfulDomainEmailCreateArgs>
    ): Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T>>

    /**
     * Create many HarmfulDomainEmails.
     *     @param {HarmfulDomainEmailCreateManyArgs} args - Arguments to create many HarmfulDomainEmails.
     *     @example
     *     // Create many HarmfulDomainEmails
     *     const harmfulDomainEmail = await prisma.harmfulDomainEmail.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HarmfulDomainEmailCreateManyArgs>(
      args?: SelectSubset<T, HarmfulDomainEmailCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HarmfulDomainEmail.
     * @param {HarmfulDomainEmailDeleteArgs} args - Arguments to delete one HarmfulDomainEmail.
     * @example
     * // Delete one HarmfulDomainEmail
     * const HarmfulDomainEmail = await prisma.harmfulDomainEmail.delete({
     *   where: {
     *     // ... filter to delete one HarmfulDomainEmail
     *   }
     * })
     * 
    **/
    delete<T extends HarmfulDomainEmailDeleteArgs>(
      args: SelectSubset<T, HarmfulDomainEmailDeleteArgs>
    ): Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T>>

    /**
     * Update one HarmfulDomainEmail.
     * @param {HarmfulDomainEmailUpdateArgs} args - Arguments to update one HarmfulDomainEmail.
     * @example
     * // Update one HarmfulDomainEmail
     * const harmfulDomainEmail = await prisma.harmfulDomainEmail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HarmfulDomainEmailUpdateArgs>(
      args: SelectSubset<T, HarmfulDomainEmailUpdateArgs>
    ): Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T>>

    /**
     * Delete zero or more HarmfulDomainEmails.
     * @param {HarmfulDomainEmailDeleteManyArgs} args - Arguments to filter HarmfulDomainEmails to delete.
     * @example
     * // Delete a few HarmfulDomainEmails
     * const { count } = await prisma.harmfulDomainEmail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HarmfulDomainEmailDeleteManyArgs>(
      args?: SelectSubset<T, HarmfulDomainEmailDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HarmfulDomainEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainEmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HarmfulDomainEmails
     * const harmfulDomainEmail = await prisma.harmfulDomainEmail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HarmfulDomainEmailUpdateManyArgs>(
      args: SelectSubset<T, HarmfulDomainEmailUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HarmfulDomainEmail.
     * @param {HarmfulDomainEmailUpsertArgs} args - Arguments to update or create a HarmfulDomainEmail.
     * @example
     * // Update or create a HarmfulDomainEmail
     * const harmfulDomainEmail = await prisma.harmfulDomainEmail.upsert({
     *   create: {
     *     // ... data to create a HarmfulDomainEmail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HarmfulDomainEmail we want to update
     *   }
     * })
    **/
    upsert<T extends HarmfulDomainEmailUpsertArgs>(
      args: SelectSubset<T, HarmfulDomainEmailUpsertArgs>
    ): Prisma__HarmfulDomainEmailClient<HarmfulDomainEmailGetPayload<T>>

    /**
     * Count the number of HarmfulDomainEmails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainEmailCountArgs} args - Arguments to filter HarmfulDomainEmails to count.
     * @example
     * // Count the number of HarmfulDomainEmails
     * const count = await prisma.harmfulDomainEmail.count({
     *   where: {
     *     // ... the filter for the HarmfulDomainEmails we want to count
     *   }
     * })
    **/
    count<T extends HarmfulDomainEmailCountArgs>(
      args?: Subset<T, HarmfulDomainEmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HarmfulDomainEmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HarmfulDomainEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainEmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HarmfulDomainEmailAggregateArgs>(args: Subset<T, HarmfulDomainEmailAggregateArgs>): Prisma.PrismaPromise<GetHarmfulDomainEmailAggregateType<T>>

    /**
     * Group by HarmfulDomainEmail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HarmfulDomainEmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HarmfulDomainEmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HarmfulDomainEmailGroupByArgs['orderBy'] }
        : { orderBy?: HarmfulDomainEmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HarmfulDomainEmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHarmfulDomainEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for HarmfulDomainEmail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HarmfulDomainEmailClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * HarmfulDomainEmail base type for findUnique actions
   */
  export type HarmfulDomainEmailFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * Filter, which HarmfulDomainEmail to fetch.
     */
    where: HarmfulDomainEmailWhereUniqueInput
  }

  /**
   * HarmfulDomainEmail findUnique
   */
  export interface HarmfulDomainEmailFindUniqueArgs extends HarmfulDomainEmailFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HarmfulDomainEmail findUniqueOrThrow
   */
  export type HarmfulDomainEmailFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * Filter, which HarmfulDomainEmail to fetch.
     */
    where: HarmfulDomainEmailWhereUniqueInput
  }


  /**
   * HarmfulDomainEmail base type for findFirst actions
   */
  export type HarmfulDomainEmailFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * Filter, which HarmfulDomainEmail to fetch.
     */
    where?: HarmfulDomainEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomainEmails to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HarmfulDomainEmails.
     */
    cursor?: HarmfulDomainEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomainEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomainEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HarmfulDomainEmails.
     */
    distinct?: Enumerable<HarmfulDomainEmailScalarFieldEnum>
  }

  /**
   * HarmfulDomainEmail findFirst
   */
  export interface HarmfulDomainEmailFindFirstArgs extends HarmfulDomainEmailFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * HarmfulDomainEmail findFirstOrThrow
   */
  export type HarmfulDomainEmailFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * Filter, which HarmfulDomainEmail to fetch.
     */
    where?: HarmfulDomainEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomainEmails to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HarmfulDomainEmails.
     */
    cursor?: HarmfulDomainEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomainEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomainEmails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HarmfulDomainEmails.
     */
    distinct?: Enumerable<HarmfulDomainEmailScalarFieldEnum>
  }


  /**
   * HarmfulDomainEmail findMany
   */
  export type HarmfulDomainEmailFindManyArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * Filter, which HarmfulDomainEmails to fetch.
     */
    where?: HarmfulDomainEmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HarmfulDomainEmails to fetch.
     */
    orderBy?: Enumerable<HarmfulDomainEmailOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HarmfulDomainEmails.
     */
    cursor?: HarmfulDomainEmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HarmfulDomainEmails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HarmfulDomainEmails.
     */
    skip?: number
    distinct?: Enumerable<HarmfulDomainEmailScalarFieldEnum>
  }


  /**
   * HarmfulDomainEmail create
   */
  export type HarmfulDomainEmailCreateArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * The data needed to create a HarmfulDomainEmail.
     */
    data: XOR<HarmfulDomainEmailCreateInput, HarmfulDomainEmailUncheckedCreateInput>
  }


  /**
   * HarmfulDomainEmail createMany
   */
  export type HarmfulDomainEmailCreateManyArgs = {
    /**
     * The data used to create many HarmfulDomainEmails.
     */
    data: Enumerable<HarmfulDomainEmailCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * HarmfulDomainEmail update
   */
  export type HarmfulDomainEmailUpdateArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * The data needed to update a HarmfulDomainEmail.
     */
    data: XOR<HarmfulDomainEmailUpdateInput, HarmfulDomainEmailUncheckedUpdateInput>
    /**
     * Choose, which HarmfulDomainEmail to update.
     */
    where: HarmfulDomainEmailWhereUniqueInput
  }


  /**
   * HarmfulDomainEmail updateMany
   */
  export type HarmfulDomainEmailUpdateManyArgs = {
    /**
     * The data used to update HarmfulDomainEmails.
     */
    data: XOR<HarmfulDomainEmailUpdateManyMutationInput, HarmfulDomainEmailUncheckedUpdateManyInput>
    /**
     * Filter which HarmfulDomainEmails to update
     */
    where?: HarmfulDomainEmailWhereInput
  }


  /**
   * HarmfulDomainEmail upsert
   */
  export type HarmfulDomainEmailUpsertArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * The filter to search for the HarmfulDomainEmail to update in case it exists.
     */
    where: HarmfulDomainEmailWhereUniqueInput
    /**
     * In case the HarmfulDomainEmail found by the `where` argument doesn't exist, create a new HarmfulDomainEmail with this data.
     */
    create: XOR<HarmfulDomainEmailCreateInput, HarmfulDomainEmailUncheckedCreateInput>
    /**
     * In case the HarmfulDomainEmail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HarmfulDomainEmailUpdateInput, HarmfulDomainEmailUncheckedUpdateInput>
  }


  /**
   * HarmfulDomainEmail delete
   */
  export type HarmfulDomainEmailDeleteArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
    /**
     * Filter which HarmfulDomainEmail to delete.
     */
    where: HarmfulDomainEmailWhereUniqueInput
  }


  /**
   * HarmfulDomainEmail deleteMany
   */
  export type HarmfulDomainEmailDeleteManyArgs = {
    /**
     * Filter which HarmfulDomainEmails to delete
     */
    where?: HarmfulDomainEmailWhereInput
  }


  /**
   * HarmfulDomainEmail without action
   */
  export type HarmfulDomainEmailArgs = {
    /**
     * Select specific fields to fetch from the HarmfulDomainEmail
     */
    select?: HarmfulDomainEmailSelect | null
  }



  /**
   * Model Vulnerability
   */


  export type AggregateVulnerability = {
    _count: VulnerabilityCountAggregateOutputType | null
    _min: VulnerabilityMinAggregateOutputType | null
    _max: VulnerabilityMaxAggregateOutputType | null
  }

  export type VulnerabilityMinAggregateOutputType = {
    id: string | null
    code: string | null
    cellPhone: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VulnerabilityMaxAggregateOutputType = {
    id: string | null
    code: string | null
    cellPhone: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VulnerabilityCountAggregateOutputType = {
    id: number
    code: number
    cellPhone: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VulnerabilityMinAggregateInputType = {
    id?: true
    code?: true
    cellPhone?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VulnerabilityMaxAggregateInputType = {
    id?: true
    code?: true
    cellPhone?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VulnerabilityCountAggregateInputType = {
    id?: true
    code?: true
    cellPhone?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VulnerabilityAggregateArgs = {
    /**
     * Filter which Vulnerability to aggregate.
     */
    where?: VulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vulnerabilities to fetch.
     */
    orderBy?: Enumerable<VulnerabilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vulnerabilities
    **/
    _count?: true | VulnerabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VulnerabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VulnerabilityMaxAggregateInputType
  }

  export type GetVulnerabilityAggregateType<T extends VulnerabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateVulnerability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVulnerability[P]>
      : GetScalarType<T[P], AggregateVulnerability[P]>
  }




  export type VulnerabilityGroupByArgs = {
    where?: VulnerabilityWhereInput
    orderBy?: Enumerable<VulnerabilityOrderByWithAggregationInput>
    by: VulnerabilityScalarFieldEnum[]
    having?: VulnerabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VulnerabilityCountAggregateInputType | true
    _min?: VulnerabilityMinAggregateInputType
    _max?: VulnerabilityMaxAggregateInputType
  }


  export type VulnerabilityGroupByOutputType = {
    id: string
    code: string
    cellPhone: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: VulnerabilityCountAggregateOutputType | null
    _min: VulnerabilityMinAggregateOutputType | null
    _max: VulnerabilityMaxAggregateOutputType | null
  }

  type GetVulnerabilityGroupByPayload<T extends VulnerabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<VulnerabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VulnerabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VulnerabilityGroupByOutputType[P]>
            : GetScalarType<T[P], VulnerabilityGroupByOutputType[P]>
        }
      >
    >


  export type VulnerabilitySelect = {
    id?: boolean
    code?: boolean
    cellPhone?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type VulnerabilityGetPayload<S extends boolean | null | undefined | VulnerabilityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Vulnerability :
    S extends undefined ? never :
    S extends { include: any } & (VulnerabilityArgs | VulnerabilityFindManyArgs)
    ? Vulnerability 
    : S extends { select: any } & (VulnerabilityArgs | VulnerabilityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Vulnerability ? Vulnerability[P] : never
  } 
      : Vulnerability


  type VulnerabilityCountArgs = 
    Omit<VulnerabilityFindManyArgs, 'select' | 'include'> & {
      select?: VulnerabilityCountAggregateInputType | true
    }

  export interface VulnerabilityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Vulnerability that matches the filter.
     * @param {VulnerabilityFindUniqueArgs} args - Arguments to find a Vulnerability
     * @example
     * // Get one Vulnerability
     * const vulnerability = await prisma.vulnerability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VulnerabilityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VulnerabilityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vulnerability'> extends True ? Prisma__VulnerabilityClient<VulnerabilityGetPayload<T>> : Prisma__VulnerabilityClient<VulnerabilityGetPayload<T> | null, null>

    /**
     * Find one Vulnerability that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VulnerabilityFindUniqueOrThrowArgs} args - Arguments to find a Vulnerability
     * @example
     * // Get one Vulnerability
     * const vulnerability = await prisma.vulnerability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VulnerabilityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, VulnerabilityFindUniqueOrThrowArgs>
    ): Prisma__VulnerabilityClient<VulnerabilityGetPayload<T>>

    /**
     * Find the first Vulnerability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VulnerabilityFindFirstArgs} args - Arguments to find a Vulnerability
     * @example
     * // Get one Vulnerability
     * const vulnerability = await prisma.vulnerability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VulnerabilityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VulnerabilityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vulnerability'> extends True ? Prisma__VulnerabilityClient<VulnerabilityGetPayload<T>> : Prisma__VulnerabilityClient<VulnerabilityGetPayload<T> | null, null>

    /**
     * Find the first Vulnerability that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VulnerabilityFindFirstOrThrowArgs} args - Arguments to find a Vulnerability
     * @example
     * // Get one Vulnerability
     * const vulnerability = await prisma.vulnerability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VulnerabilityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VulnerabilityFindFirstOrThrowArgs>
    ): Prisma__VulnerabilityClient<VulnerabilityGetPayload<T>>

    /**
     * Find zero or more Vulnerabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VulnerabilityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vulnerabilities
     * const vulnerabilities = await prisma.vulnerability.findMany()
     * 
     * // Get first 10 Vulnerabilities
     * const vulnerabilities = await prisma.vulnerability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vulnerabilityWithIdOnly = await prisma.vulnerability.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VulnerabilityFindManyArgs>(
      args?: SelectSubset<T, VulnerabilityFindManyArgs>
    ): Prisma.PrismaPromise<Array<VulnerabilityGetPayload<T>>>

    /**
     * Create a Vulnerability.
     * @param {VulnerabilityCreateArgs} args - Arguments to create a Vulnerability.
     * @example
     * // Create one Vulnerability
     * const Vulnerability = await prisma.vulnerability.create({
     *   data: {
     *     // ... data to create a Vulnerability
     *   }
     * })
     * 
    **/
    create<T extends VulnerabilityCreateArgs>(
      args: SelectSubset<T, VulnerabilityCreateArgs>
    ): Prisma__VulnerabilityClient<VulnerabilityGetPayload<T>>

    /**
     * Create many Vulnerabilities.
     *     @param {VulnerabilityCreateManyArgs} args - Arguments to create many Vulnerabilities.
     *     @example
     *     // Create many Vulnerabilities
     *     const vulnerability = await prisma.vulnerability.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VulnerabilityCreateManyArgs>(
      args?: SelectSubset<T, VulnerabilityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vulnerability.
     * @param {VulnerabilityDeleteArgs} args - Arguments to delete one Vulnerability.
     * @example
     * // Delete one Vulnerability
     * const Vulnerability = await prisma.vulnerability.delete({
     *   where: {
     *     // ... filter to delete one Vulnerability
     *   }
     * })
     * 
    **/
    delete<T extends VulnerabilityDeleteArgs>(
      args: SelectSubset<T, VulnerabilityDeleteArgs>
    ): Prisma__VulnerabilityClient<VulnerabilityGetPayload<T>>

    /**
     * Update one Vulnerability.
     * @param {VulnerabilityUpdateArgs} args - Arguments to update one Vulnerability.
     * @example
     * // Update one Vulnerability
     * const vulnerability = await prisma.vulnerability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VulnerabilityUpdateArgs>(
      args: SelectSubset<T, VulnerabilityUpdateArgs>
    ): Prisma__VulnerabilityClient<VulnerabilityGetPayload<T>>

    /**
     * Delete zero or more Vulnerabilities.
     * @param {VulnerabilityDeleteManyArgs} args - Arguments to filter Vulnerabilities to delete.
     * @example
     * // Delete a few Vulnerabilities
     * const { count } = await prisma.vulnerability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VulnerabilityDeleteManyArgs>(
      args?: SelectSubset<T, VulnerabilityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vulnerabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VulnerabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vulnerabilities
     * const vulnerability = await prisma.vulnerability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VulnerabilityUpdateManyArgs>(
      args: SelectSubset<T, VulnerabilityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vulnerability.
     * @param {VulnerabilityUpsertArgs} args - Arguments to update or create a Vulnerability.
     * @example
     * // Update or create a Vulnerability
     * const vulnerability = await prisma.vulnerability.upsert({
     *   create: {
     *     // ... data to create a Vulnerability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vulnerability we want to update
     *   }
     * })
    **/
    upsert<T extends VulnerabilityUpsertArgs>(
      args: SelectSubset<T, VulnerabilityUpsertArgs>
    ): Prisma__VulnerabilityClient<VulnerabilityGetPayload<T>>

    /**
     * Count the number of Vulnerabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VulnerabilityCountArgs} args - Arguments to filter Vulnerabilities to count.
     * @example
     * // Count the number of Vulnerabilities
     * const count = await prisma.vulnerability.count({
     *   where: {
     *     // ... the filter for the Vulnerabilities we want to count
     *   }
     * })
    **/
    count<T extends VulnerabilityCountArgs>(
      args?: Subset<T, VulnerabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VulnerabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vulnerability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VulnerabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VulnerabilityAggregateArgs>(args: Subset<T, VulnerabilityAggregateArgs>): Prisma.PrismaPromise<GetVulnerabilityAggregateType<T>>

    /**
     * Group by Vulnerability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VulnerabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VulnerabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VulnerabilityGroupByArgs['orderBy'] }
        : { orderBy?: VulnerabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VulnerabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVulnerabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Vulnerability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VulnerabilityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Vulnerability base type for findUnique actions
   */
  export type VulnerabilityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * Filter, which Vulnerability to fetch.
     */
    where: VulnerabilityWhereUniqueInput
  }

  /**
   * Vulnerability findUnique
   */
  export interface VulnerabilityFindUniqueArgs extends VulnerabilityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vulnerability findUniqueOrThrow
   */
  export type VulnerabilityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * Filter, which Vulnerability to fetch.
     */
    where: VulnerabilityWhereUniqueInput
  }


  /**
   * Vulnerability base type for findFirst actions
   */
  export type VulnerabilityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * Filter, which Vulnerability to fetch.
     */
    where?: VulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vulnerabilities to fetch.
     */
    orderBy?: Enumerable<VulnerabilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vulnerabilities.
     */
    cursor?: VulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vulnerabilities.
     */
    distinct?: Enumerable<VulnerabilityScalarFieldEnum>
  }

  /**
   * Vulnerability findFirst
   */
  export interface VulnerabilityFindFirstArgs extends VulnerabilityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Vulnerability findFirstOrThrow
   */
  export type VulnerabilityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * Filter, which Vulnerability to fetch.
     */
    where?: VulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vulnerabilities to fetch.
     */
    orderBy?: Enumerable<VulnerabilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vulnerabilities.
     */
    cursor?: VulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vulnerabilities.
     */
    distinct?: Enumerable<VulnerabilityScalarFieldEnum>
  }


  /**
   * Vulnerability findMany
   */
  export type VulnerabilityFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * Filter, which Vulnerabilities to fetch.
     */
    where?: VulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vulnerabilities to fetch.
     */
    orderBy?: Enumerable<VulnerabilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vulnerabilities.
     */
    cursor?: VulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vulnerabilities.
     */
    skip?: number
    distinct?: Enumerable<VulnerabilityScalarFieldEnum>
  }


  /**
   * Vulnerability create
   */
  export type VulnerabilityCreateArgs = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * The data needed to create a Vulnerability.
     */
    data: XOR<VulnerabilityCreateInput, VulnerabilityUncheckedCreateInput>
  }


  /**
   * Vulnerability createMany
   */
  export type VulnerabilityCreateManyArgs = {
    /**
     * The data used to create many Vulnerabilities.
     */
    data: Enumerable<VulnerabilityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vulnerability update
   */
  export type VulnerabilityUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * The data needed to update a Vulnerability.
     */
    data: XOR<VulnerabilityUpdateInput, VulnerabilityUncheckedUpdateInput>
    /**
     * Choose, which Vulnerability to update.
     */
    where: VulnerabilityWhereUniqueInput
  }


  /**
   * Vulnerability updateMany
   */
  export type VulnerabilityUpdateManyArgs = {
    /**
     * The data used to update Vulnerabilities.
     */
    data: XOR<VulnerabilityUpdateManyMutationInput, VulnerabilityUncheckedUpdateManyInput>
    /**
     * Filter which Vulnerabilities to update
     */
    where?: VulnerabilityWhereInput
  }


  /**
   * Vulnerability upsert
   */
  export type VulnerabilityUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * The filter to search for the Vulnerability to update in case it exists.
     */
    where: VulnerabilityWhereUniqueInput
    /**
     * In case the Vulnerability found by the `where` argument doesn't exist, create a new Vulnerability with this data.
     */
    create: XOR<VulnerabilityCreateInput, VulnerabilityUncheckedCreateInput>
    /**
     * In case the Vulnerability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VulnerabilityUpdateInput, VulnerabilityUncheckedUpdateInput>
  }


  /**
   * Vulnerability delete
   */
  export type VulnerabilityDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
    /**
     * Filter which Vulnerability to delete.
     */
    where: VulnerabilityWhereUniqueInput
  }


  /**
   * Vulnerability deleteMany
   */
  export type VulnerabilityDeleteManyArgs = {
    /**
     * Filter which Vulnerabilities to delete
     */
    where?: VulnerabilityWhereInput
  }


  /**
   * Vulnerability without action
   */
  export type VulnerabilityArgs = {
    /**
     * Select specific fields to fetch from the Vulnerability
     */
    select?: VulnerabilitySelect | null
  }



  /**
   * Model AsDetected
   */


  export type AggregateAsDetected = {
    _count: AsDetectedCountAggregateOutputType | null
    _min: AsDetectedMinAggregateOutputType | null
    _max: AsDetectedMaxAggregateOutputType | null
  }

  export type AsDetectedMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AsDetectedMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AsDetectedCountAggregateOutputType = {
    id: number
    name: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AsDetectedMinAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AsDetectedMaxAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AsDetectedCountAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AsDetectedAggregateArgs = {
    /**
     * Filter which AsDetected to aggregate.
     */
    where?: AsDetectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsDetecteds to fetch.
     */
    orderBy?: Enumerable<AsDetectedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AsDetectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsDetecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsDetecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AsDetecteds
    **/
    _count?: true | AsDetectedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AsDetectedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AsDetectedMaxAggregateInputType
  }

  export type GetAsDetectedAggregateType<T extends AsDetectedAggregateArgs> = {
        [P in keyof T & keyof AggregateAsDetected]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsDetected[P]>
      : GetScalarType<T[P], AggregateAsDetected[P]>
  }




  export type AsDetectedGroupByArgs = {
    where?: AsDetectedWhereInput
    orderBy?: Enumerable<AsDetectedOrderByWithAggregationInput>
    by: AsDetectedScalarFieldEnum[]
    having?: AsDetectedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AsDetectedCountAggregateInputType | true
    _min?: AsDetectedMinAggregateInputType
    _max?: AsDetectedMaxAggregateInputType
  }


  export type AsDetectedGroupByOutputType = {
    id: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: AsDetectedCountAggregateOutputType | null
    _min: AsDetectedMinAggregateOutputType | null
    _max: AsDetectedMaxAggregateOutputType | null
  }

  type GetAsDetectedGroupByPayload<T extends AsDetectedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AsDetectedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AsDetectedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AsDetectedGroupByOutputType[P]>
            : GetScalarType<T[P], AsDetectedGroupByOutputType[P]>
        }
      >
    >


  export type AsDetectedSelect = {
    id?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type AsDetectedGetPayload<S extends boolean | null | undefined | AsDetectedArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? AsDetected :
    S extends undefined ? never :
    S extends { include: any } & (AsDetectedArgs | AsDetectedFindManyArgs)
    ? AsDetected 
    : S extends { select: any } & (AsDetectedArgs | AsDetectedFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof AsDetected ? AsDetected[P] : never
  } 
      : AsDetected


  type AsDetectedCountArgs = 
    Omit<AsDetectedFindManyArgs, 'select' | 'include'> & {
      select?: AsDetectedCountAggregateInputType | true
    }

  export interface AsDetectedDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one AsDetected that matches the filter.
     * @param {AsDetectedFindUniqueArgs} args - Arguments to find a AsDetected
     * @example
     * // Get one AsDetected
     * const asDetected = await prisma.asDetected.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AsDetectedFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AsDetectedFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AsDetected'> extends True ? Prisma__AsDetectedClient<AsDetectedGetPayload<T>> : Prisma__AsDetectedClient<AsDetectedGetPayload<T> | null, null>

    /**
     * Find one AsDetected that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AsDetectedFindUniqueOrThrowArgs} args - Arguments to find a AsDetected
     * @example
     * // Get one AsDetected
     * const asDetected = await prisma.asDetected.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AsDetectedFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, AsDetectedFindUniqueOrThrowArgs>
    ): Prisma__AsDetectedClient<AsDetectedGetPayload<T>>

    /**
     * Find the first AsDetected that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsDetectedFindFirstArgs} args - Arguments to find a AsDetected
     * @example
     * // Get one AsDetected
     * const asDetected = await prisma.asDetected.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AsDetectedFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AsDetectedFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AsDetected'> extends True ? Prisma__AsDetectedClient<AsDetectedGetPayload<T>> : Prisma__AsDetectedClient<AsDetectedGetPayload<T> | null, null>

    /**
     * Find the first AsDetected that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsDetectedFindFirstOrThrowArgs} args - Arguments to find a AsDetected
     * @example
     * // Get one AsDetected
     * const asDetected = await prisma.asDetected.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AsDetectedFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AsDetectedFindFirstOrThrowArgs>
    ): Prisma__AsDetectedClient<AsDetectedGetPayload<T>>

    /**
     * Find zero or more AsDetecteds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsDetectedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AsDetecteds
     * const asDetecteds = await prisma.asDetected.findMany()
     * 
     * // Get first 10 AsDetecteds
     * const asDetecteds = await prisma.asDetected.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const asDetectedWithIdOnly = await prisma.asDetected.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AsDetectedFindManyArgs>(
      args?: SelectSubset<T, AsDetectedFindManyArgs>
    ): Prisma.PrismaPromise<Array<AsDetectedGetPayload<T>>>

    /**
     * Create a AsDetected.
     * @param {AsDetectedCreateArgs} args - Arguments to create a AsDetected.
     * @example
     * // Create one AsDetected
     * const AsDetected = await prisma.asDetected.create({
     *   data: {
     *     // ... data to create a AsDetected
     *   }
     * })
     * 
    **/
    create<T extends AsDetectedCreateArgs>(
      args: SelectSubset<T, AsDetectedCreateArgs>
    ): Prisma__AsDetectedClient<AsDetectedGetPayload<T>>

    /**
     * Create many AsDetecteds.
     *     @param {AsDetectedCreateManyArgs} args - Arguments to create many AsDetecteds.
     *     @example
     *     // Create many AsDetecteds
     *     const asDetected = await prisma.asDetected.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AsDetectedCreateManyArgs>(
      args?: SelectSubset<T, AsDetectedCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AsDetected.
     * @param {AsDetectedDeleteArgs} args - Arguments to delete one AsDetected.
     * @example
     * // Delete one AsDetected
     * const AsDetected = await prisma.asDetected.delete({
     *   where: {
     *     // ... filter to delete one AsDetected
     *   }
     * })
     * 
    **/
    delete<T extends AsDetectedDeleteArgs>(
      args: SelectSubset<T, AsDetectedDeleteArgs>
    ): Prisma__AsDetectedClient<AsDetectedGetPayload<T>>

    /**
     * Update one AsDetected.
     * @param {AsDetectedUpdateArgs} args - Arguments to update one AsDetected.
     * @example
     * // Update one AsDetected
     * const asDetected = await prisma.asDetected.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AsDetectedUpdateArgs>(
      args: SelectSubset<T, AsDetectedUpdateArgs>
    ): Prisma__AsDetectedClient<AsDetectedGetPayload<T>>

    /**
     * Delete zero or more AsDetecteds.
     * @param {AsDetectedDeleteManyArgs} args - Arguments to filter AsDetecteds to delete.
     * @example
     * // Delete a few AsDetecteds
     * const { count } = await prisma.asDetected.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AsDetectedDeleteManyArgs>(
      args?: SelectSubset<T, AsDetectedDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AsDetecteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsDetectedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AsDetecteds
     * const asDetected = await prisma.asDetected.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AsDetectedUpdateManyArgs>(
      args: SelectSubset<T, AsDetectedUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AsDetected.
     * @param {AsDetectedUpsertArgs} args - Arguments to update or create a AsDetected.
     * @example
     * // Update or create a AsDetected
     * const asDetected = await prisma.asDetected.upsert({
     *   create: {
     *     // ... data to create a AsDetected
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AsDetected we want to update
     *   }
     * })
    **/
    upsert<T extends AsDetectedUpsertArgs>(
      args: SelectSubset<T, AsDetectedUpsertArgs>
    ): Prisma__AsDetectedClient<AsDetectedGetPayload<T>>

    /**
     * Count the number of AsDetecteds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsDetectedCountArgs} args - Arguments to filter AsDetecteds to count.
     * @example
     * // Count the number of AsDetecteds
     * const count = await prisma.asDetected.count({
     *   where: {
     *     // ... the filter for the AsDetecteds we want to count
     *   }
     * })
    **/
    count<T extends AsDetectedCountArgs>(
      args?: Subset<T, AsDetectedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AsDetectedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AsDetected.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsDetectedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AsDetectedAggregateArgs>(args: Subset<T, AsDetectedAggregateArgs>): Prisma.PrismaPromise<GetAsDetectedAggregateType<T>>

    /**
     * Group by AsDetected.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AsDetectedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AsDetectedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AsDetectedGroupByArgs['orderBy'] }
        : { orderBy?: AsDetectedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AsDetectedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAsDetectedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AsDetected.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AsDetectedClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AsDetected base type for findUnique actions
   */
  export type AsDetectedFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * Filter, which AsDetected to fetch.
     */
    where: AsDetectedWhereUniqueInput
  }

  /**
   * AsDetected findUnique
   */
  export interface AsDetectedFindUniqueArgs extends AsDetectedFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AsDetected findUniqueOrThrow
   */
  export type AsDetectedFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * Filter, which AsDetected to fetch.
     */
    where: AsDetectedWhereUniqueInput
  }


  /**
   * AsDetected base type for findFirst actions
   */
  export type AsDetectedFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * Filter, which AsDetected to fetch.
     */
    where?: AsDetectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsDetecteds to fetch.
     */
    orderBy?: Enumerable<AsDetectedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AsDetecteds.
     */
    cursor?: AsDetectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsDetecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsDetecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AsDetecteds.
     */
    distinct?: Enumerable<AsDetectedScalarFieldEnum>
  }

  /**
   * AsDetected findFirst
   */
  export interface AsDetectedFindFirstArgs extends AsDetectedFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AsDetected findFirstOrThrow
   */
  export type AsDetectedFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * Filter, which AsDetected to fetch.
     */
    where?: AsDetectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsDetecteds to fetch.
     */
    orderBy?: Enumerable<AsDetectedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AsDetecteds.
     */
    cursor?: AsDetectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsDetecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsDetecteds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AsDetecteds.
     */
    distinct?: Enumerable<AsDetectedScalarFieldEnum>
  }


  /**
   * AsDetected findMany
   */
  export type AsDetectedFindManyArgs = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * Filter, which AsDetecteds to fetch.
     */
    where?: AsDetectedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AsDetecteds to fetch.
     */
    orderBy?: Enumerable<AsDetectedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AsDetecteds.
     */
    cursor?: AsDetectedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AsDetecteds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AsDetecteds.
     */
    skip?: number
    distinct?: Enumerable<AsDetectedScalarFieldEnum>
  }


  /**
   * AsDetected create
   */
  export type AsDetectedCreateArgs = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * The data needed to create a AsDetected.
     */
    data: XOR<AsDetectedCreateInput, AsDetectedUncheckedCreateInput>
  }


  /**
   * AsDetected createMany
   */
  export type AsDetectedCreateManyArgs = {
    /**
     * The data used to create many AsDetecteds.
     */
    data: Enumerable<AsDetectedCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AsDetected update
   */
  export type AsDetectedUpdateArgs = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * The data needed to update a AsDetected.
     */
    data: XOR<AsDetectedUpdateInput, AsDetectedUncheckedUpdateInput>
    /**
     * Choose, which AsDetected to update.
     */
    where: AsDetectedWhereUniqueInput
  }


  /**
   * AsDetected updateMany
   */
  export type AsDetectedUpdateManyArgs = {
    /**
     * The data used to update AsDetecteds.
     */
    data: XOR<AsDetectedUpdateManyMutationInput, AsDetectedUncheckedUpdateManyInput>
    /**
     * Filter which AsDetecteds to update
     */
    where?: AsDetectedWhereInput
  }


  /**
   * AsDetected upsert
   */
  export type AsDetectedUpsertArgs = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * The filter to search for the AsDetected to update in case it exists.
     */
    where: AsDetectedWhereUniqueInput
    /**
     * In case the AsDetected found by the `where` argument doesn't exist, create a new AsDetected with this data.
     */
    create: XOR<AsDetectedCreateInput, AsDetectedUncheckedCreateInput>
    /**
     * In case the AsDetected was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AsDetectedUpdateInput, AsDetectedUncheckedUpdateInput>
  }


  /**
   * AsDetected delete
   */
  export type AsDetectedDeleteArgs = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
    /**
     * Filter which AsDetected to delete.
     */
    where: AsDetectedWhereUniqueInput
  }


  /**
   * AsDetected deleteMany
   */
  export type AsDetectedDeleteManyArgs = {
    /**
     * Filter which AsDetecteds to delete
     */
    where?: AsDetectedWhereInput
  }


  /**
   * AsDetected without action
   */
  export type AsDetectedArgs = {
    /**
     * Select specific fields to fetch from the AsDetected
     */
    select?: AsDetectedSelect | null
  }



  /**
   * Model DetectedStatus
   */


  export type AggregateDetectedStatus = {
    _count: DetectedStatusCountAggregateOutputType | null
    _min: DetectedStatusMinAggregateOutputType | null
    _max: DetectedStatusMaxAggregateOutputType | null
  }

  export type DetectedStatusMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetectedStatusMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DetectedStatusCountAggregateOutputType = {
    id: number
    name: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DetectedStatusMinAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetectedStatusMaxAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DetectedStatusCountAggregateInputType = {
    id?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DetectedStatusAggregateArgs = {
    /**
     * Filter which DetectedStatus to aggregate.
     */
    where?: DetectedStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedStatuses to fetch.
     */
    orderBy?: Enumerable<DetectedStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetectedStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetectedStatuses
    **/
    _count?: true | DetectedStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetectedStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetectedStatusMaxAggregateInputType
  }

  export type GetDetectedStatusAggregateType<T extends DetectedStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateDetectedStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetectedStatus[P]>
      : GetScalarType<T[P], AggregateDetectedStatus[P]>
  }




  export type DetectedStatusGroupByArgs = {
    where?: DetectedStatusWhereInput
    orderBy?: Enumerable<DetectedStatusOrderByWithAggregationInput>
    by: DetectedStatusScalarFieldEnum[]
    having?: DetectedStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetectedStatusCountAggregateInputType | true
    _min?: DetectedStatusMinAggregateInputType
    _max?: DetectedStatusMaxAggregateInputType
  }


  export type DetectedStatusGroupByOutputType = {
    id: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DetectedStatusCountAggregateOutputType | null
    _min: DetectedStatusMinAggregateOutputType | null
    _max: DetectedStatusMaxAggregateOutputType | null
  }

  type GetDetectedStatusGroupByPayload<T extends DetectedStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DetectedStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetectedStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetectedStatusGroupByOutputType[P]>
            : GetScalarType<T[P], DetectedStatusGroupByOutputType[P]>
        }
      >
    >


  export type DetectedStatusSelect = {
    id?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type DetectedStatusGetPayload<S extends boolean | null | undefined | DetectedStatusArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DetectedStatus :
    S extends undefined ? never :
    S extends { include: any } & (DetectedStatusArgs | DetectedStatusFindManyArgs)
    ? DetectedStatus 
    : S extends { select: any } & (DetectedStatusArgs | DetectedStatusFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DetectedStatus ? DetectedStatus[P] : never
  } 
      : DetectedStatus


  type DetectedStatusCountArgs = 
    Omit<DetectedStatusFindManyArgs, 'select' | 'include'> & {
      select?: DetectedStatusCountAggregateInputType | true
    }

  export interface DetectedStatusDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DetectedStatus that matches the filter.
     * @param {DetectedStatusFindUniqueArgs} args - Arguments to find a DetectedStatus
     * @example
     * // Get one DetectedStatus
     * const detectedStatus = await prisma.detectedStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DetectedStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DetectedStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DetectedStatus'> extends True ? Prisma__DetectedStatusClient<DetectedStatusGetPayload<T>> : Prisma__DetectedStatusClient<DetectedStatusGetPayload<T> | null, null>

    /**
     * Find one DetectedStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DetectedStatusFindUniqueOrThrowArgs} args - Arguments to find a DetectedStatus
     * @example
     * // Get one DetectedStatus
     * const detectedStatus = await prisma.detectedStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DetectedStatusFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DetectedStatusFindUniqueOrThrowArgs>
    ): Prisma__DetectedStatusClient<DetectedStatusGetPayload<T>>

    /**
     * Find the first DetectedStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedStatusFindFirstArgs} args - Arguments to find a DetectedStatus
     * @example
     * // Get one DetectedStatus
     * const detectedStatus = await prisma.detectedStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DetectedStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DetectedStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DetectedStatus'> extends True ? Prisma__DetectedStatusClient<DetectedStatusGetPayload<T>> : Prisma__DetectedStatusClient<DetectedStatusGetPayload<T> | null, null>

    /**
     * Find the first DetectedStatus that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedStatusFindFirstOrThrowArgs} args - Arguments to find a DetectedStatus
     * @example
     * // Get one DetectedStatus
     * const detectedStatus = await prisma.detectedStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DetectedStatusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DetectedStatusFindFirstOrThrowArgs>
    ): Prisma__DetectedStatusClient<DetectedStatusGetPayload<T>>

    /**
     * Find zero or more DetectedStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetectedStatuses
     * const detectedStatuses = await prisma.detectedStatus.findMany()
     * 
     * // Get first 10 DetectedStatuses
     * const detectedStatuses = await prisma.detectedStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detectedStatusWithIdOnly = await prisma.detectedStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DetectedStatusFindManyArgs>(
      args?: SelectSubset<T, DetectedStatusFindManyArgs>
    ): Prisma.PrismaPromise<Array<DetectedStatusGetPayload<T>>>

    /**
     * Create a DetectedStatus.
     * @param {DetectedStatusCreateArgs} args - Arguments to create a DetectedStatus.
     * @example
     * // Create one DetectedStatus
     * const DetectedStatus = await prisma.detectedStatus.create({
     *   data: {
     *     // ... data to create a DetectedStatus
     *   }
     * })
     * 
    **/
    create<T extends DetectedStatusCreateArgs>(
      args: SelectSubset<T, DetectedStatusCreateArgs>
    ): Prisma__DetectedStatusClient<DetectedStatusGetPayload<T>>

    /**
     * Create many DetectedStatuses.
     *     @param {DetectedStatusCreateManyArgs} args - Arguments to create many DetectedStatuses.
     *     @example
     *     // Create many DetectedStatuses
     *     const detectedStatus = await prisma.detectedStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DetectedStatusCreateManyArgs>(
      args?: SelectSubset<T, DetectedStatusCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DetectedStatus.
     * @param {DetectedStatusDeleteArgs} args - Arguments to delete one DetectedStatus.
     * @example
     * // Delete one DetectedStatus
     * const DetectedStatus = await prisma.detectedStatus.delete({
     *   where: {
     *     // ... filter to delete one DetectedStatus
     *   }
     * })
     * 
    **/
    delete<T extends DetectedStatusDeleteArgs>(
      args: SelectSubset<T, DetectedStatusDeleteArgs>
    ): Prisma__DetectedStatusClient<DetectedStatusGetPayload<T>>

    /**
     * Update one DetectedStatus.
     * @param {DetectedStatusUpdateArgs} args - Arguments to update one DetectedStatus.
     * @example
     * // Update one DetectedStatus
     * const detectedStatus = await prisma.detectedStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DetectedStatusUpdateArgs>(
      args: SelectSubset<T, DetectedStatusUpdateArgs>
    ): Prisma__DetectedStatusClient<DetectedStatusGetPayload<T>>

    /**
     * Delete zero or more DetectedStatuses.
     * @param {DetectedStatusDeleteManyArgs} args - Arguments to filter DetectedStatuses to delete.
     * @example
     * // Delete a few DetectedStatuses
     * const { count } = await prisma.detectedStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DetectedStatusDeleteManyArgs>(
      args?: SelectSubset<T, DetectedStatusDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetectedStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetectedStatuses
     * const detectedStatus = await prisma.detectedStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DetectedStatusUpdateManyArgs>(
      args: SelectSubset<T, DetectedStatusUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetectedStatus.
     * @param {DetectedStatusUpsertArgs} args - Arguments to update or create a DetectedStatus.
     * @example
     * // Update or create a DetectedStatus
     * const detectedStatus = await prisma.detectedStatus.upsert({
     *   create: {
     *     // ... data to create a DetectedStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetectedStatus we want to update
     *   }
     * })
    **/
    upsert<T extends DetectedStatusUpsertArgs>(
      args: SelectSubset<T, DetectedStatusUpsertArgs>
    ): Prisma__DetectedStatusClient<DetectedStatusGetPayload<T>>

    /**
     * Count the number of DetectedStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedStatusCountArgs} args - Arguments to filter DetectedStatuses to count.
     * @example
     * // Count the number of DetectedStatuses
     * const count = await prisma.detectedStatus.count({
     *   where: {
     *     // ... the filter for the DetectedStatuses we want to count
     *   }
     * })
    **/
    count<T extends DetectedStatusCountArgs>(
      args?: Subset<T, DetectedStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetectedStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetectedStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetectedStatusAggregateArgs>(args: Subset<T, DetectedStatusAggregateArgs>): Prisma.PrismaPromise<GetDetectedStatusAggregateType<T>>

    /**
     * Group by DetectedStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetectedStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetectedStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetectedStatusGroupByArgs['orderBy'] }
        : { orderBy?: DetectedStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetectedStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetectedStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DetectedStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DetectedStatusClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DetectedStatus base type for findUnique actions
   */
  export type DetectedStatusFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * Filter, which DetectedStatus to fetch.
     */
    where: DetectedStatusWhereUniqueInput
  }

  /**
   * DetectedStatus findUnique
   */
  export interface DetectedStatusFindUniqueArgs extends DetectedStatusFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DetectedStatus findUniqueOrThrow
   */
  export type DetectedStatusFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * Filter, which DetectedStatus to fetch.
     */
    where: DetectedStatusWhereUniqueInput
  }


  /**
   * DetectedStatus base type for findFirst actions
   */
  export type DetectedStatusFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * Filter, which DetectedStatus to fetch.
     */
    where?: DetectedStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedStatuses to fetch.
     */
    orderBy?: Enumerable<DetectedStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetectedStatuses.
     */
    cursor?: DetectedStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetectedStatuses.
     */
    distinct?: Enumerable<DetectedStatusScalarFieldEnum>
  }

  /**
   * DetectedStatus findFirst
   */
  export interface DetectedStatusFindFirstArgs extends DetectedStatusFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DetectedStatus findFirstOrThrow
   */
  export type DetectedStatusFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * Filter, which DetectedStatus to fetch.
     */
    where?: DetectedStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedStatuses to fetch.
     */
    orderBy?: Enumerable<DetectedStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetectedStatuses.
     */
    cursor?: DetectedStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetectedStatuses.
     */
    distinct?: Enumerable<DetectedStatusScalarFieldEnum>
  }


  /**
   * DetectedStatus findMany
   */
  export type DetectedStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * Filter, which DetectedStatuses to fetch.
     */
    where?: DetectedStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetectedStatuses to fetch.
     */
    orderBy?: Enumerable<DetectedStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetectedStatuses.
     */
    cursor?: DetectedStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetectedStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetectedStatuses.
     */
    skip?: number
    distinct?: Enumerable<DetectedStatusScalarFieldEnum>
  }


  /**
   * DetectedStatus create
   */
  export type DetectedStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * The data needed to create a DetectedStatus.
     */
    data: XOR<DetectedStatusCreateInput, DetectedStatusUncheckedCreateInput>
  }


  /**
   * DetectedStatus createMany
   */
  export type DetectedStatusCreateManyArgs = {
    /**
     * The data used to create many DetectedStatuses.
     */
    data: Enumerable<DetectedStatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DetectedStatus update
   */
  export type DetectedStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * The data needed to update a DetectedStatus.
     */
    data: XOR<DetectedStatusUpdateInput, DetectedStatusUncheckedUpdateInput>
    /**
     * Choose, which DetectedStatus to update.
     */
    where: DetectedStatusWhereUniqueInput
  }


  /**
   * DetectedStatus updateMany
   */
  export type DetectedStatusUpdateManyArgs = {
    /**
     * The data used to update DetectedStatuses.
     */
    data: XOR<DetectedStatusUpdateManyMutationInput, DetectedStatusUncheckedUpdateManyInput>
    /**
     * Filter which DetectedStatuses to update
     */
    where?: DetectedStatusWhereInput
  }


  /**
   * DetectedStatus upsert
   */
  export type DetectedStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * The filter to search for the DetectedStatus to update in case it exists.
     */
    where: DetectedStatusWhereUniqueInput
    /**
     * In case the DetectedStatus found by the `where` argument doesn't exist, create a new DetectedStatus with this data.
     */
    create: XOR<DetectedStatusCreateInput, DetectedStatusUncheckedCreateInput>
    /**
     * In case the DetectedStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetectedStatusUpdateInput, DetectedStatusUncheckedUpdateInput>
  }


  /**
   * DetectedStatus delete
   */
  export type DetectedStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
    /**
     * Filter which DetectedStatus to delete.
     */
    where: DetectedStatusWhereUniqueInput
  }


  /**
   * DetectedStatus deleteMany
   */
  export type DetectedStatusDeleteManyArgs = {
    /**
     * Filter which DetectedStatuses to delete
     */
    where?: DetectedStatusWhereInput
  }


  /**
   * DetectedStatus without action
   */
  export type DetectedStatusArgs = {
    /**
     * Select specific fields to fetch from the DetectedStatus
     */
    select?: DetectedStatusSelect | null
  }



  /**
   * Model ImpactObject
   */


  export type AggregateImpactObject = {
    _count: ImpactObjectCountAggregateOutputType | null
    _min: ImpactObjectMinAggregateOutputType | null
    _max: ImpactObjectMaxAggregateOutputType | null
  }

  export type ImpactObjectMinAggregateOutputType = {
    id: string | null
    code: string | null
    objectsInfluence: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImpactObjectMaxAggregateOutputType = {
    id: string | null
    code: string | null
    objectsInfluence: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImpactObjectCountAggregateOutputType = {
    id: number
    code: number
    objectsInfluence: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImpactObjectMinAggregateInputType = {
    id?: true
    code?: true
    objectsInfluence?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImpactObjectMaxAggregateInputType = {
    id?: true
    code?: true
    objectsInfluence?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImpactObjectCountAggregateInputType = {
    id?: true
    code?: true
    objectsInfluence?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImpactObjectAggregateArgs = {
    /**
     * Filter which ImpactObject to aggregate.
     */
    where?: ImpactObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactObjects to fetch.
     */
    orderBy?: Enumerable<ImpactObjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImpactObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImpactObjects
    **/
    _count?: true | ImpactObjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImpactObjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImpactObjectMaxAggregateInputType
  }

  export type GetImpactObjectAggregateType<T extends ImpactObjectAggregateArgs> = {
        [P in keyof T & keyof AggregateImpactObject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpactObject[P]>
      : GetScalarType<T[P], AggregateImpactObject[P]>
  }




  export type ImpactObjectGroupByArgs = {
    where?: ImpactObjectWhereInput
    orderBy?: Enumerable<ImpactObjectOrderByWithAggregationInput>
    by: ImpactObjectScalarFieldEnum[]
    having?: ImpactObjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImpactObjectCountAggregateInputType | true
    _min?: ImpactObjectMinAggregateInputType
    _max?: ImpactObjectMaxAggregateInputType
  }


  export type ImpactObjectGroupByOutputType = {
    id: string
    code: string
    objectsInfluence: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImpactObjectCountAggregateOutputType | null
    _min: ImpactObjectMinAggregateOutputType | null
    _max: ImpactObjectMaxAggregateOutputType | null
  }

  type GetImpactObjectGroupByPayload<T extends ImpactObjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImpactObjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImpactObjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImpactObjectGroupByOutputType[P]>
            : GetScalarType<T[P], ImpactObjectGroupByOutputType[P]>
        }
      >
    >


  export type ImpactObjectSelect = {
    id?: boolean
    code?: boolean
    objectsInfluence?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ImpactObjectGetPayload<S extends boolean | null | undefined | ImpactObjectArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ImpactObject :
    S extends undefined ? never :
    S extends { include: any } & (ImpactObjectArgs | ImpactObjectFindManyArgs)
    ? ImpactObject 
    : S extends { select: any } & (ImpactObjectArgs | ImpactObjectFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ImpactObject ? ImpactObject[P] : never
  } 
      : ImpactObject


  type ImpactObjectCountArgs = 
    Omit<ImpactObjectFindManyArgs, 'select' | 'include'> & {
      select?: ImpactObjectCountAggregateInputType | true
    }

  export interface ImpactObjectDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ImpactObject that matches the filter.
     * @param {ImpactObjectFindUniqueArgs} args - Arguments to find a ImpactObject
     * @example
     * // Get one ImpactObject
     * const impactObject = await prisma.impactObject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImpactObjectFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImpactObjectFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ImpactObject'> extends True ? Prisma__ImpactObjectClient<ImpactObjectGetPayload<T>> : Prisma__ImpactObjectClient<ImpactObjectGetPayload<T> | null, null>

    /**
     * Find one ImpactObject that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ImpactObjectFindUniqueOrThrowArgs} args - Arguments to find a ImpactObject
     * @example
     * // Get one ImpactObject
     * const impactObject = await prisma.impactObject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImpactObjectFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImpactObjectFindUniqueOrThrowArgs>
    ): Prisma__ImpactObjectClient<ImpactObjectGetPayload<T>>

    /**
     * Find the first ImpactObject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactObjectFindFirstArgs} args - Arguments to find a ImpactObject
     * @example
     * // Get one ImpactObject
     * const impactObject = await prisma.impactObject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImpactObjectFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImpactObjectFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ImpactObject'> extends True ? Prisma__ImpactObjectClient<ImpactObjectGetPayload<T>> : Prisma__ImpactObjectClient<ImpactObjectGetPayload<T> | null, null>

    /**
     * Find the first ImpactObject that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactObjectFindFirstOrThrowArgs} args - Arguments to find a ImpactObject
     * @example
     * // Get one ImpactObject
     * const impactObject = await prisma.impactObject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImpactObjectFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImpactObjectFindFirstOrThrowArgs>
    ): Prisma__ImpactObjectClient<ImpactObjectGetPayload<T>>

    /**
     * Find zero or more ImpactObjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactObjectFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImpactObjects
     * const impactObjects = await prisma.impactObject.findMany()
     * 
     * // Get first 10 ImpactObjects
     * const impactObjects = await prisma.impactObject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impactObjectWithIdOnly = await prisma.impactObject.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImpactObjectFindManyArgs>(
      args?: SelectSubset<T, ImpactObjectFindManyArgs>
    ): Prisma.PrismaPromise<Array<ImpactObjectGetPayload<T>>>

    /**
     * Create a ImpactObject.
     * @param {ImpactObjectCreateArgs} args - Arguments to create a ImpactObject.
     * @example
     * // Create one ImpactObject
     * const ImpactObject = await prisma.impactObject.create({
     *   data: {
     *     // ... data to create a ImpactObject
     *   }
     * })
     * 
    **/
    create<T extends ImpactObjectCreateArgs>(
      args: SelectSubset<T, ImpactObjectCreateArgs>
    ): Prisma__ImpactObjectClient<ImpactObjectGetPayload<T>>

    /**
     * Create many ImpactObjects.
     *     @param {ImpactObjectCreateManyArgs} args - Arguments to create many ImpactObjects.
     *     @example
     *     // Create many ImpactObjects
     *     const impactObject = await prisma.impactObject.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImpactObjectCreateManyArgs>(
      args?: SelectSubset<T, ImpactObjectCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImpactObject.
     * @param {ImpactObjectDeleteArgs} args - Arguments to delete one ImpactObject.
     * @example
     * // Delete one ImpactObject
     * const ImpactObject = await prisma.impactObject.delete({
     *   where: {
     *     // ... filter to delete one ImpactObject
     *   }
     * })
     * 
    **/
    delete<T extends ImpactObjectDeleteArgs>(
      args: SelectSubset<T, ImpactObjectDeleteArgs>
    ): Prisma__ImpactObjectClient<ImpactObjectGetPayload<T>>

    /**
     * Update one ImpactObject.
     * @param {ImpactObjectUpdateArgs} args - Arguments to update one ImpactObject.
     * @example
     * // Update one ImpactObject
     * const impactObject = await prisma.impactObject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImpactObjectUpdateArgs>(
      args: SelectSubset<T, ImpactObjectUpdateArgs>
    ): Prisma__ImpactObjectClient<ImpactObjectGetPayload<T>>

    /**
     * Delete zero or more ImpactObjects.
     * @param {ImpactObjectDeleteManyArgs} args - Arguments to filter ImpactObjects to delete.
     * @example
     * // Delete a few ImpactObjects
     * const { count } = await prisma.impactObject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImpactObjectDeleteManyArgs>(
      args?: SelectSubset<T, ImpactObjectDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImpactObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactObjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImpactObjects
     * const impactObject = await prisma.impactObject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImpactObjectUpdateManyArgs>(
      args: SelectSubset<T, ImpactObjectUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImpactObject.
     * @param {ImpactObjectUpsertArgs} args - Arguments to update or create a ImpactObject.
     * @example
     * // Update or create a ImpactObject
     * const impactObject = await prisma.impactObject.upsert({
     *   create: {
     *     // ... data to create a ImpactObject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImpactObject we want to update
     *   }
     * })
    **/
    upsert<T extends ImpactObjectUpsertArgs>(
      args: SelectSubset<T, ImpactObjectUpsertArgs>
    ): Prisma__ImpactObjectClient<ImpactObjectGetPayload<T>>

    /**
     * Count the number of ImpactObjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactObjectCountArgs} args - Arguments to filter ImpactObjects to count.
     * @example
     * // Count the number of ImpactObjects
     * const count = await prisma.impactObject.count({
     *   where: {
     *     // ... the filter for the ImpactObjects we want to count
     *   }
     * })
    **/
    count<T extends ImpactObjectCountArgs>(
      args?: Subset<T, ImpactObjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImpactObjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImpactObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactObjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImpactObjectAggregateArgs>(args: Subset<T, ImpactObjectAggregateArgs>): Prisma.PrismaPromise<GetImpactObjectAggregateType<T>>

    /**
     * Group by ImpactObject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactObjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImpactObjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImpactObjectGroupByArgs['orderBy'] }
        : { orderBy?: ImpactObjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImpactObjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpactObjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ImpactObject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImpactObjectClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ImpactObject base type for findUnique actions
   */
  export type ImpactObjectFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * Filter, which ImpactObject to fetch.
     */
    where: ImpactObjectWhereUniqueInput
  }

  /**
   * ImpactObject findUnique
   */
  export interface ImpactObjectFindUniqueArgs extends ImpactObjectFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImpactObject findUniqueOrThrow
   */
  export type ImpactObjectFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * Filter, which ImpactObject to fetch.
     */
    where: ImpactObjectWhereUniqueInput
  }


  /**
   * ImpactObject base type for findFirst actions
   */
  export type ImpactObjectFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * Filter, which ImpactObject to fetch.
     */
    where?: ImpactObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactObjects to fetch.
     */
    orderBy?: Enumerable<ImpactObjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImpactObjects.
     */
    cursor?: ImpactObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImpactObjects.
     */
    distinct?: Enumerable<ImpactObjectScalarFieldEnum>
  }

  /**
   * ImpactObject findFirst
   */
  export interface ImpactObjectFindFirstArgs extends ImpactObjectFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImpactObject findFirstOrThrow
   */
  export type ImpactObjectFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * Filter, which ImpactObject to fetch.
     */
    where?: ImpactObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactObjects to fetch.
     */
    orderBy?: Enumerable<ImpactObjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImpactObjects.
     */
    cursor?: ImpactObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactObjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImpactObjects.
     */
    distinct?: Enumerable<ImpactObjectScalarFieldEnum>
  }


  /**
   * ImpactObject findMany
   */
  export type ImpactObjectFindManyArgs = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * Filter, which ImpactObjects to fetch.
     */
    where?: ImpactObjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactObjects to fetch.
     */
    orderBy?: Enumerable<ImpactObjectOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImpactObjects.
     */
    cursor?: ImpactObjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactObjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactObjects.
     */
    skip?: number
    distinct?: Enumerable<ImpactObjectScalarFieldEnum>
  }


  /**
   * ImpactObject create
   */
  export type ImpactObjectCreateArgs = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * The data needed to create a ImpactObject.
     */
    data: XOR<ImpactObjectCreateInput, ImpactObjectUncheckedCreateInput>
  }


  /**
   * ImpactObject createMany
   */
  export type ImpactObjectCreateManyArgs = {
    /**
     * The data used to create many ImpactObjects.
     */
    data: Enumerable<ImpactObjectCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ImpactObject update
   */
  export type ImpactObjectUpdateArgs = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * The data needed to update a ImpactObject.
     */
    data: XOR<ImpactObjectUpdateInput, ImpactObjectUncheckedUpdateInput>
    /**
     * Choose, which ImpactObject to update.
     */
    where: ImpactObjectWhereUniqueInput
  }


  /**
   * ImpactObject updateMany
   */
  export type ImpactObjectUpdateManyArgs = {
    /**
     * The data used to update ImpactObjects.
     */
    data: XOR<ImpactObjectUpdateManyMutationInput, ImpactObjectUncheckedUpdateManyInput>
    /**
     * Filter which ImpactObjects to update
     */
    where?: ImpactObjectWhereInput
  }


  /**
   * ImpactObject upsert
   */
  export type ImpactObjectUpsertArgs = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * The filter to search for the ImpactObject to update in case it exists.
     */
    where: ImpactObjectWhereUniqueInput
    /**
     * In case the ImpactObject found by the `where` argument doesn't exist, create a new ImpactObject with this data.
     */
    create: XOR<ImpactObjectCreateInput, ImpactObjectUncheckedCreateInput>
    /**
     * In case the ImpactObject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImpactObjectUpdateInput, ImpactObjectUncheckedUpdateInput>
  }


  /**
   * ImpactObject delete
   */
  export type ImpactObjectDeleteArgs = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
    /**
     * Filter which ImpactObject to delete.
     */
    where: ImpactObjectWhereUniqueInput
  }


  /**
   * ImpactObject deleteMany
   */
  export type ImpactObjectDeleteManyArgs = {
    /**
     * Filter which ImpactObjects to delete
     */
    where?: ImpactObjectWhereInput
  }


  /**
   * ImpactObject without action
   */
  export type ImpactObjectArgs = {
    /**
     * Select specific fields to fetch from the ImpactObject
     */
    select?: ImpactObjectSelect | null
  }



  /**
   * Model TypeComponents
   */


  export type AggregateTypeComponents = {
    _count: TypeComponentsCountAggregateOutputType | null
    _min: TypeComponentsMinAggregateOutputType | null
    _max: TypeComponentsMaxAggregateOutputType | null
  }

  export type TypeComponentsMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeComponentsMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypeComponentsCountAggregateOutputType = {
    id: number
    code: number
    name: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TypeComponentsMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeComponentsMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypeComponentsCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TypeComponentsAggregateArgs = {
    /**
     * Filter which TypeComponents to aggregate.
     */
    where?: TypeComponentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeComponents to fetch.
     */
    orderBy?: Enumerable<TypeComponentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeComponentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeComponents
    **/
    _count?: true | TypeComponentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeComponentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeComponentsMaxAggregateInputType
  }

  export type GetTypeComponentsAggregateType<T extends TypeComponentsAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeComponents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeComponents[P]>
      : GetScalarType<T[P], AggregateTypeComponents[P]>
  }




  export type TypeComponentsGroupByArgs = {
    where?: TypeComponentsWhereInput
    orderBy?: Enumerable<TypeComponentsOrderByWithAggregationInput>
    by: TypeComponentsScalarFieldEnum[]
    having?: TypeComponentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeComponentsCountAggregateInputType | true
    _min?: TypeComponentsMinAggregateInputType
    _max?: TypeComponentsMaxAggregateInputType
  }


  export type TypeComponentsGroupByOutputType = {
    id: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TypeComponentsCountAggregateOutputType | null
    _min: TypeComponentsMinAggregateOutputType | null
    _max: TypeComponentsMaxAggregateOutputType | null
  }

  type GetTypeComponentsGroupByPayload<T extends TypeComponentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypeComponentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeComponentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeComponentsGroupByOutputType[P]>
            : GetScalarType<T[P], TypeComponentsGroupByOutputType[P]>
        }
      >
    >


  export type TypeComponentsSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TypeComponentsGetPayload<S extends boolean | null | undefined | TypeComponentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TypeComponents :
    S extends undefined ? never :
    S extends { include: any } & (TypeComponentsArgs | TypeComponentsFindManyArgs)
    ? TypeComponents 
    : S extends { select: any } & (TypeComponentsArgs | TypeComponentsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TypeComponents ? TypeComponents[P] : never
  } 
      : TypeComponents


  type TypeComponentsCountArgs = 
    Omit<TypeComponentsFindManyArgs, 'select' | 'include'> & {
      select?: TypeComponentsCountAggregateInputType | true
    }

  export interface TypeComponentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TypeComponents that matches the filter.
     * @param {TypeComponentsFindUniqueArgs} args - Arguments to find a TypeComponents
     * @example
     * // Get one TypeComponents
     * const typeComponents = await prisma.typeComponents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypeComponentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypeComponentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TypeComponents'> extends True ? Prisma__TypeComponentsClient<TypeComponentsGetPayload<T>> : Prisma__TypeComponentsClient<TypeComponentsGetPayload<T> | null, null>

    /**
     * Find one TypeComponents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypeComponentsFindUniqueOrThrowArgs} args - Arguments to find a TypeComponents
     * @example
     * // Get one TypeComponents
     * const typeComponents = await prisma.typeComponents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypeComponentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TypeComponentsFindUniqueOrThrowArgs>
    ): Prisma__TypeComponentsClient<TypeComponentsGetPayload<T>>

    /**
     * Find the first TypeComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComponentsFindFirstArgs} args - Arguments to find a TypeComponents
     * @example
     * // Get one TypeComponents
     * const typeComponents = await prisma.typeComponents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypeComponentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypeComponentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TypeComponents'> extends True ? Prisma__TypeComponentsClient<TypeComponentsGetPayload<T>> : Prisma__TypeComponentsClient<TypeComponentsGetPayload<T> | null, null>

    /**
     * Find the first TypeComponents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComponentsFindFirstOrThrowArgs} args - Arguments to find a TypeComponents
     * @example
     * // Get one TypeComponents
     * const typeComponents = await prisma.typeComponents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypeComponentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TypeComponentsFindFirstOrThrowArgs>
    ): Prisma__TypeComponentsClient<TypeComponentsGetPayload<T>>

    /**
     * Find zero or more TypeComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComponentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeComponents
     * const typeComponents = await prisma.typeComponents.findMany()
     * 
     * // Get first 10 TypeComponents
     * const typeComponents = await prisma.typeComponents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeComponentsWithIdOnly = await prisma.typeComponents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypeComponentsFindManyArgs>(
      args?: SelectSubset<T, TypeComponentsFindManyArgs>
    ): Prisma.PrismaPromise<Array<TypeComponentsGetPayload<T>>>

    /**
     * Create a TypeComponents.
     * @param {TypeComponentsCreateArgs} args - Arguments to create a TypeComponents.
     * @example
     * // Create one TypeComponents
     * const TypeComponents = await prisma.typeComponents.create({
     *   data: {
     *     // ... data to create a TypeComponents
     *   }
     * })
     * 
    **/
    create<T extends TypeComponentsCreateArgs>(
      args: SelectSubset<T, TypeComponentsCreateArgs>
    ): Prisma__TypeComponentsClient<TypeComponentsGetPayload<T>>

    /**
     * Create many TypeComponents.
     *     @param {TypeComponentsCreateManyArgs} args - Arguments to create many TypeComponents.
     *     @example
     *     // Create many TypeComponents
     *     const typeComponents = await prisma.typeComponents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypeComponentsCreateManyArgs>(
      args?: SelectSubset<T, TypeComponentsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypeComponents.
     * @param {TypeComponentsDeleteArgs} args - Arguments to delete one TypeComponents.
     * @example
     * // Delete one TypeComponents
     * const TypeComponents = await prisma.typeComponents.delete({
     *   where: {
     *     // ... filter to delete one TypeComponents
     *   }
     * })
     * 
    **/
    delete<T extends TypeComponentsDeleteArgs>(
      args: SelectSubset<T, TypeComponentsDeleteArgs>
    ): Prisma__TypeComponentsClient<TypeComponentsGetPayload<T>>

    /**
     * Update one TypeComponents.
     * @param {TypeComponentsUpdateArgs} args - Arguments to update one TypeComponents.
     * @example
     * // Update one TypeComponents
     * const typeComponents = await prisma.typeComponents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypeComponentsUpdateArgs>(
      args: SelectSubset<T, TypeComponentsUpdateArgs>
    ): Prisma__TypeComponentsClient<TypeComponentsGetPayload<T>>

    /**
     * Delete zero or more TypeComponents.
     * @param {TypeComponentsDeleteManyArgs} args - Arguments to filter TypeComponents to delete.
     * @example
     * // Delete a few TypeComponents
     * const { count } = await prisma.typeComponents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypeComponentsDeleteManyArgs>(
      args?: SelectSubset<T, TypeComponentsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComponentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeComponents
     * const typeComponents = await prisma.typeComponents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypeComponentsUpdateManyArgs>(
      args: SelectSubset<T, TypeComponentsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeComponents.
     * @param {TypeComponentsUpsertArgs} args - Arguments to update or create a TypeComponents.
     * @example
     * // Update or create a TypeComponents
     * const typeComponents = await prisma.typeComponents.upsert({
     *   create: {
     *     // ... data to create a TypeComponents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeComponents we want to update
     *   }
     * })
    **/
    upsert<T extends TypeComponentsUpsertArgs>(
      args: SelectSubset<T, TypeComponentsUpsertArgs>
    ): Prisma__TypeComponentsClient<TypeComponentsGetPayload<T>>

    /**
     * Count the number of TypeComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComponentsCountArgs} args - Arguments to filter TypeComponents to count.
     * @example
     * // Count the number of TypeComponents
     * const count = await prisma.typeComponents.count({
     *   where: {
     *     // ... the filter for the TypeComponents we want to count
     *   }
     * })
    **/
    count<T extends TypeComponentsCountArgs>(
      args?: Subset<T, TypeComponentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeComponentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComponentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeComponentsAggregateArgs>(args: Subset<T, TypeComponentsAggregateArgs>): Prisma.PrismaPromise<GetTypeComponentsAggregateType<T>>

    /**
     * Group by TypeComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeComponentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeComponentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeComponentsGroupByArgs['orderBy'] }
        : { orderBy?: TypeComponentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeComponentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeComponentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeComponents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypeComponentsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TypeComponents base type for findUnique actions
   */
  export type TypeComponentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * Filter, which TypeComponents to fetch.
     */
    where: TypeComponentsWhereUniqueInput
  }

  /**
   * TypeComponents findUnique
   */
  export interface TypeComponentsFindUniqueArgs extends TypeComponentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypeComponents findUniqueOrThrow
   */
  export type TypeComponentsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * Filter, which TypeComponents to fetch.
     */
    where: TypeComponentsWhereUniqueInput
  }


  /**
   * TypeComponents base type for findFirst actions
   */
  export type TypeComponentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * Filter, which TypeComponents to fetch.
     */
    where?: TypeComponentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeComponents to fetch.
     */
    orderBy?: Enumerable<TypeComponentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeComponents.
     */
    cursor?: TypeComponentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeComponents.
     */
    distinct?: Enumerable<TypeComponentsScalarFieldEnum>
  }

  /**
   * TypeComponents findFirst
   */
  export interface TypeComponentsFindFirstArgs extends TypeComponentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypeComponents findFirstOrThrow
   */
  export type TypeComponentsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * Filter, which TypeComponents to fetch.
     */
    where?: TypeComponentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeComponents to fetch.
     */
    orderBy?: Enumerable<TypeComponentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeComponents.
     */
    cursor?: TypeComponentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeComponents.
     */
    distinct?: Enumerable<TypeComponentsScalarFieldEnum>
  }


  /**
   * TypeComponents findMany
   */
  export type TypeComponentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * Filter, which TypeComponents to fetch.
     */
    where?: TypeComponentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeComponents to fetch.
     */
    orderBy?: Enumerable<TypeComponentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeComponents.
     */
    cursor?: TypeComponentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeComponents.
     */
    skip?: number
    distinct?: Enumerable<TypeComponentsScalarFieldEnum>
  }


  /**
   * TypeComponents create
   */
  export type TypeComponentsCreateArgs = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * The data needed to create a TypeComponents.
     */
    data: XOR<TypeComponentsCreateInput, TypeComponentsUncheckedCreateInput>
  }


  /**
   * TypeComponents createMany
   */
  export type TypeComponentsCreateManyArgs = {
    /**
     * The data used to create many TypeComponents.
     */
    data: Enumerable<TypeComponentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TypeComponents update
   */
  export type TypeComponentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * The data needed to update a TypeComponents.
     */
    data: XOR<TypeComponentsUpdateInput, TypeComponentsUncheckedUpdateInput>
    /**
     * Choose, which TypeComponents to update.
     */
    where: TypeComponentsWhereUniqueInput
  }


  /**
   * TypeComponents updateMany
   */
  export type TypeComponentsUpdateManyArgs = {
    /**
     * The data used to update TypeComponents.
     */
    data: XOR<TypeComponentsUpdateManyMutationInput, TypeComponentsUncheckedUpdateManyInput>
    /**
     * Filter which TypeComponents to update
     */
    where?: TypeComponentsWhereInput
  }


  /**
   * TypeComponents upsert
   */
  export type TypeComponentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * The filter to search for the TypeComponents to update in case it exists.
     */
    where: TypeComponentsWhereUniqueInput
    /**
     * In case the TypeComponents found by the `where` argument doesn't exist, create a new TypeComponents with this data.
     */
    create: XOR<TypeComponentsCreateInput, TypeComponentsUncheckedCreateInput>
    /**
     * In case the TypeComponents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeComponentsUpdateInput, TypeComponentsUncheckedUpdateInput>
  }


  /**
   * TypeComponents delete
   */
  export type TypeComponentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
    /**
     * Filter which TypeComponents to delete.
     */
    where: TypeComponentsWhereUniqueInput
  }


  /**
   * TypeComponents deleteMany
   */
  export type TypeComponentsDeleteManyArgs = {
    /**
     * Filter which TypeComponents to delete
     */
    where?: TypeComponentsWhereInput
  }


  /**
   * TypeComponents without action
   */
  export type TypeComponentsArgs = {
    /**
     * Select specific fields to fetch from the TypeComponents
     */
    select?: TypeComponentsSelect | null
  }



  /**
   * Model GroupComponents
   */


  export type AggregateGroupComponents = {
    _count: GroupComponentsCountAggregateOutputType | null
    _min: GroupComponentsMinAggregateOutputType | null
    _max: GroupComponentsMaxAggregateOutputType | null
  }

  export type GroupComponentsMinAggregateOutputType = {
    id: string | null
    code: string | null
    nameGroup: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupComponentsMaxAggregateOutputType = {
    id: string | null
    code: string | null
    nameGroup: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GroupComponentsCountAggregateOutputType = {
    id: number
    code: number
    nameGroup: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GroupComponentsMinAggregateInputType = {
    id?: true
    code?: true
    nameGroup?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupComponentsMaxAggregateInputType = {
    id?: true
    code?: true
    nameGroup?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GroupComponentsCountAggregateInputType = {
    id?: true
    code?: true
    nameGroup?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GroupComponentsAggregateArgs = {
    /**
     * Filter which GroupComponents to aggregate.
     */
    where?: GroupComponentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupComponents to fetch.
     */
    orderBy?: Enumerable<GroupComponentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupComponentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupComponents
    **/
    _count?: true | GroupComponentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupComponentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupComponentsMaxAggregateInputType
  }

  export type GetGroupComponentsAggregateType<T extends GroupComponentsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupComponents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupComponents[P]>
      : GetScalarType<T[P], AggregateGroupComponents[P]>
  }




  export type GroupComponentsGroupByArgs = {
    where?: GroupComponentsWhereInput
    orderBy?: Enumerable<GroupComponentsOrderByWithAggregationInput>
    by: GroupComponentsScalarFieldEnum[]
    having?: GroupComponentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupComponentsCountAggregateInputType | true
    _min?: GroupComponentsMinAggregateInputType
    _max?: GroupComponentsMaxAggregateInputType
  }


  export type GroupComponentsGroupByOutputType = {
    id: string
    code: string
    nameGroup: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: GroupComponentsCountAggregateOutputType | null
    _min: GroupComponentsMinAggregateOutputType | null
    _max: GroupComponentsMaxAggregateOutputType | null
  }

  type GetGroupComponentsGroupByPayload<T extends GroupComponentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<GroupComponentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupComponentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupComponentsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupComponentsGroupByOutputType[P]>
        }
      >
    >


  export type GroupComponentsSelect = {
    id?: boolean
    code?: boolean
    nameGroup?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type GroupComponentsGetPayload<S extends boolean | null | undefined | GroupComponentsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? GroupComponents :
    S extends undefined ? never :
    S extends { include: any } & (GroupComponentsArgs | GroupComponentsFindManyArgs)
    ? GroupComponents 
    : S extends { select: any } & (GroupComponentsArgs | GroupComponentsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof GroupComponents ? GroupComponents[P] : never
  } 
      : GroupComponents


  type GroupComponentsCountArgs = 
    Omit<GroupComponentsFindManyArgs, 'select' | 'include'> & {
      select?: GroupComponentsCountAggregateInputType | true
    }

  export interface GroupComponentsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one GroupComponents that matches the filter.
     * @param {GroupComponentsFindUniqueArgs} args - Arguments to find a GroupComponents
     * @example
     * // Get one GroupComponents
     * const groupComponents = await prisma.groupComponents.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GroupComponentsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GroupComponentsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'GroupComponents'> extends True ? Prisma__GroupComponentsClient<GroupComponentsGetPayload<T>> : Prisma__GroupComponentsClient<GroupComponentsGetPayload<T> | null, null>

    /**
     * Find one GroupComponents that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GroupComponentsFindUniqueOrThrowArgs} args - Arguments to find a GroupComponents
     * @example
     * // Get one GroupComponents
     * const groupComponents = await prisma.groupComponents.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GroupComponentsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, GroupComponentsFindUniqueOrThrowArgs>
    ): Prisma__GroupComponentsClient<GroupComponentsGetPayload<T>>

    /**
     * Find the first GroupComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupComponentsFindFirstArgs} args - Arguments to find a GroupComponents
     * @example
     * // Get one GroupComponents
     * const groupComponents = await prisma.groupComponents.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GroupComponentsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GroupComponentsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'GroupComponents'> extends True ? Prisma__GroupComponentsClient<GroupComponentsGetPayload<T>> : Prisma__GroupComponentsClient<GroupComponentsGetPayload<T> | null, null>

    /**
     * Find the first GroupComponents that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupComponentsFindFirstOrThrowArgs} args - Arguments to find a GroupComponents
     * @example
     * // Get one GroupComponents
     * const groupComponents = await prisma.groupComponents.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GroupComponentsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, GroupComponentsFindFirstOrThrowArgs>
    ): Prisma__GroupComponentsClient<GroupComponentsGetPayload<T>>

    /**
     * Find zero or more GroupComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupComponentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupComponents
     * const groupComponents = await prisma.groupComponents.findMany()
     * 
     * // Get first 10 GroupComponents
     * const groupComponents = await prisma.groupComponents.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupComponentsWithIdOnly = await prisma.groupComponents.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GroupComponentsFindManyArgs>(
      args?: SelectSubset<T, GroupComponentsFindManyArgs>
    ): Prisma.PrismaPromise<Array<GroupComponentsGetPayload<T>>>

    /**
     * Create a GroupComponents.
     * @param {GroupComponentsCreateArgs} args - Arguments to create a GroupComponents.
     * @example
     * // Create one GroupComponents
     * const GroupComponents = await prisma.groupComponents.create({
     *   data: {
     *     // ... data to create a GroupComponents
     *   }
     * })
     * 
    **/
    create<T extends GroupComponentsCreateArgs>(
      args: SelectSubset<T, GroupComponentsCreateArgs>
    ): Prisma__GroupComponentsClient<GroupComponentsGetPayload<T>>

    /**
     * Create many GroupComponents.
     *     @param {GroupComponentsCreateManyArgs} args - Arguments to create many GroupComponents.
     *     @example
     *     // Create many GroupComponents
     *     const groupComponents = await prisma.groupComponents.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GroupComponentsCreateManyArgs>(
      args?: SelectSubset<T, GroupComponentsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupComponents.
     * @param {GroupComponentsDeleteArgs} args - Arguments to delete one GroupComponents.
     * @example
     * // Delete one GroupComponents
     * const GroupComponents = await prisma.groupComponents.delete({
     *   where: {
     *     // ... filter to delete one GroupComponents
     *   }
     * })
     * 
    **/
    delete<T extends GroupComponentsDeleteArgs>(
      args: SelectSubset<T, GroupComponentsDeleteArgs>
    ): Prisma__GroupComponentsClient<GroupComponentsGetPayload<T>>

    /**
     * Update one GroupComponents.
     * @param {GroupComponentsUpdateArgs} args - Arguments to update one GroupComponents.
     * @example
     * // Update one GroupComponents
     * const groupComponents = await prisma.groupComponents.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GroupComponentsUpdateArgs>(
      args: SelectSubset<T, GroupComponentsUpdateArgs>
    ): Prisma__GroupComponentsClient<GroupComponentsGetPayload<T>>

    /**
     * Delete zero or more GroupComponents.
     * @param {GroupComponentsDeleteManyArgs} args - Arguments to filter GroupComponents to delete.
     * @example
     * // Delete a few GroupComponents
     * const { count } = await prisma.groupComponents.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GroupComponentsDeleteManyArgs>(
      args?: SelectSubset<T, GroupComponentsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupComponentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupComponents
     * const groupComponents = await prisma.groupComponents.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GroupComponentsUpdateManyArgs>(
      args: SelectSubset<T, GroupComponentsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupComponents.
     * @param {GroupComponentsUpsertArgs} args - Arguments to update or create a GroupComponents.
     * @example
     * // Update or create a GroupComponents
     * const groupComponents = await prisma.groupComponents.upsert({
     *   create: {
     *     // ... data to create a GroupComponents
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupComponents we want to update
     *   }
     * })
    **/
    upsert<T extends GroupComponentsUpsertArgs>(
      args: SelectSubset<T, GroupComponentsUpsertArgs>
    ): Prisma__GroupComponentsClient<GroupComponentsGetPayload<T>>

    /**
     * Count the number of GroupComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupComponentsCountArgs} args - Arguments to filter GroupComponents to count.
     * @example
     * // Count the number of GroupComponents
     * const count = await prisma.groupComponents.count({
     *   where: {
     *     // ... the filter for the GroupComponents we want to count
     *   }
     * })
    **/
    count<T extends GroupComponentsCountArgs>(
      args?: Subset<T, GroupComponentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupComponentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupComponentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupComponentsAggregateArgs>(args: Subset<T, GroupComponentsAggregateArgs>): Prisma.PrismaPromise<GetGroupComponentsAggregateType<T>>

    /**
     * Group by GroupComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupComponentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupComponentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupComponentsGroupByArgs['orderBy'] }
        : { orderBy?: GroupComponentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupComponentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupComponentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupComponents.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GroupComponentsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * GroupComponents base type for findUnique actions
   */
  export type GroupComponentsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * Filter, which GroupComponents to fetch.
     */
    where: GroupComponentsWhereUniqueInput
  }

  /**
   * GroupComponents findUnique
   */
  export interface GroupComponentsFindUniqueArgs extends GroupComponentsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupComponents findUniqueOrThrow
   */
  export type GroupComponentsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * Filter, which GroupComponents to fetch.
     */
    where: GroupComponentsWhereUniqueInput
  }


  /**
   * GroupComponents base type for findFirst actions
   */
  export type GroupComponentsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * Filter, which GroupComponents to fetch.
     */
    where?: GroupComponentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupComponents to fetch.
     */
    orderBy?: Enumerable<GroupComponentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupComponents.
     */
    cursor?: GroupComponentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupComponents.
     */
    distinct?: Enumerable<GroupComponentsScalarFieldEnum>
  }

  /**
   * GroupComponents findFirst
   */
  export interface GroupComponentsFindFirstArgs extends GroupComponentsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * GroupComponents findFirstOrThrow
   */
  export type GroupComponentsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * Filter, which GroupComponents to fetch.
     */
    where?: GroupComponentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupComponents to fetch.
     */
    orderBy?: Enumerable<GroupComponentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupComponents.
     */
    cursor?: GroupComponentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupComponents.
     */
    distinct?: Enumerable<GroupComponentsScalarFieldEnum>
  }


  /**
   * GroupComponents findMany
   */
  export type GroupComponentsFindManyArgs = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * Filter, which GroupComponents to fetch.
     */
    where?: GroupComponentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupComponents to fetch.
     */
    orderBy?: Enumerable<GroupComponentsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupComponents.
     */
    cursor?: GroupComponentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupComponents.
     */
    skip?: number
    distinct?: Enumerable<GroupComponentsScalarFieldEnum>
  }


  /**
   * GroupComponents create
   */
  export type GroupComponentsCreateArgs = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * The data needed to create a GroupComponents.
     */
    data: XOR<GroupComponentsCreateInput, GroupComponentsUncheckedCreateInput>
  }


  /**
   * GroupComponents createMany
   */
  export type GroupComponentsCreateManyArgs = {
    /**
     * The data used to create many GroupComponents.
     */
    data: Enumerable<GroupComponentsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * GroupComponents update
   */
  export type GroupComponentsUpdateArgs = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * The data needed to update a GroupComponents.
     */
    data: XOR<GroupComponentsUpdateInput, GroupComponentsUncheckedUpdateInput>
    /**
     * Choose, which GroupComponents to update.
     */
    where: GroupComponentsWhereUniqueInput
  }


  /**
   * GroupComponents updateMany
   */
  export type GroupComponentsUpdateManyArgs = {
    /**
     * The data used to update GroupComponents.
     */
    data: XOR<GroupComponentsUpdateManyMutationInput, GroupComponentsUncheckedUpdateManyInput>
    /**
     * Filter which GroupComponents to update
     */
    where?: GroupComponentsWhereInput
  }


  /**
   * GroupComponents upsert
   */
  export type GroupComponentsUpsertArgs = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * The filter to search for the GroupComponents to update in case it exists.
     */
    where: GroupComponentsWhereUniqueInput
    /**
     * In case the GroupComponents found by the `where` argument doesn't exist, create a new GroupComponents with this data.
     */
    create: XOR<GroupComponentsCreateInput, GroupComponentsUncheckedCreateInput>
    /**
     * In case the GroupComponents was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupComponentsUpdateInput, GroupComponentsUncheckedUpdateInput>
  }


  /**
   * GroupComponents delete
   */
  export type GroupComponentsDeleteArgs = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
    /**
     * Filter which GroupComponents to delete.
     */
    where: GroupComponentsWhereUniqueInput
  }


  /**
   * GroupComponents deleteMany
   */
  export type GroupComponentsDeleteManyArgs = {
    /**
     * Filter which GroupComponents to delete
     */
    where?: GroupComponentsWhereInput
  }


  /**
   * GroupComponents without action
   */
  export type GroupComponentsArgs = {
    /**
     * Select specific fields to fetch from the GroupComponents
     */
    select?: GroupComponentsSelect | null
  }



  /**
   * Model ImpactComponent
   */


  export type AggregateImpactComponent = {
    _count: ImpactComponentCountAggregateOutputType | null
    _min: ImpactComponentMinAggregateOutputType | null
    _max: ImpactComponentMaxAggregateOutputType | null
  }

  export type ImpactComponentMinAggregateOutputType = {
    id: string | null
    code: string | null
    impactComponents: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImpactComponentMaxAggregateOutputType = {
    id: string | null
    code: string | null
    impactComponents: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImpactComponentCountAggregateOutputType = {
    id: number
    code: number
    impactComponents: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImpactComponentMinAggregateInputType = {
    id?: true
    code?: true
    impactComponents?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImpactComponentMaxAggregateInputType = {
    id?: true
    code?: true
    impactComponents?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImpactComponentCountAggregateInputType = {
    id?: true
    code?: true
    impactComponents?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImpactComponentAggregateArgs = {
    /**
     * Filter which ImpactComponent to aggregate.
     */
    where?: ImpactComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactComponents to fetch.
     */
    orderBy?: Enumerable<ImpactComponentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImpactComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImpactComponents
    **/
    _count?: true | ImpactComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImpactComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImpactComponentMaxAggregateInputType
  }

  export type GetImpactComponentAggregateType<T extends ImpactComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateImpactComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpactComponent[P]>
      : GetScalarType<T[P], AggregateImpactComponent[P]>
  }




  export type ImpactComponentGroupByArgs = {
    where?: ImpactComponentWhereInput
    orderBy?: Enumerable<ImpactComponentOrderByWithAggregationInput>
    by: ImpactComponentScalarFieldEnum[]
    having?: ImpactComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImpactComponentCountAggregateInputType | true
    _min?: ImpactComponentMinAggregateInputType
    _max?: ImpactComponentMaxAggregateInputType
  }


  export type ImpactComponentGroupByOutputType = {
    id: string
    code: string
    impactComponents: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ImpactComponentCountAggregateOutputType | null
    _min: ImpactComponentMinAggregateOutputType | null
    _max: ImpactComponentMaxAggregateOutputType | null
  }

  type GetImpactComponentGroupByPayload<T extends ImpactComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImpactComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImpactComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImpactComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ImpactComponentGroupByOutputType[P]>
        }
      >
    >


  export type ImpactComponentSelect = {
    id?: boolean
    code?: boolean
    impactComponents?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ImpactComponentGetPayload<S extends boolean | null | undefined | ImpactComponentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ImpactComponent :
    S extends undefined ? never :
    S extends { include: any } & (ImpactComponentArgs | ImpactComponentFindManyArgs)
    ? ImpactComponent 
    : S extends { select: any } & (ImpactComponentArgs | ImpactComponentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ImpactComponent ? ImpactComponent[P] : never
  } 
      : ImpactComponent


  type ImpactComponentCountArgs = 
    Omit<ImpactComponentFindManyArgs, 'select' | 'include'> & {
      select?: ImpactComponentCountAggregateInputType | true
    }

  export interface ImpactComponentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ImpactComponent that matches the filter.
     * @param {ImpactComponentFindUniqueArgs} args - Arguments to find a ImpactComponent
     * @example
     * // Get one ImpactComponent
     * const impactComponent = await prisma.impactComponent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImpactComponentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImpactComponentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ImpactComponent'> extends True ? Prisma__ImpactComponentClient<ImpactComponentGetPayload<T>> : Prisma__ImpactComponentClient<ImpactComponentGetPayload<T> | null, null>

    /**
     * Find one ImpactComponent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ImpactComponentFindUniqueOrThrowArgs} args - Arguments to find a ImpactComponent
     * @example
     * // Get one ImpactComponent
     * const impactComponent = await prisma.impactComponent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImpactComponentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImpactComponentFindUniqueOrThrowArgs>
    ): Prisma__ImpactComponentClient<ImpactComponentGetPayload<T>>

    /**
     * Find the first ImpactComponent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactComponentFindFirstArgs} args - Arguments to find a ImpactComponent
     * @example
     * // Get one ImpactComponent
     * const impactComponent = await prisma.impactComponent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImpactComponentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImpactComponentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ImpactComponent'> extends True ? Prisma__ImpactComponentClient<ImpactComponentGetPayload<T>> : Prisma__ImpactComponentClient<ImpactComponentGetPayload<T> | null, null>

    /**
     * Find the first ImpactComponent that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactComponentFindFirstOrThrowArgs} args - Arguments to find a ImpactComponent
     * @example
     * // Get one ImpactComponent
     * const impactComponent = await prisma.impactComponent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImpactComponentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImpactComponentFindFirstOrThrowArgs>
    ): Prisma__ImpactComponentClient<ImpactComponentGetPayload<T>>

    /**
     * Find zero or more ImpactComponents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactComponentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImpactComponents
     * const impactComponents = await prisma.impactComponent.findMany()
     * 
     * // Get first 10 ImpactComponents
     * const impactComponents = await prisma.impactComponent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impactComponentWithIdOnly = await prisma.impactComponent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImpactComponentFindManyArgs>(
      args?: SelectSubset<T, ImpactComponentFindManyArgs>
    ): Prisma.PrismaPromise<Array<ImpactComponentGetPayload<T>>>

    /**
     * Create a ImpactComponent.
     * @param {ImpactComponentCreateArgs} args - Arguments to create a ImpactComponent.
     * @example
     * // Create one ImpactComponent
     * const ImpactComponent = await prisma.impactComponent.create({
     *   data: {
     *     // ... data to create a ImpactComponent
     *   }
     * })
     * 
    **/
    create<T extends ImpactComponentCreateArgs>(
      args: SelectSubset<T, ImpactComponentCreateArgs>
    ): Prisma__ImpactComponentClient<ImpactComponentGetPayload<T>>

    /**
     * Create many ImpactComponents.
     *     @param {ImpactComponentCreateManyArgs} args - Arguments to create many ImpactComponents.
     *     @example
     *     // Create many ImpactComponents
     *     const impactComponent = await prisma.impactComponent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImpactComponentCreateManyArgs>(
      args?: SelectSubset<T, ImpactComponentCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImpactComponent.
     * @param {ImpactComponentDeleteArgs} args - Arguments to delete one ImpactComponent.
     * @example
     * // Delete one ImpactComponent
     * const ImpactComponent = await prisma.impactComponent.delete({
     *   where: {
     *     // ... filter to delete one ImpactComponent
     *   }
     * })
     * 
    **/
    delete<T extends ImpactComponentDeleteArgs>(
      args: SelectSubset<T, ImpactComponentDeleteArgs>
    ): Prisma__ImpactComponentClient<ImpactComponentGetPayload<T>>

    /**
     * Update one ImpactComponent.
     * @param {ImpactComponentUpdateArgs} args - Arguments to update one ImpactComponent.
     * @example
     * // Update one ImpactComponent
     * const impactComponent = await prisma.impactComponent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImpactComponentUpdateArgs>(
      args: SelectSubset<T, ImpactComponentUpdateArgs>
    ): Prisma__ImpactComponentClient<ImpactComponentGetPayload<T>>

    /**
     * Delete zero or more ImpactComponents.
     * @param {ImpactComponentDeleteManyArgs} args - Arguments to filter ImpactComponents to delete.
     * @example
     * // Delete a few ImpactComponents
     * const { count } = await prisma.impactComponent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImpactComponentDeleteManyArgs>(
      args?: SelectSubset<T, ImpactComponentDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImpactComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImpactComponents
     * const impactComponent = await prisma.impactComponent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImpactComponentUpdateManyArgs>(
      args: SelectSubset<T, ImpactComponentUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImpactComponent.
     * @param {ImpactComponentUpsertArgs} args - Arguments to update or create a ImpactComponent.
     * @example
     * // Update or create a ImpactComponent
     * const impactComponent = await prisma.impactComponent.upsert({
     *   create: {
     *     // ... data to create a ImpactComponent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImpactComponent we want to update
     *   }
     * })
    **/
    upsert<T extends ImpactComponentUpsertArgs>(
      args: SelectSubset<T, ImpactComponentUpsertArgs>
    ): Prisma__ImpactComponentClient<ImpactComponentGetPayload<T>>

    /**
     * Count the number of ImpactComponents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactComponentCountArgs} args - Arguments to filter ImpactComponents to count.
     * @example
     * // Count the number of ImpactComponents
     * const count = await prisma.impactComponent.count({
     *   where: {
     *     // ... the filter for the ImpactComponents we want to count
     *   }
     * })
    **/
    count<T extends ImpactComponentCountArgs>(
      args?: Subset<T, ImpactComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImpactComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImpactComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImpactComponentAggregateArgs>(args: Subset<T, ImpactComponentAggregateArgs>): Prisma.PrismaPromise<GetImpactComponentAggregateType<T>>

    /**
     * Group by ImpactComponent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpactComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImpactComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImpactComponentGroupByArgs['orderBy'] }
        : { orderBy?: ImpactComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImpactComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpactComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ImpactComponent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImpactComponentClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ImpactComponent base type for findUnique actions
   */
  export type ImpactComponentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * Filter, which ImpactComponent to fetch.
     */
    where: ImpactComponentWhereUniqueInput
  }

  /**
   * ImpactComponent findUnique
   */
  export interface ImpactComponentFindUniqueArgs extends ImpactComponentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImpactComponent findUniqueOrThrow
   */
  export type ImpactComponentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * Filter, which ImpactComponent to fetch.
     */
    where: ImpactComponentWhereUniqueInput
  }


  /**
   * ImpactComponent base type for findFirst actions
   */
  export type ImpactComponentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * Filter, which ImpactComponent to fetch.
     */
    where?: ImpactComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactComponents to fetch.
     */
    orderBy?: Enumerable<ImpactComponentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImpactComponents.
     */
    cursor?: ImpactComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImpactComponents.
     */
    distinct?: Enumerable<ImpactComponentScalarFieldEnum>
  }

  /**
   * ImpactComponent findFirst
   */
  export interface ImpactComponentFindFirstArgs extends ImpactComponentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ImpactComponent findFirstOrThrow
   */
  export type ImpactComponentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * Filter, which ImpactComponent to fetch.
     */
    where?: ImpactComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactComponents to fetch.
     */
    orderBy?: Enumerable<ImpactComponentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImpactComponents.
     */
    cursor?: ImpactComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactComponents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImpactComponents.
     */
    distinct?: Enumerable<ImpactComponentScalarFieldEnum>
  }


  /**
   * ImpactComponent findMany
   */
  export type ImpactComponentFindManyArgs = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * Filter, which ImpactComponents to fetch.
     */
    where?: ImpactComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImpactComponents to fetch.
     */
    orderBy?: Enumerable<ImpactComponentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImpactComponents.
     */
    cursor?: ImpactComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImpactComponents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImpactComponents.
     */
    skip?: number
    distinct?: Enumerable<ImpactComponentScalarFieldEnum>
  }


  /**
   * ImpactComponent create
   */
  export type ImpactComponentCreateArgs = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * The data needed to create a ImpactComponent.
     */
    data: XOR<ImpactComponentCreateInput, ImpactComponentUncheckedCreateInput>
  }


  /**
   * ImpactComponent createMany
   */
  export type ImpactComponentCreateManyArgs = {
    /**
     * The data used to create many ImpactComponents.
     */
    data: Enumerable<ImpactComponentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ImpactComponent update
   */
  export type ImpactComponentUpdateArgs = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * The data needed to update a ImpactComponent.
     */
    data: XOR<ImpactComponentUpdateInput, ImpactComponentUncheckedUpdateInput>
    /**
     * Choose, which ImpactComponent to update.
     */
    where: ImpactComponentWhereUniqueInput
  }


  /**
   * ImpactComponent updateMany
   */
  export type ImpactComponentUpdateManyArgs = {
    /**
     * The data used to update ImpactComponents.
     */
    data: XOR<ImpactComponentUpdateManyMutationInput, ImpactComponentUncheckedUpdateManyInput>
    /**
     * Filter which ImpactComponents to update
     */
    where?: ImpactComponentWhereInput
  }


  /**
   * ImpactComponent upsert
   */
  export type ImpactComponentUpsertArgs = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * The filter to search for the ImpactComponent to update in case it exists.
     */
    where: ImpactComponentWhereUniqueInput
    /**
     * In case the ImpactComponent found by the `where` argument doesn't exist, create a new ImpactComponent with this data.
     */
    create: XOR<ImpactComponentCreateInput, ImpactComponentUncheckedCreateInput>
    /**
     * In case the ImpactComponent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImpactComponentUpdateInput, ImpactComponentUncheckedUpdateInput>
  }


  /**
   * ImpactComponent delete
   */
  export type ImpactComponentDeleteArgs = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
    /**
     * Filter which ImpactComponent to delete.
     */
    where: ImpactComponentWhereUniqueInput
  }


  /**
   * ImpactComponent deleteMany
   */
  export type ImpactComponentDeleteManyArgs = {
    /**
     * Filter which ImpactComponents to delete
     */
    where?: ImpactComponentWhereInput
  }


  /**
   * ImpactComponent without action
   */
  export type ImpactComponentArgs = {
    /**
     * Select specific fields to fetch from the ImpactComponent
     */
    select?: ImpactComponentSelect | null
  }



  /**
   * Model Motivation
   */


  export type AggregateMotivation = {
    _count: MotivationCountAggregateOutputType | null
    _min: MotivationMinAggregateOutputType | null
    _max: MotivationMaxAggregateOutputType | null
  }

  export type MotivationMinAggregateOutputType = {
    id: string | null
    code: string | null
    hackerGroups: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MotivationMaxAggregateOutputType = {
    id: string | null
    code: string | null
    hackerGroups: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MotivationCountAggregateOutputType = {
    id: number
    code: number
    hackerGroups: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MotivationMinAggregateInputType = {
    id?: true
    code?: true
    hackerGroups?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MotivationMaxAggregateInputType = {
    id?: true
    code?: true
    hackerGroups?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MotivationCountAggregateInputType = {
    id?: true
    code?: true
    hackerGroups?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MotivationAggregateArgs = {
    /**
     * Filter which Motivation to aggregate.
     */
    where?: MotivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivations to fetch.
     */
    orderBy?: Enumerable<MotivationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MotivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Motivations
    **/
    _count?: true | MotivationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotivationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotivationMaxAggregateInputType
  }

  export type GetMotivationAggregateType<T extends MotivationAggregateArgs> = {
        [P in keyof T & keyof AggregateMotivation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMotivation[P]>
      : GetScalarType<T[P], AggregateMotivation[P]>
  }




  export type MotivationGroupByArgs = {
    where?: MotivationWhereInput
    orderBy?: Enumerable<MotivationOrderByWithAggregationInput>
    by: MotivationScalarFieldEnum[]
    having?: MotivationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotivationCountAggregateInputType | true
    _min?: MotivationMinAggregateInputType
    _max?: MotivationMaxAggregateInputType
  }


  export type MotivationGroupByOutputType = {
    id: string
    code: string
    hackerGroups: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MotivationCountAggregateOutputType | null
    _min: MotivationMinAggregateOutputType | null
    _max: MotivationMaxAggregateOutputType | null
  }

  type GetMotivationGroupByPayload<T extends MotivationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MotivationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotivationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotivationGroupByOutputType[P]>
            : GetScalarType<T[P], MotivationGroupByOutputType[P]>
        }
      >
    >


  export type MotivationSelect = {
    id?: boolean
    code?: boolean
    hackerGroups?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type MotivationGetPayload<S extends boolean | null | undefined | MotivationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Motivation :
    S extends undefined ? never :
    S extends { include: any } & (MotivationArgs | MotivationFindManyArgs)
    ? Motivation 
    : S extends { select: any } & (MotivationArgs | MotivationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Motivation ? Motivation[P] : never
  } 
      : Motivation


  type MotivationCountArgs = 
    Omit<MotivationFindManyArgs, 'select' | 'include'> & {
      select?: MotivationCountAggregateInputType | true
    }

  export interface MotivationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Motivation that matches the filter.
     * @param {MotivationFindUniqueArgs} args - Arguments to find a Motivation
     * @example
     * // Get one Motivation
     * const motivation = await prisma.motivation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MotivationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MotivationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Motivation'> extends True ? Prisma__MotivationClient<MotivationGetPayload<T>> : Prisma__MotivationClient<MotivationGetPayload<T> | null, null>

    /**
     * Find one Motivation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MotivationFindUniqueOrThrowArgs} args - Arguments to find a Motivation
     * @example
     * // Get one Motivation
     * const motivation = await prisma.motivation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MotivationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MotivationFindUniqueOrThrowArgs>
    ): Prisma__MotivationClient<MotivationGetPayload<T>>

    /**
     * Find the first Motivation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivationFindFirstArgs} args - Arguments to find a Motivation
     * @example
     * // Get one Motivation
     * const motivation = await prisma.motivation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MotivationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MotivationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Motivation'> extends True ? Prisma__MotivationClient<MotivationGetPayload<T>> : Prisma__MotivationClient<MotivationGetPayload<T> | null, null>

    /**
     * Find the first Motivation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivationFindFirstOrThrowArgs} args - Arguments to find a Motivation
     * @example
     * // Get one Motivation
     * const motivation = await prisma.motivation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MotivationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MotivationFindFirstOrThrowArgs>
    ): Prisma__MotivationClient<MotivationGetPayload<T>>

    /**
     * Find zero or more Motivations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motivations
     * const motivations = await prisma.motivation.findMany()
     * 
     * // Get first 10 Motivations
     * const motivations = await prisma.motivation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motivationWithIdOnly = await prisma.motivation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MotivationFindManyArgs>(
      args?: SelectSubset<T, MotivationFindManyArgs>
    ): Prisma.PrismaPromise<Array<MotivationGetPayload<T>>>

    /**
     * Create a Motivation.
     * @param {MotivationCreateArgs} args - Arguments to create a Motivation.
     * @example
     * // Create one Motivation
     * const Motivation = await prisma.motivation.create({
     *   data: {
     *     // ... data to create a Motivation
     *   }
     * })
     * 
    **/
    create<T extends MotivationCreateArgs>(
      args: SelectSubset<T, MotivationCreateArgs>
    ): Prisma__MotivationClient<MotivationGetPayload<T>>

    /**
     * Create many Motivations.
     *     @param {MotivationCreateManyArgs} args - Arguments to create many Motivations.
     *     @example
     *     // Create many Motivations
     *     const motivation = await prisma.motivation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MotivationCreateManyArgs>(
      args?: SelectSubset<T, MotivationCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Motivation.
     * @param {MotivationDeleteArgs} args - Arguments to delete one Motivation.
     * @example
     * // Delete one Motivation
     * const Motivation = await prisma.motivation.delete({
     *   where: {
     *     // ... filter to delete one Motivation
     *   }
     * })
     * 
    **/
    delete<T extends MotivationDeleteArgs>(
      args: SelectSubset<T, MotivationDeleteArgs>
    ): Prisma__MotivationClient<MotivationGetPayload<T>>

    /**
     * Update one Motivation.
     * @param {MotivationUpdateArgs} args - Arguments to update one Motivation.
     * @example
     * // Update one Motivation
     * const motivation = await prisma.motivation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MotivationUpdateArgs>(
      args: SelectSubset<T, MotivationUpdateArgs>
    ): Prisma__MotivationClient<MotivationGetPayload<T>>

    /**
     * Delete zero or more Motivations.
     * @param {MotivationDeleteManyArgs} args - Arguments to filter Motivations to delete.
     * @example
     * // Delete a few Motivations
     * const { count } = await prisma.motivation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MotivationDeleteManyArgs>(
      args?: SelectSubset<T, MotivationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motivations
     * const motivation = await prisma.motivation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MotivationUpdateManyArgs>(
      args: SelectSubset<T, MotivationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Motivation.
     * @param {MotivationUpsertArgs} args - Arguments to update or create a Motivation.
     * @example
     * // Update or create a Motivation
     * const motivation = await prisma.motivation.upsert({
     *   create: {
     *     // ... data to create a Motivation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Motivation we want to update
     *   }
     * })
    **/
    upsert<T extends MotivationUpsertArgs>(
      args: SelectSubset<T, MotivationUpsertArgs>
    ): Prisma__MotivationClient<MotivationGetPayload<T>>

    /**
     * Count the number of Motivations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivationCountArgs} args - Arguments to filter Motivations to count.
     * @example
     * // Count the number of Motivations
     * const count = await prisma.motivation.count({
     *   where: {
     *     // ... the filter for the Motivations we want to count
     *   }
     * })
    **/
    count<T extends MotivationCountArgs>(
      args?: Subset<T, MotivationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotivationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Motivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotivationAggregateArgs>(args: Subset<T, MotivationAggregateArgs>): Prisma.PrismaPromise<GetMotivationAggregateType<T>>

    /**
     * Group by Motivation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotivationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MotivationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MotivationGroupByArgs['orderBy'] }
        : { orderBy?: MotivationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MotivationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotivationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Motivation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MotivationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Motivation base type for findUnique actions
   */
  export type MotivationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * Filter, which Motivation to fetch.
     */
    where: MotivationWhereUniqueInput
  }

  /**
   * Motivation findUnique
   */
  export interface MotivationFindUniqueArgs extends MotivationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Motivation findUniqueOrThrow
   */
  export type MotivationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * Filter, which Motivation to fetch.
     */
    where: MotivationWhereUniqueInput
  }


  /**
   * Motivation base type for findFirst actions
   */
  export type MotivationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * Filter, which Motivation to fetch.
     */
    where?: MotivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivations to fetch.
     */
    orderBy?: Enumerable<MotivationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motivations.
     */
    cursor?: MotivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motivations.
     */
    distinct?: Enumerable<MotivationScalarFieldEnum>
  }

  /**
   * Motivation findFirst
   */
  export interface MotivationFindFirstArgs extends MotivationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Motivation findFirstOrThrow
   */
  export type MotivationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * Filter, which Motivation to fetch.
     */
    where?: MotivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivations to fetch.
     */
    orderBy?: Enumerable<MotivationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motivations.
     */
    cursor?: MotivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motivations.
     */
    distinct?: Enumerable<MotivationScalarFieldEnum>
  }


  /**
   * Motivation findMany
   */
  export type MotivationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * Filter, which Motivations to fetch.
     */
    where?: MotivationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motivations to fetch.
     */
    orderBy?: Enumerable<MotivationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Motivations.
     */
    cursor?: MotivationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motivations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motivations.
     */
    skip?: number
    distinct?: Enumerable<MotivationScalarFieldEnum>
  }


  /**
   * Motivation create
   */
  export type MotivationCreateArgs = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * The data needed to create a Motivation.
     */
    data: XOR<MotivationCreateInput, MotivationUncheckedCreateInput>
  }


  /**
   * Motivation createMany
   */
  export type MotivationCreateManyArgs = {
    /**
     * The data used to create many Motivations.
     */
    data: Enumerable<MotivationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Motivation update
   */
  export type MotivationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * The data needed to update a Motivation.
     */
    data: XOR<MotivationUpdateInput, MotivationUncheckedUpdateInput>
    /**
     * Choose, which Motivation to update.
     */
    where: MotivationWhereUniqueInput
  }


  /**
   * Motivation updateMany
   */
  export type MotivationUpdateManyArgs = {
    /**
     * The data used to update Motivations.
     */
    data: XOR<MotivationUpdateManyMutationInput, MotivationUncheckedUpdateManyInput>
    /**
     * Filter which Motivations to update
     */
    where?: MotivationWhereInput
  }


  /**
   * Motivation upsert
   */
  export type MotivationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * The filter to search for the Motivation to update in case it exists.
     */
    where: MotivationWhereUniqueInput
    /**
     * In case the Motivation found by the `where` argument doesn't exist, create a new Motivation with this data.
     */
    create: XOR<MotivationCreateInput, MotivationUncheckedCreateInput>
    /**
     * In case the Motivation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MotivationUpdateInput, MotivationUncheckedUpdateInput>
  }


  /**
   * Motivation delete
   */
  export type MotivationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
    /**
     * Filter which Motivation to delete.
     */
    where: MotivationWhereUniqueInput
  }


  /**
   * Motivation deleteMany
   */
  export type MotivationDeleteManyArgs = {
    /**
     * Filter which Motivations to delete
     */
    where?: MotivationWhereInput
  }


  /**
   * Motivation without action
   */
  export type MotivationArgs = {
    /**
     * Select specific fields to fetch from the Motivation
     */
    select?: MotivationSelect | null
  }



  /**
   * Model MethodViolator
   */


  export type AggregateMethodViolator = {
    _count: MethodViolatorCountAggregateOutputType | null
    _min: MethodViolatorMinAggregateOutputType | null
    _max: MethodViolatorMaxAggregateOutputType | null
  }

  export type MethodViolatorMinAggregateOutputType = {
    id: string | null
    techniqueCode: string | null
    nameTechnique: string | null
    MITRECode: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MethodViolatorMaxAggregateOutputType = {
    id: string | null
    techniqueCode: string | null
    nameTechnique: string | null
    MITRECode: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MethodViolatorCountAggregateOutputType = {
    id: number
    techniqueCode: number
    nameTechnique: number
    MITRECode: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MethodViolatorMinAggregateInputType = {
    id?: true
    techniqueCode?: true
    nameTechnique?: true
    MITRECode?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MethodViolatorMaxAggregateInputType = {
    id?: true
    techniqueCode?: true
    nameTechnique?: true
    MITRECode?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MethodViolatorCountAggregateInputType = {
    id?: true
    techniqueCode?: true
    nameTechnique?: true
    MITRECode?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MethodViolatorAggregateArgs = {
    /**
     * Filter which MethodViolator to aggregate.
     */
    where?: MethodViolatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodViolators to fetch.
     */
    orderBy?: Enumerable<MethodViolatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MethodViolatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodViolators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodViolators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MethodViolators
    **/
    _count?: true | MethodViolatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MethodViolatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MethodViolatorMaxAggregateInputType
  }

  export type GetMethodViolatorAggregateType<T extends MethodViolatorAggregateArgs> = {
        [P in keyof T & keyof AggregateMethodViolator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMethodViolator[P]>
      : GetScalarType<T[P], AggregateMethodViolator[P]>
  }




  export type MethodViolatorGroupByArgs = {
    where?: MethodViolatorWhereInput
    orderBy?: Enumerable<MethodViolatorOrderByWithAggregationInput>
    by: MethodViolatorScalarFieldEnum[]
    having?: MethodViolatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MethodViolatorCountAggregateInputType | true
    _min?: MethodViolatorMinAggregateInputType
    _max?: MethodViolatorMaxAggregateInputType
  }


  export type MethodViolatorGroupByOutputType = {
    id: string
    techniqueCode: string
    nameTechnique: string
    MITRECode: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MethodViolatorCountAggregateOutputType | null
    _min: MethodViolatorMinAggregateOutputType | null
    _max: MethodViolatorMaxAggregateOutputType | null
  }

  type GetMethodViolatorGroupByPayload<T extends MethodViolatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MethodViolatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MethodViolatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MethodViolatorGroupByOutputType[P]>
            : GetScalarType<T[P], MethodViolatorGroupByOutputType[P]>
        }
      >
    >


  export type MethodViolatorSelect = {
    id?: boolean
    techniqueCode?: boolean
    nameTechnique?: boolean
    MITRECode?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type MethodViolatorGetPayload<S extends boolean | null | undefined | MethodViolatorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MethodViolator :
    S extends undefined ? never :
    S extends { include: any } & (MethodViolatorArgs | MethodViolatorFindManyArgs)
    ? MethodViolator 
    : S extends { select: any } & (MethodViolatorArgs | MethodViolatorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MethodViolator ? MethodViolator[P] : never
  } 
      : MethodViolator


  type MethodViolatorCountArgs = 
    Omit<MethodViolatorFindManyArgs, 'select' | 'include'> & {
      select?: MethodViolatorCountAggregateInputType | true
    }

  export interface MethodViolatorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one MethodViolator that matches the filter.
     * @param {MethodViolatorFindUniqueArgs} args - Arguments to find a MethodViolator
     * @example
     * // Get one MethodViolator
     * const methodViolator = await prisma.methodViolator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MethodViolatorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MethodViolatorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MethodViolator'> extends True ? Prisma__MethodViolatorClient<MethodViolatorGetPayload<T>> : Prisma__MethodViolatorClient<MethodViolatorGetPayload<T> | null, null>

    /**
     * Find one MethodViolator that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MethodViolatorFindUniqueOrThrowArgs} args - Arguments to find a MethodViolator
     * @example
     * // Get one MethodViolator
     * const methodViolator = await prisma.methodViolator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MethodViolatorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, MethodViolatorFindUniqueOrThrowArgs>
    ): Prisma__MethodViolatorClient<MethodViolatorGetPayload<T>>

    /**
     * Find the first MethodViolator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodViolatorFindFirstArgs} args - Arguments to find a MethodViolator
     * @example
     * // Get one MethodViolator
     * const methodViolator = await prisma.methodViolator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MethodViolatorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MethodViolatorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MethodViolator'> extends True ? Prisma__MethodViolatorClient<MethodViolatorGetPayload<T>> : Prisma__MethodViolatorClient<MethodViolatorGetPayload<T> | null, null>

    /**
     * Find the first MethodViolator that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodViolatorFindFirstOrThrowArgs} args - Arguments to find a MethodViolator
     * @example
     * // Get one MethodViolator
     * const methodViolator = await prisma.methodViolator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MethodViolatorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MethodViolatorFindFirstOrThrowArgs>
    ): Prisma__MethodViolatorClient<MethodViolatorGetPayload<T>>

    /**
     * Find zero or more MethodViolators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodViolatorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MethodViolators
     * const methodViolators = await prisma.methodViolator.findMany()
     * 
     * // Get first 10 MethodViolators
     * const methodViolators = await prisma.methodViolator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const methodViolatorWithIdOnly = await prisma.methodViolator.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MethodViolatorFindManyArgs>(
      args?: SelectSubset<T, MethodViolatorFindManyArgs>
    ): Prisma.PrismaPromise<Array<MethodViolatorGetPayload<T>>>

    /**
     * Create a MethodViolator.
     * @param {MethodViolatorCreateArgs} args - Arguments to create a MethodViolator.
     * @example
     * // Create one MethodViolator
     * const MethodViolator = await prisma.methodViolator.create({
     *   data: {
     *     // ... data to create a MethodViolator
     *   }
     * })
     * 
    **/
    create<T extends MethodViolatorCreateArgs>(
      args: SelectSubset<T, MethodViolatorCreateArgs>
    ): Prisma__MethodViolatorClient<MethodViolatorGetPayload<T>>

    /**
     * Create many MethodViolators.
     *     @param {MethodViolatorCreateManyArgs} args - Arguments to create many MethodViolators.
     *     @example
     *     // Create many MethodViolators
     *     const methodViolator = await prisma.methodViolator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MethodViolatorCreateManyArgs>(
      args?: SelectSubset<T, MethodViolatorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MethodViolator.
     * @param {MethodViolatorDeleteArgs} args - Arguments to delete one MethodViolator.
     * @example
     * // Delete one MethodViolator
     * const MethodViolator = await prisma.methodViolator.delete({
     *   where: {
     *     // ... filter to delete one MethodViolator
     *   }
     * })
     * 
    **/
    delete<T extends MethodViolatorDeleteArgs>(
      args: SelectSubset<T, MethodViolatorDeleteArgs>
    ): Prisma__MethodViolatorClient<MethodViolatorGetPayload<T>>

    /**
     * Update one MethodViolator.
     * @param {MethodViolatorUpdateArgs} args - Arguments to update one MethodViolator.
     * @example
     * // Update one MethodViolator
     * const methodViolator = await prisma.methodViolator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MethodViolatorUpdateArgs>(
      args: SelectSubset<T, MethodViolatorUpdateArgs>
    ): Prisma__MethodViolatorClient<MethodViolatorGetPayload<T>>

    /**
     * Delete zero or more MethodViolators.
     * @param {MethodViolatorDeleteManyArgs} args - Arguments to filter MethodViolators to delete.
     * @example
     * // Delete a few MethodViolators
     * const { count } = await prisma.methodViolator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MethodViolatorDeleteManyArgs>(
      args?: SelectSubset<T, MethodViolatorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MethodViolators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodViolatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MethodViolators
     * const methodViolator = await prisma.methodViolator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MethodViolatorUpdateManyArgs>(
      args: SelectSubset<T, MethodViolatorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MethodViolator.
     * @param {MethodViolatorUpsertArgs} args - Arguments to update or create a MethodViolator.
     * @example
     * // Update or create a MethodViolator
     * const methodViolator = await prisma.methodViolator.upsert({
     *   create: {
     *     // ... data to create a MethodViolator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MethodViolator we want to update
     *   }
     * })
    **/
    upsert<T extends MethodViolatorUpsertArgs>(
      args: SelectSubset<T, MethodViolatorUpsertArgs>
    ): Prisma__MethodViolatorClient<MethodViolatorGetPayload<T>>

    /**
     * Count the number of MethodViolators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodViolatorCountArgs} args - Arguments to filter MethodViolators to count.
     * @example
     * // Count the number of MethodViolators
     * const count = await prisma.methodViolator.count({
     *   where: {
     *     // ... the filter for the MethodViolators we want to count
     *   }
     * })
    **/
    count<T extends MethodViolatorCountArgs>(
      args?: Subset<T, MethodViolatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MethodViolatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MethodViolator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodViolatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MethodViolatorAggregateArgs>(args: Subset<T, MethodViolatorAggregateArgs>): Prisma.PrismaPromise<GetMethodViolatorAggregateType<T>>

    /**
     * Group by MethodViolator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MethodViolatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MethodViolatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MethodViolatorGroupByArgs['orderBy'] }
        : { orderBy?: MethodViolatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MethodViolatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMethodViolatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for MethodViolator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MethodViolatorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * MethodViolator base type for findUnique actions
   */
  export type MethodViolatorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * Filter, which MethodViolator to fetch.
     */
    where: MethodViolatorWhereUniqueInput
  }

  /**
   * MethodViolator findUnique
   */
  export interface MethodViolatorFindUniqueArgs extends MethodViolatorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MethodViolator findUniqueOrThrow
   */
  export type MethodViolatorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * Filter, which MethodViolator to fetch.
     */
    where: MethodViolatorWhereUniqueInput
  }


  /**
   * MethodViolator base type for findFirst actions
   */
  export type MethodViolatorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * Filter, which MethodViolator to fetch.
     */
    where?: MethodViolatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodViolators to fetch.
     */
    orderBy?: Enumerable<MethodViolatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MethodViolators.
     */
    cursor?: MethodViolatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodViolators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodViolators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MethodViolators.
     */
    distinct?: Enumerable<MethodViolatorScalarFieldEnum>
  }

  /**
   * MethodViolator findFirst
   */
  export interface MethodViolatorFindFirstArgs extends MethodViolatorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * MethodViolator findFirstOrThrow
   */
  export type MethodViolatorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * Filter, which MethodViolator to fetch.
     */
    where?: MethodViolatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodViolators to fetch.
     */
    orderBy?: Enumerable<MethodViolatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MethodViolators.
     */
    cursor?: MethodViolatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodViolators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodViolators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MethodViolators.
     */
    distinct?: Enumerable<MethodViolatorScalarFieldEnum>
  }


  /**
   * MethodViolator findMany
   */
  export type MethodViolatorFindManyArgs = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * Filter, which MethodViolators to fetch.
     */
    where?: MethodViolatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MethodViolators to fetch.
     */
    orderBy?: Enumerable<MethodViolatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MethodViolators.
     */
    cursor?: MethodViolatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MethodViolators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MethodViolators.
     */
    skip?: number
    distinct?: Enumerable<MethodViolatorScalarFieldEnum>
  }


  /**
   * MethodViolator create
   */
  export type MethodViolatorCreateArgs = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * The data needed to create a MethodViolator.
     */
    data: XOR<MethodViolatorCreateInput, MethodViolatorUncheckedCreateInput>
  }


  /**
   * MethodViolator createMany
   */
  export type MethodViolatorCreateManyArgs = {
    /**
     * The data used to create many MethodViolators.
     */
    data: Enumerable<MethodViolatorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MethodViolator update
   */
  export type MethodViolatorUpdateArgs = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * The data needed to update a MethodViolator.
     */
    data: XOR<MethodViolatorUpdateInput, MethodViolatorUncheckedUpdateInput>
    /**
     * Choose, which MethodViolator to update.
     */
    where: MethodViolatorWhereUniqueInput
  }


  /**
   * MethodViolator updateMany
   */
  export type MethodViolatorUpdateManyArgs = {
    /**
     * The data used to update MethodViolators.
     */
    data: XOR<MethodViolatorUpdateManyMutationInput, MethodViolatorUncheckedUpdateManyInput>
    /**
     * Filter which MethodViolators to update
     */
    where?: MethodViolatorWhereInput
  }


  /**
   * MethodViolator upsert
   */
  export type MethodViolatorUpsertArgs = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * The filter to search for the MethodViolator to update in case it exists.
     */
    where: MethodViolatorWhereUniqueInput
    /**
     * In case the MethodViolator found by the `where` argument doesn't exist, create a new MethodViolator with this data.
     */
    create: XOR<MethodViolatorCreateInput, MethodViolatorUncheckedCreateInput>
    /**
     * In case the MethodViolator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MethodViolatorUpdateInput, MethodViolatorUncheckedUpdateInput>
  }


  /**
   * MethodViolator delete
   */
  export type MethodViolatorDeleteArgs = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
    /**
     * Filter which MethodViolator to delete.
     */
    where: MethodViolatorWhereUniqueInput
  }


  /**
   * MethodViolator deleteMany
   */
  export type MethodViolatorDeleteManyArgs = {
    /**
     * Filter which MethodViolators to delete
     */
    where?: MethodViolatorWhereInput
  }


  /**
   * MethodViolator without action
   */
  export type MethodViolatorArgs = {
    /**
     * Select specific fields to fetch from the MethodViolator
     */
    select?: MethodViolatorSelect | null
  }



  /**
   * Model TacticsViolator
   */


  export type AggregateTacticsViolator = {
    _count: TacticsViolatorCountAggregateOutputType | null
    _min: TacticsViolatorMinAggregateOutputType | null
    _max: TacticsViolatorMaxAggregateOutputType | null
  }

  export type TacticsViolatorMinAggregateOutputType = {
    id: string | null
    code: string | null
    objectAttack: string | null
    stages: string | null
    description: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TacticsViolatorMaxAggregateOutputType = {
    id: string | null
    code: string | null
    objectAttack: string | null
    stages: string | null
    description: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TacticsViolatorCountAggregateOutputType = {
    id: number
    code: number
    objectAttack: number
    stages: number
    description: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TacticsViolatorMinAggregateInputType = {
    id?: true
    code?: true
    objectAttack?: true
    stages?: true
    description?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TacticsViolatorMaxAggregateInputType = {
    id?: true
    code?: true
    objectAttack?: true
    stages?: true
    description?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TacticsViolatorCountAggregateInputType = {
    id?: true
    code?: true
    objectAttack?: true
    stages?: true
    description?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TacticsViolatorAggregateArgs = {
    /**
     * Filter which TacticsViolator to aggregate.
     */
    where?: TacticsViolatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TacticsViolators to fetch.
     */
    orderBy?: Enumerable<TacticsViolatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TacticsViolatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TacticsViolators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TacticsViolators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TacticsViolators
    **/
    _count?: true | TacticsViolatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TacticsViolatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TacticsViolatorMaxAggregateInputType
  }

  export type GetTacticsViolatorAggregateType<T extends TacticsViolatorAggregateArgs> = {
        [P in keyof T & keyof AggregateTacticsViolator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTacticsViolator[P]>
      : GetScalarType<T[P], AggregateTacticsViolator[P]>
  }




  export type TacticsViolatorGroupByArgs = {
    where?: TacticsViolatorWhereInput
    orderBy?: Enumerable<TacticsViolatorOrderByWithAggregationInput>
    by: TacticsViolatorScalarFieldEnum[]
    having?: TacticsViolatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TacticsViolatorCountAggregateInputType | true
    _min?: TacticsViolatorMinAggregateInputType
    _max?: TacticsViolatorMaxAggregateInputType
  }


  export type TacticsViolatorGroupByOutputType = {
    id: string
    code: string
    objectAttack: string
    stages: string
    description: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TacticsViolatorCountAggregateOutputType | null
    _min: TacticsViolatorMinAggregateOutputType | null
    _max: TacticsViolatorMaxAggregateOutputType | null
  }

  type GetTacticsViolatorGroupByPayload<T extends TacticsViolatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TacticsViolatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TacticsViolatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TacticsViolatorGroupByOutputType[P]>
            : GetScalarType<T[P], TacticsViolatorGroupByOutputType[P]>
        }
      >
    >


  export type TacticsViolatorSelect = {
    id?: boolean
    code?: boolean
    objectAttack?: boolean
    stages?: boolean
    description?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TacticsViolatorGetPayload<S extends boolean | null | undefined | TacticsViolatorArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TacticsViolator :
    S extends undefined ? never :
    S extends { include: any } & (TacticsViolatorArgs | TacticsViolatorFindManyArgs)
    ? TacticsViolator 
    : S extends { select: any } & (TacticsViolatorArgs | TacticsViolatorFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TacticsViolator ? TacticsViolator[P] : never
  } 
      : TacticsViolator


  type TacticsViolatorCountArgs = 
    Omit<TacticsViolatorFindManyArgs, 'select' | 'include'> & {
      select?: TacticsViolatorCountAggregateInputType | true
    }

  export interface TacticsViolatorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TacticsViolator that matches the filter.
     * @param {TacticsViolatorFindUniqueArgs} args - Arguments to find a TacticsViolator
     * @example
     * // Get one TacticsViolator
     * const tacticsViolator = await prisma.tacticsViolator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TacticsViolatorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TacticsViolatorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TacticsViolator'> extends True ? Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T>> : Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T> | null, null>

    /**
     * Find one TacticsViolator that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TacticsViolatorFindUniqueOrThrowArgs} args - Arguments to find a TacticsViolator
     * @example
     * // Get one TacticsViolator
     * const tacticsViolator = await prisma.tacticsViolator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TacticsViolatorFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TacticsViolatorFindUniqueOrThrowArgs>
    ): Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T>>

    /**
     * Find the first TacticsViolator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacticsViolatorFindFirstArgs} args - Arguments to find a TacticsViolator
     * @example
     * // Get one TacticsViolator
     * const tacticsViolator = await prisma.tacticsViolator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TacticsViolatorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TacticsViolatorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TacticsViolator'> extends True ? Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T>> : Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T> | null, null>

    /**
     * Find the first TacticsViolator that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacticsViolatorFindFirstOrThrowArgs} args - Arguments to find a TacticsViolator
     * @example
     * // Get one TacticsViolator
     * const tacticsViolator = await prisma.tacticsViolator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TacticsViolatorFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TacticsViolatorFindFirstOrThrowArgs>
    ): Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T>>

    /**
     * Find zero or more TacticsViolators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacticsViolatorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TacticsViolators
     * const tacticsViolators = await prisma.tacticsViolator.findMany()
     * 
     * // Get first 10 TacticsViolators
     * const tacticsViolators = await prisma.tacticsViolator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tacticsViolatorWithIdOnly = await prisma.tacticsViolator.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TacticsViolatorFindManyArgs>(
      args?: SelectSubset<T, TacticsViolatorFindManyArgs>
    ): Prisma.PrismaPromise<Array<TacticsViolatorGetPayload<T>>>

    /**
     * Create a TacticsViolator.
     * @param {TacticsViolatorCreateArgs} args - Arguments to create a TacticsViolator.
     * @example
     * // Create one TacticsViolator
     * const TacticsViolator = await prisma.tacticsViolator.create({
     *   data: {
     *     // ... data to create a TacticsViolator
     *   }
     * })
     * 
    **/
    create<T extends TacticsViolatorCreateArgs>(
      args: SelectSubset<T, TacticsViolatorCreateArgs>
    ): Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T>>

    /**
     * Create many TacticsViolators.
     *     @param {TacticsViolatorCreateManyArgs} args - Arguments to create many TacticsViolators.
     *     @example
     *     // Create many TacticsViolators
     *     const tacticsViolator = await prisma.tacticsViolator.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TacticsViolatorCreateManyArgs>(
      args?: SelectSubset<T, TacticsViolatorCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TacticsViolator.
     * @param {TacticsViolatorDeleteArgs} args - Arguments to delete one TacticsViolator.
     * @example
     * // Delete one TacticsViolator
     * const TacticsViolator = await prisma.tacticsViolator.delete({
     *   where: {
     *     // ... filter to delete one TacticsViolator
     *   }
     * })
     * 
    **/
    delete<T extends TacticsViolatorDeleteArgs>(
      args: SelectSubset<T, TacticsViolatorDeleteArgs>
    ): Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T>>

    /**
     * Update one TacticsViolator.
     * @param {TacticsViolatorUpdateArgs} args - Arguments to update one TacticsViolator.
     * @example
     * // Update one TacticsViolator
     * const tacticsViolator = await prisma.tacticsViolator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TacticsViolatorUpdateArgs>(
      args: SelectSubset<T, TacticsViolatorUpdateArgs>
    ): Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T>>

    /**
     * Delete zero or more TacticsViolators.
     * @param {TacticsViolatorDeleteManyArgs} args - Arguments to filter TacticsViolators to delete.
     * @example
     * // Delete a few TacticsViolators
     * const { count } = await prisma.tacticsViolator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TacticsViolatorDeleteManyArgs>(
      args?: SelectSubset<T, TacticsViolatorDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TacticsViolators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacticsViolatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TacticsViolators
     * const tacticsViolator = await prisma.tacticsViolator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TacticsViolatorUpdateManyArgs>(
      args: SelectSubset<T, TacticsViolatorUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TacticsViolator.
     * @param {TacticsViolatorUpsertArgs} args - Arguments to update or create a TacticsViolator.
     * @example
     * // Update or create a TacticsViolator
     * const tacticsViolator = await prisma.tacticsViolator.upsert({
     *   create: {
     *     // ... data to create a TacticsViolator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TacticsViolator we want to update
     *   }
     * })
    **/
    upsert<T extends TacticsViolatorUpsertArgs>(
      args: SelectSubset<T, TacticsViolatorUpsertArgs>
    ): Prisma__TacticsViolatorClient<TacticsViolatorGetPayload<T>>

    /**
     * Count the number of TacticsViolators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacticsViolatorCountArgs} args - Arguments to filter TacticsViolators to count.
     * @example
     * // Count the number of TacticsViolators
     * const count = await prisma.tacticsViolator.count({
     *   where: {
     *     // ... the filter for the TacticsViolators we want to count
     *   }
     * })
    **/
    count<T extends TacticsViolatorCountArgs>(
      args?: Subset<T, TacticsViolatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TacticsViolatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TacticsViolator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacticsViolatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TacticsViolatorAggregateArgs>(args: Subset<T, TacticsViolatorAggregateArgs>): Prisma.PrismaPromise<GetTacticsViolatorAggregateType<T>>

    /**
     * Group by TacticsViolator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TacticsViolatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TacticsViolatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TacticsViolatorGroupByArgs['orderBy'] }
        : { orderBy?: TacticsViolatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TacticsViolatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTacticsViolatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TacticsViolator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TacticsViolatorClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TacticsViolator base type for findUnique actions
   */
  export type TacticsViolatorFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * Filter, which TacticsViolator to fetch.
     */
    where: TacticsViolatorWhereUniqueInput
  }

  /**
   * TacticsViolator findUnique
   */
  export interface TacticsViolatorFindUniqueArgs extends TacticsViolatorFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TacticsViolator findUniqueOrThrow
   */
  export type TacticsViolatorFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * Filter, which TacticsViolator to fetch.
     */
    where: TacticsViolatorWhereUniqueInput
  }


  /**
   * TacticsViolator base type for findFirst actions
   */
  export type TacticsViolatorFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * Filter, which TacticsViolator to fetch.
     */
    where?: TacticsViolatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TacticsViolators to fetch.
     */
    orderBy?: Enumerable<TacticsViolatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TacticsViolators.
     */
    cursor?: TacticsViolatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TacticsViolators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TacticsViolators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TacticsViolators.
     */
    distinct?: Enumerable<TacticsViolatorScalarFieldEnum>
  }

  /**
   * TacticsViolator findFirst
   */
  export interface TacticsViolatorFindFirstArgs extends TacticsViolatorFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TacticsViolator findFirstOrThrow
   */
  export type TacticsViolatorFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * Filter, which TacticsViolator to fetch.
     */
    where?: TacticsViolatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TacticsViolators to fetch.
     */
    orderBy?: Enumerable<TacticsViolatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TacticsViolators.
     */
    cursor?: TacticsViolatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TacticsViolators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TacticsViolators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TacticsViolators.
     */
    distinct?: Enumerable<TacticsViolatorScalarFieldEnum>
  }


  /**
   * TacticsViolator findMany
   */
  export type TacticsViolatorFindManyArgs = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * Filter, which TacticsViolators to fetch.
     */
    where?: TacticsViolatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TacticsViolators to fetch.
     */
    orderBy?: Enumerable<TacticsViolatorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TacticsViolators.
     */
    cursor?: TacticsViolatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TacticsViolators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TacticsViolators.
     */
    skip?: number
    distinct?: Enumerable<TacticsViolatorScalarFieldEnum>
  }


  /**
   * TacticsViolator create
   */
  export type TacticsViolatorCreateArgs = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * The data needed to create a TacticsViolator.
     */
    data: XOR<TacticsViolatorCreateInput, TacticsViolatorUncheckedCreateInput>
  }


  /**
   * TacticsViolator createMany
   */
  export type TacticsViolatorCreateManyArgs = {
    /**
     * The data used to create many TacticsViolators.
     */
    data: Enumerable<TacticsViolatorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TacticsViolator update
   */
  export type TacticsViolatorUpdateArgs = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * The data needed to update a TacticsViolator.
     */
    data: XOR<TacticsViolatorUpdateInput, TacticsViolatorUncheckedUpdateInput>
    /**
     * Choose, which TacticsViolator to update.
     */
    where: TacticsViolatorWhereUniqueInput
  }


  /**
   * TacticsViolator updateMany
   */
  export type TacticsViolatorUpdateManyArgs = {
    /**
     * The data used to update TacticsViolators.
     */
    data: XOR<TacticsViolatorUpdateManyMutationInput, TacticsViolatorUncheckedUpdateManyInput>
    /**
     * Filter which TacticsViolators to update
     */
    where?: TacticsViolatorWhereInput
  }


  /**
   * TacticsViolator upsert
   */
  export type TacticsViolatorUpsertArgs = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * The filter to search for the TacticsViolator to update in case it exists.
     */
    where: TacticsViolatorWhereUniqueInput
    /**
     * In case the TacticsViolator found by the `where` argument doesn't exist, create a new TacticsViolator with this data.
     */
    create: XOR<TacticsViolatorCreateInput, TacticsViolatorUncheckedCreateInput>
    /**
     * In case the TacticsViolator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TacticsViolatorUpdateInput, TacticsViolatorUncheckedUpdateInput>
  }


  /**
   * TacticsViolator delete
   */
  export type TacticsViolatorDeleteArgs = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
    /**
     * Filter which TacticsViolator to delete.
     */
    where: TacticsViolatorWhereUniqueInput
  }


  /**
   * TacticsViolator deleteMany
   */
  export type TacticsViolatorDeleteManyArgs = {
    /**
     * Filter which TacticsViolators to delete
     */
    where?: TacticsViolatorWhereInput
  }


  /**
   * TacticsViolator without action
   */
  export type TacticsViolatorArgs = {
    /**
     * Select specific fields to fetch from the TacticsViolator
     */
    select?: TacticsViolatorSelect | null
  }



  /**
   * Model TypicalThreat
   */


  export type AggregateTypicalThreat = {
    _count: TypicalThreatCountAggregateOutputType | null
    _min: TypicalThreatMinAggregateOutputType | null
    _max: TypicalThreatMaxAggregateOutputType | null
  }

  export type TypicalThreatMinAggregateOutputType = {
    id: string | null
    gangTools: string | null
    toolType: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypicalThreatMaxAggregateOutputType = {
    id: string | null
    gangTools: string | null
    toolType: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TypicalThreatCountAggregateOutputType = {
    id: number
    gangTools: number
    toolType: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TypicalThreatMinAggregateInputType = {
    id?: true
    gangTools?: true
    toolType?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypicalThreatMaxAggregateInputType = {
    id?: true
    gangTools?: true
    toolType?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TypicalThreatCountAggregateInputType = {
    id?: true
    gangTools?: true
    toolType?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TypicalThreatAggregateArgs = {
    /**
     * Filter which TypicalThreat to aggregate.
     */
    where?: TypicalThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypicalThreats to fetch.
     */
    orderBy?: Enumerable<TypicalThreatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypicalThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypicalThreats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypicalThreats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypicalThreats
    **/
    _count?: true | TypicalThreatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypicalThreatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypicalThreatMaxAggregateInputType
  }

  export type GetTypicalThreatAggregateType<T extends TypicalThreatAggregateArgs> = {
        [P in keyof T & keyof AggregateTypicalThreat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypicalThreat[P]>
      : GetScalarType<T[P], AggregateTypicalThreat[P]>
  }




  export type TypicalThreatGroupByArgs = {
    where?: TypicalThreatWhereInput
    orderBy?: Enumerable<TypicalThreatOrderByWithAggregationInput>
    by: TypicalThreatScalarFieldEnum[]
    having?: TypicalThreatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypicalThreatCountAggregateInputType | true
    _min?: TypicalThreatMinAggregateInputType
    _max?: TypicalThreatMaxAggregateInputType
  }


  export type TypicalThreatGroupByOutputType = {
    id: string
    gangTools: string
    toolType: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TypicalThreatCountAggregateOutputType | null
    _min: TypicalThreatMinAggregateOutputType | null
    _max: TypicalThreatMaxAggregateOutputType | null
  }

  type GetTypicalThreatGroupByPayload<T extends TypicalThreatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TypicalThreatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypicalThreatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypicalThreatGroupByOutputType[P]>
            : GetScalarType<T[P], TypicalThreatGroupByOutputType[P]>
        }
      >
    >


  export type TypicalThreatSelect = {
    id?: boolean
    gangTools?: boolean
    toolType?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type TypicalThreatGetPayload<S extends boolean | null | undefined | TypicalThreatArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TypicalThreat :
    S extends undefined ? never :
    S extends { include: any } & (TypicalThreatArgs | TypicalThreatFindManyArgs)
    ? TypicalThreat 
    : S extends { select: any } & (TypicalThreatArgs | TypicalThreatFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TypicalThreat ? TypicalThreat[P] : never
  } 
      : TypicalThreat


  type TypicalThreatCountArgs = 
    Omit<TypicalThreatFindManyArgs, 'select' | 'include'> & {
      select?: TypicalThreatCountAggregateInputType | true
    }

  export interface TypicalThreatDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TypicalThreat that matches the filter.
     * @param {TypicalThreatFindUniqueArgs} args - Arguments to find a TypicalThreat
     * @example
     * // Get one TypicalThreat
     * const typicalThreat = await prisma.typicalThreat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypicalThreatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TypicalThreatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TypicalThreat'> extends True ? Prisma__TypicalThreatClient<TypicalThreatGetPayload<T>> : Prisma__TypicalThreatClient<TypicalThreatGetPayload<T> | null, null>

    /**
     * Find one TypicalThreat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TypicalThreatFindUniqueOrThrowArgs} args - Arguments to find a TypicalThreat
     * @example
     * // Get one TypicalThreat
     * const typicalThreat = await prisma.typicalThreat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypicalThreatFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TypicalThreatFindUniqueOrThrowArgs>
    ): Prisma__TypicalThreatClient<TypicalThreatGetPayload<T>>

    /**
     * Find the first TypicalThreat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypicalThreatFindFirstArgs} args - Arguments to find a TypicalThreat
     * @example
     * // Get one TypicalThreat
     * const typicalThreat = await prisma.typicalThreat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypicalThreatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TypicalThreatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TypicalThreat'> extends True ? Prisma__TypicalThreatClient<TypicalThreatGetPayload<T>> : Prisma__TypicalThreatClient<TypicalThreatGetPayload<T> | null, null>

    /**
     * Find the first TypicalThreat that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypicalThreatFindFirstOrThrowArgs} args - Arguments to find a TypicalThreat
     * @example
     * // Get one TypicalThreat
     * const typicalThreat = await prisma.typicalThreat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypicalThreatFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TypicalThreatFindFirstOrThrowArgs>
    ): Prisma__TypicalThreatClient<TypicalThreatGetPayload<T>>

    /**
     * Find zero or more TypicalThreats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypicalThreatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypicalThreats
     * const typicalThreats = await prisma.typicalThreat.findMany()
     * 
     * // Get first 10 TypicalThreats
     * const typicalThreats = await prisma.typicalThreat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typicalThreatWithIdOnly = await prisma.typicalThreat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TypicalThreatFindManyArgs>(
      args?: SelectSubset<T, TypicalThreatFindManyArgs>
    ): Prisma.PrismaPromise<Array<TypicalThreatGetPayload<T>>>

    /**
     * Create a TypicalThreat.
     * @param {TypicalThreatCreateArgs} args - Arguments to create a TypicalThreat.
     * @example
     * // Create one TypicalThreat
     * const TypicalThreat = await prisma.typicalThreat.create({
     *   data: {
     *     // ... data to create a TypicalThreat
     *   }
     * })
     * 
    **/
    create<T extends TypicalThreatCreateArgs>(
      args: SelectSubset<T, TypicalThreatCreateArgs>
    ): Prisma__TypicalThreatClient<TypicalThreatGetPayload<T>>

    /**
     * Create many TypicalThreats.
     *     @param {TypicalThreatCreateManyArgs} args - Arguments to create many TypicalThreats.
     *     @example
     *     // Create many TypicalThreats
     *     const typicalThreat = await prisma.typicalThreat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TypicalThreatCreateManyArgs>(
      args?: SelectSubset<T, TypicalThreatCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypicalThreat.
     * @param {TypicalThreatDeleteArgs} args - Arguments to delete one TypicalThreat.
     * @example
     * // Delete one TypicalThreat
     * const TypicalThreat = await prisma.typicalThreat.delete({
     *   where: {
     *     // ... filter to delete one TypicalThreat
     *   }
     * })
     * 
    **/
    delete<T extends TypicalThreatDeleteArgs>(
      args: SelectSubset<T, TypicalThreatDeleteArgs>
    ): Prisma__TypicalThreatClient<TypicalThreatGetPayload<T>>

    /**
     * Update one TypicalThreat.
     * @param {TypicalThreatUpdateArgs} args - Arguments to update one TypicalThreat.
     * @example
     * // Update one TypicalThreat
     * const typicalThreat = await prisma.typicalThreat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypicalThreatUpdateArgs>(
      args: SelectSubset<T, TypicalThreatUpdateArgs>
    ): Prisma__TypicalThreatClient<TypicalThreatGetPayload<T>>

    /**
     * Delete zero or more TypicalThreats.
     * @param {TypicalThreatDeleteManyArgs} args - Arguments to filter TypicalThreats to delete.
     * @example
     * // Delete a few TypicalThreats
     * const { count } = await prisma.typicalThreat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypicalThreatDeleteManyArgs>(
      args?: SelectSubset<T, TypicalThreatDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypicalThreats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypicalThreatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypicalThreats
     * const typicalThreat = await prisma.typicalThreat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypicalThreatUpdateManyArgs>(
      args: SelectSubset<T, TypicalThreatUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypicalThreat.
     * @param {TypicalThreatUpsertArgs} args - Arguments to update or create a TypicalThreat.
     * @example
     * // Update or create a TypicalThreat
     * const typicalThreat = await prisma.typicalThreat.upsert({
     *   create: {
     *     // ... data to create a TypicalThreat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypicalThreat we want to update
     *   }
     * })
    **/
    upsert<T extends TypicalThreatUpsertArgs>(
      args: SelectSubset<T, TypicalThreatUpsertArgs>
    ): Prisma__TypicalThreatClient<TypicalThreatGetPayload<T>>

    /**
     * Count the number of TypicalThreats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypicalThreatCountArgs} args - Arguments to filter TypicalThreats to count.
     * @example
     * // Count the number of TypicalThreats
     * const count = await prisma.typicalThreat.count({
     *   where: {
     *     // ... the filter for the TypicalThreats we want to count
     *   }
     * })
    **/
    count<T extends TypicalThreatCountArgs>(
      args?: Subset<T, TypicalThreatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypicalThreatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypicalThreat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypicalThreatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypicalThreatAggregateArgs>(args: Subset<T, TypicalThreatAggregateArgs>): Prisma.PrismaPromise<GetTypicalThreatAggregateType<T>>

    /**
     * Group by TypicalThreat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypicalThreatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypicalThreatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypicalThreatGroupByArgs['orderBy'] }
        : { orderBy?: TypicalThreatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypicalThreatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypicalThreatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TypicalThreat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TypicalThreatClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TypicalThreat base type for findUnique actions
   */
  export type TypicalThreatFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * Filter, which TypicalThreat to fetch.
     */
    where: TypicalThreatWhereUniqueInput
  }

  /**
   * TypicalThreat findUnique
   */
  export interface TypicalThreatFindUniqueArgs extends TypicalThreatFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypicalThreat findUniqueOrThrow
   */
  export type TypicalThreatFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * Filter, which TypicalThreat to fetch.
     */
    where: TypicalThreatWhereUniqueInput
  }


  /**
   * TypicalThreat base type for findFirst actions
   */
  export type TypicalThreatFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * Filter, which TypicalThreat to fetch.
     */
    where?: TypicalThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypicalThreats to fetch.
     */
    orderBy?: Enumerable<TypicalThreatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypicalThreats.
     */
    cursor?: TypicalThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypicalThreats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypicalThreats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypicalThreats.
     */
    distinct?: Enumerable<TypicalThreatScalarFieldEnum>
  }

  /**
   * TypicalThreat findFirst
   */
  export interface TypicalThreatFindFirstArgs extends TypicalThreatFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TypicalThreat findFirstOrThrow
   */
  export type TypicalThreatFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * Filter, which TypicalThreat to fetch.
     */
    where?: TypicalThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypicalThreats to fetch.
     */
    orderBy?: Enumerable<TypicalThreatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypicalThreats.
     */
    cursor?: TypicalThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypicalThreats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypicalThreats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypicalThreats.
     */
    distinct?: Enumerable<TypicalThreatScalarFieldEnum>
  }


  /**
   * TypicalThreat findMany
   */
  export type TypicalThreatFindManyArgs = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * Filter, which TypicalThreats to fetch.
     */
    where?: TypicalThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypicalThreats to fetch.
     */
    orderBy?: Enumerable<TypicalThreatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypicalThreats.
     */
    cursor?: TypicalThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypicalThreats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypicalThreats.
     */
    skip?: number
    distinct?: Enumerable<TypicalThreatScalarFieldEnum>
  }


  /**
   * TypicalThreat create
   */
  export type TypicalThreatCreateArgs = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * The data needed to create a TypicalThreat.
     */
    data: XOR<TypicalThreatCreateInput, TypicalThreatUncheckedCreateInput>
  }


  /**
   * TypicalThreat createMany
   */
  export type TypicalThreatCreateManyArgs = {
    /**
     * The data used to create many TypicalThreats.
     */
    data: Enumerable<TypicalThreatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TypicalThreat update
   */
  export type TypicalThreatUpdateArgs = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * The data needed to update a TypicalThreat.
     */
    data: XOR<TypicalThreatUpdateInput, TypicalThreatUncheckedUpdateInput>
    /**
     * Choose, which TypicalThreat to update.
     */
    where: TypicalThreatWhereUniqueInput
  }


  /**
   * TypicalThreat updateMany
   */
  export type TypicalThreatUpdateManyArgs = {
    /**
     * The data used to update TypicalThreats.
     */
    data: XOR<TypicalThreatUpdateManyMutationInput, TypicalThreatUncheckedUpdateManyInput>
    /**
     * Filter which TypicalThreats to update
     */
    where?: TypicalThreatWhereInput
  }


  /**
   * TypicalThreat upsert
   */
  export type TypicalThreatUpsertArgs = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * The filter to search for the TypicalThreat to update in case it exists.
     */
    where: TypicalThreatWhereUniqueInput
    /**
     * In case the TypicalThreat found by the `where` argument doesn't exist, create a new TypicalThreat with this data.
     */
    create: XOR<TypicalThreatCreateInput, TypicalThreatUncheckedCreateInput>
    /**
     * In case the TypicalThreat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypicalThreatUpdateInput, TypicalThreatUncheckedUpdateInput>
  }


  /**
   * TypicalThreat delete
   */
  export type TypicalThreatDeleteArgs = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
    /**
     * Filter which TypicalThreat to delete.
     */
    where: TypicalThreatWhereUniqueInput
  }


  /**
   * TypicalThreat deleteMany
   */
  export type TypicalThreatDeleteManyArgs = {
    /**
     * Filter which TypicalThreats to delete
     */
    where?: TypicalThreatWhereInput
  }


  /**
   * TypicalThreat without action
   */
  export type TypicalThreatArgs = {
    /**
     * Select specific fields to fetch from the TypicalThreat
     */
    select?: TypicalThreatSelect | null
  }



  /**
   * Model ResGeography
   */


  export type AggregateResGeography = {
    _count: ResGeographyCountAggregateOutputType | null
    _min: ResGeographyMinAggregateOutputType | null
    _max: ResGeographyMaxAggregateOutputType | null
  }

  export type ResGeographyMinAggregateOutputType = {
    id: string | null
    code: string | null
    geographicregions: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResGeographyMaxAggregateOutputType = {
    id: string | null
    code: string | null
    geographicregions: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResGeographyCountAggregateOutputType = {
    id: number
    code: number
    geographicregions: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResGeographyMinAggregateInputType = {
    id?: true
    code?: true
    geographicregions?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResGeographyMaxAggregateInputType = {
    id?: true
    code?: true
    geographicregions?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResGeographyCountAggregateInputType = {
    id?: true
    code?: true
    geographicregions?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResGeographyAggregateArgs = {
    /**
     * Filter which ResGeography to aggregate.
     */
    where?: ResGeographyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResGeographies to fetch.
     */
    orderBy?: Enumerable<ResGeographyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResGeographyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResGeographies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResGeographies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResGeographies
    **/
    _count?: true | ResGeographyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResGeographyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResGeographyMaxAggregateInputType
  }

  export type GetResGeographyAggregateType<T extends ResGeographyAggregateArgs> = {
        [P in keyof T & keyof AggregateResGeography]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResGeography[P]>
      : GetScalarType<T[P], AggregateResGeography[P]>
  }




  export type ResGeographyGroupByArgs = {
    where?: ResGeographyWhereInput
    orderBy?: Enumerable<ResGeographyOrderByWithAggregationInput>
    by: ResGeographyScalarFieldEnum[]
    having?: ResGeographyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResGeographyCountAggregateInputType | true
    _min?: ResGeographyMinAggregateInputType
    _max?: ResGeographyMaxAggregateInputType
  }


  export type ResGeographyGroupByOutputType = {
    id: string
    code: string
    geographicregions: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ResGeographyCountAggregateOutputType | null
    _min: ResGeographyMinAggregateOutputType | null
    _max: ResGeographyMaxAggregateOutputType | null
  }

  type GetResGeographyGroupByPayload<T extends ResGeographyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ResGeographyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResGeographyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResGeographyGroupByOutputType[P]>
            : GetScalarType<T[P], ResGeographyGroupByOutputType[P]>
        }
      >
    >


  export type ResGeographySelect = {
    id?: boolean
    code?: boolean
    geographicregions?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ResGeographyGetPayload<S extends boolean | null | undefined | ResGeographyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ResGeography :
    S extends undefined ? never :
    S extends { include: any } & (ResGeographyArgs | ResGeographyFindManyArgs)
    ? ResGeography 
    : S extends { select: any } & (ResGeographyArgs | ResGeographyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ResGeography ? ResGeography[P] : never
  } 
      : ResGeography


  type ResGeographyCountArgs = 
    Omit<ResGeographyFindManyArgs, 'select' | 'include'> & {
      select?: ResGeographyCountAggregateInputType | true
    }

  export interface ResGeographyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ResGeography that matches the filter.
     * @param {ResGeographyFindUniqueArgs} args - Arguments to find a ResGeography
     * @example
     * // Get one ResGeography
     * const resGeography = await prisma.resGeography.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResGeographyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResGeographyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ResGeography'> extends True ? Prisma__ResGeographyClient<ResGeographyGetPayload<T>> : Prisma__ResGeographyClient<ResGeographyGetPayload<T> | null, null>

    /**
     * Find one ResGeography that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResGeographyFindUniqueOrThrowArgs} args - Arguments to find a ResGeography
     * @example
     * // Get one ResGeography
     * const resGeography = await prisma.resGeography.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResGeographyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ResGeographyFindUniqueOrThrowArgs>
    ): Prisma__ResGeographyClient<ResGeographyGetPayload<T>>

    /**
     * Find the first ResGeography that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResGeographyFindFirstArgs} args - Arguments to find a ResGeography
     * @example
     * // Get one ResGeography
     * const resGeography = await prisma.resGeography.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResGeographyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResGeographyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ResGeography'> extends True ? Prisma__ResGeographyClient<ResGeographyGetPayload<T>> : Prisma__ResGeographyClient<ResGeographyGetPayload<T> | null, null>

    /**
     * Find the first ResGeography that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResGeographyFindFirstOrThrowArgs} args - Arguments to find a ResGeography
     * @example
     * // Get one ResGeography
     * const resGeography = await prisma.resGeography.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResGeographyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ResGeographyFindFirstOrThrowArgs>
    ): Prisma__ResGeographyClient<ResGeographyGetPayload<T>>

    /**
     * Find zero or more ResGeographies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResGeographyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResGeographies
     * const resGeographies = await prisma.resGeography.findMany()
     * 
     * // Get first 10 ResGeographies
     * const resGeographies = await prisma.resGeography.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resGeographyWithIdOnly = await prisma.resGeography.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResGeographyFindManyArgs>(
      args?: SelectSubset<T, ResGeographyFindManyArgs>
    ): Prisma.PrismaPromise<Array<ResGeographyGetPayload<T>>>

    /**
     * Create a ResGeography.
     * @param {ResGeographyCreateArgs} args - Arguments to create a ResGeography.
     * @example
     * // Create one ResGeography
     * const ResGeography = await prisma.resGeography.create({
     *   data: {
     *     // ... data to create a ResGeography
     *   }
     * })
     * 
    **/
    create<T extends ResGeographyCreateArgs>(
      args: SelectSubset<T, ResGeographyCreateArgs>
    ): Prisma__ResGeographyClient<ResGeographyGetPayload<T>>

    /**
     * Create many ResGeographies.
     *     @param {ResGeographyCreateManyArgs} args - Arguments to create many ResGeographies.
     *     @example
     *     // Create many ResGeographies
     *     const resGeography = await prisma.resGeography.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResGeographyCreateManyArgs>(
      args?: SelectSubset<T, ResGeographyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ResGeography.
     * @param {ResGeographyDeleteArgs} args - Arguments to delete one ResGeography.
     * @example
     * // Delete one ResGeography
     * const ResGeography = await prisma.resGeography.delete({
     *   where: {
     *     // ... filter to delete one ResGeography
     *   }
     * })
     * 
    **/
    delete<T extends ResGeographyDeleteArgs>(
      args: SelectSubset<T, ResGeographyDeleteArgs>
    ): Prisma__ResGeographyClient<ResGeographyGetPayload<T>>

    /**
     * Update one ResGeography.
     * @param {ResGeographyUpdateArgs} args - Arguments to update one ResGeography.
     * @example
     * // Update one ResGeography
     * const resGeography = await prisma.resGeography.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResGeographyUpdateArgs>(
      args: SelectSubset<T, ResGeographyUpdateArgs>
    ): Prisma__ResGeographyClient<ResGeographyGetPayload<T>>

    /**
     * Delete zero or more ResGeographies.
     * @param {ResGeographyDeleteManyArgs} args - Arguments to filter ResGeographies to delete.
     * @example
     * // Delete a few ResGeographies
     * const { count } = await prisma.resGeography.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResGeographyDeleteManyArgs>(
      args?: SelectSubset<T, ResGeographyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResGeographies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResGeographyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResGeographies
     * const resGeography = await prisma.resGeography.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResGeographyUpdateManyArgs>(
      args: SelectSubset<T, ResGeographyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResGeography.
     * @param {ResGeographyUpsertArgs} args - Arguments to update or create a ResGeography.
     * @example
     * // Update or create a ResGeography
     * const resGeography = await prisma.resGeography.upsert({
     *   create: {
     *     // ... data to create a ResGeography
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResGeography we want to update
     *   }
     * })
    **/
    upsert<T extends ResGeographyUpsertArgs>(
      args: SelectSubset<T, ResGeographyUpsertArgs>
    ): Prisma__ResGeographyClient<ResGeographyGetPayload<T>>

    /**
     * Count the number of ResGeographies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResGeographyCountArgs} args - Arguments to filter ResGeographies to count.
     * @example
     * // Count the number of ResGeographies
     * const count = await prisma.resGeography.count({
     *   where: {
     *     // ... the filter for the ResGeographies we want to count
     *   }
     * })
    **/
    count<T extends ResGeographyCountArgs>(
      args?: Subset<T, ResGeographyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResGeographyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResGeography.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResGeographyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResGeographyAggregateArgs>(args: Subset<T, ResGeographyAggregateArgs>): Prisma.PrismaPromise<GetResGeographyAggregateType<T>>

    /**
     * Group by ResGeography.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResGeographyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResGeographyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResGeographyGroupByArgs['orderBy'] }
        : { orderBy?: ResGeographyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResGeographyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResGeographyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ResGeography.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResGeographyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ResGeography base type for findUnique actions
   */
  export type ResGeographyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * Filter, which ResGeography to fetch.
     */
    where: ResGeographyWhereUniqueInput
  }

  /**
   * ResGeography findUnique
   */
  export interface ResGeographyFindUniqueArgs extends ResGeographyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResGeography findUniqueOrThrow
   */
  export type ResGeographyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * Filter, which ResGeography to fetch.
     */
    where: ResGeographyWhereUniqueInput
  }


  /**
   * ResGeography base type for findFirst actions
   */
  export type ResGeographyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * Filter, which ResGeography to fetch.
     */
    where?: ResGeographyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResGeographies to fetch.
     */
    orderBy?: Enumerable<ResGeographyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResGeographies.
     */
    cursor?: ResGeographyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResGeographies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResGeographies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResGeographies.
     */
    distinct?: Enumerable<ResGeographyScalarFieldEnum>
  }

  /**
   * ResGeography findFirst
   */
  export interface ResGeographyFindFirstArgs extends ResGeographyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ResGeography findFirstOrThrow
   */
  export type ResGeographyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * Filter, which ResGeography to fetch.
     */
    where?: ResGeographyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResGeographies to fetch.
     */
    orderBy?: Enumerable<ResGeographyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResGeographies.
     */
    cursor?: ResGeographyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResGeographies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResGeographies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResGeographies.
     */
    distinct?: Enumerable<ResGeographyScalarFieldEnum>
  }


  /**
   * ResGeography findMany
   */
  export type ResGeographyFindManyArgs = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * Filter, which ResGeographies to fetch.
     */
    where?: ResGeographyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResGeographies to fetch.
     */
    orderBy?: Enumerable<ResGeographyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResGeographies.
     */
    cursor?: ResGeographyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResGeographies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResGeographies.
     */
    skip?: number
    distinct?: Enumerable<ResGeographyScalarFieldEnum>
  }


  /**
   * ResGeography create
   */
  export type ResGeographyCreateArgs = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * The data needed to create a ResGeography.
     */
    data: XOR<ResGeographyCreateInput, ResGeographyUncheckedCreateInput>
  }


  /**
   * ResGeography createMany
   */
  export type ResGeographyCreateManyArgs = {
    /**
     * The data used to create many ResGeographies.
     */
    data: Enumerable<ResGeographyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ResGeography update
   */
  export type ResGeographyUpdateArgs = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * The data needed to update a ResGeography.
     */
    data: XOR<ResGeographyUpdateInput, ResGeographyUncheckedUpdateInput>
    /**
     * Choose, which ResGeography to update.
     */
    where: ResGeographyWhereUniqueInput
  }


  /**
   * ResGeography updateMany
   */
  export type ResGeographyUpdateManyArgs = {
    /**
     * The data used to update ResGeographies.
     */
    data: XOR<ResGeographyUpdateManyMutationInput, ResGeographyUncheckedUpdateManyInput>
    /**
     * Filter which ResGeographies to update
     */
    where?: ResGeographyWhereInput
  }


  /**
   * ResGeography upsert
   */
  export type ResGeographyUpsertArgs = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * The filter to search for the ResGeography to update in case it exists.
     */
    where: ResGeographyWhereUniqueInput
    /**
     * In case the ResGeography found by the `where` argument doesn't exist, create a new ResGeography with this data.
     */
    create: XOR<ResGeographyCreateInput, ResGeographyUncheckedCreateInput>
    /**
     * In case the ResGeography was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResGeographyUpdateInput, ResGeographyUncheckedUpdateInput>
  }


  /**
   * ResGeography delete
   */
  export type ResGeographyDeleteArgs = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
    /**
     * Filter which ResGeography to delete.
     */
    where: ResGeographyWhereUniqueInput
  }


  /**
   * ResGeography deleteMany
   */
  export type ResGeographyDeleteManyArgs = {
    /**
     * Filter which ResGeographies to delete
     */
    where?: ResGeographyWhereInput
  }


  /**
   * ResGeography without action
   */
  export type ResGeographyArgs = {
    /**
     * Select specific fields to fetch from the ResGeography
     */
    select?: ResGeographySelect | null
  }



  /**
   * Model CurrentStatus
   */


  export type AggregateCurrentStatus = {
    _count: CurrentStatusCountAggregateOutputType | null
    _min: CurrentStatusMinAggregateOutputType | null
    _max: CurrentStatusMaxAggregateOutputType | null
  }

  export type CurrentStatusMinAggregateOutputType = {
    id: string | null
    code: string | null
    nameStatus: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrentStatusMaxAggregateOutputType = {
    id: string | null
    code: string | null
    nameStatus: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CurrentStatusCountAggregateOutputType = {
    id: number
    code: number
    nameStatus: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CurrentStatusMinAggregateInputType = {
    id?: true
    code?: true
    nameStatus?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrentStatusMaxAggregateInputType = {
    id?: true
    code?: true
    nameStatus?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CurrentStatusCountAggregateInputType = {
    id?: true
    code?: true
    nameStatus?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CurrentStatusAggregateArgs = {
    /**
     * Filter which CurrentStatus to aggregate.
     */
    where?: CurrentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentStatuses to fetch.
     */
    orderBy?: Enumerable<CurrentStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CurrentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CurrentStatuses
    **/
    _count?: true | CurrentStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrentStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrentStatusMaxAggregateInputType
  }

  export type GetCurrentStatusAggregateType<T extends CurrentStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrentStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrentStatus[P]>
      : GetScalarType<T[P], AggregateCurrentStatus[P]>
  }




  export type CurrentStatusGroupByArgs = {
    where?: CurrentStatusWhereInput
    orderBy?: Enumerable<CurrentStatusOrderByWithAggregationInput>
    by: CurrentStatusScalarFieldEnum[]
    having?: CurrentStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrentStatusCountAggregateInputType | true
    _min?: CurrentStatusMinAggregateInputType
    _max?: CurrentStatusMaxAggregateInputType
  }


  export type CurrentStatusGroupByOutputType = {
    id: string
    code: string
    nameStatus: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CurrentStatusCountAggregateOutputType | null
    _min: CurrentStatusMinAggregateOutputType | null
    _max: CurrentStatusMaxAggregateOutputType | null
  }

  type GetCurrentStatusGroupByPayload<T extends CurrentStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CurrentStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrentStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrentStatusGroupByOutputType[P]>
            : GetScalarType<T[P], CurrentStatusGroupByOutputType[P]>
        }
      >
    >


  export type CurrentStatusSelect = {
    id?: boolean
    code?: boolean
    nameStatus?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type CurrentStatusGetPayload<S extends boolean | null | undefined | CurrentStatusArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CurrentStatus :
    S extends undefined ? never :
    S extends { include: any } & (CurrentStatusArgs | CurrentStatusFindManyArgs)
    ? CurrentStatus 
    : S extends { select: any } & (CurrentStatusArgs | CurrentStatusFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CurrentStatus ? CurrentStatus[P] : never
  } 
      : CurrentStatus


  type CurrentStatusCountArgs = 
    Omit<CurrentStatusFindManyArgs, 'select' | 'include'> & {
      select?: CurrentStatusCountAggregateInputType | true
    }

  export interface CurrentStatusDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one CurrentStatus that matches the filter.
     * @param {CurrentStatusFindUniqueArgs} args - Arguments to find a CurrentStatus
     * @example
     * // Get one CurrentStatus
     * const currentStatus = await prisma.currentStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CurrentStatusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CurrentStatusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CurrentStatus'> extends True ? Prisma__CurrentStatusClient<CurrentStatusGetPayload<T>> : Prisma__CurrentStatusClient<CurrentStatusGetPayload<T> | null, null>

    /**
     * Find one CurrentStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CurrentStatusFindUniqueOrThrowArgs} args - Arguments to find a CurrentStatus
     * @example
     * // Get one CurrentStatus
     * const currentStatus = await prisma.currentStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CurrentStatusFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CurrentStatusFindUniqueOrThrowArgs>
    ): Prisma__CurrentStatusClient<CurrentStatusGetPayload<T>>

    /**
     * Find the first CurrentStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentStatusFindFirstArgs} args - Arguments to find a CurrentStatus
     * @example
     * // Get one CurrentStatus
     * const currentStatus = await prisma.currentStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CurrentStatusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CurrentStatusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CurrentStatus'> extends True ? Prisma__CurrentStatusClient<CurrentStatusGetPayload<T>> : Prisma__CurrentStatusClient<CurrentStatusGetPayload<T> | null, null>

    /**
     * Find the first CurrentStatus that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentStatusFindFirstOrThrowArgs} args - Arguments to find a CurrentStatus
     * @example
     * // Get one CurrentStatus
     * const currentStatus = await prisma.currentStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CurrentStatusFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CurrentStatusFindFirstOrThrowArgs>
    ): Prisma__CurrentStatusClient<CurrentStatusGetPayload<T>>

    /**
     * Find zero or more CurrentStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CurrentStatuses
     * const currentStatuses = await prisma.currentStatus.findMany()
     * 
     * // Get first 10 CurrentStatuses
     * const currentStatuses = await prisma.currentStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const currentStatusWithIdOnly = await prisma.currentStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CurrentStatusFindManyArgs>(
      args?: SelectSubset<T, CurrentStatusFindManyArgs>
    ): Prisma.PrismaPromise<Array<CurrentStatusGetPayload<T>>>

    /**
     * Create a CurrentStatus.
     * @param {CurrentStatusCreateArgs} args - Arguments to create a CurrentStatus.
     * @example
     * // Create one CurrentStatus
     * const CurrentStatus = await prisma.currentStatus.create({
     *   data: {
     *     // ... data to create a CurrentStatus
     *   }
     * })
     * 
    **/
    create<T extends CurrentStatusCreateArgs>(
      args: SelectSubset<T, CurrentStatusCreateArgs>
    ): Prisma__CurrentStatusClient<CurrentStatusGetPayload<T>>

    /**
     * Create many CurrentStatuses.
     *     @param {CurrentStatusCreateManyArgs} args - Arguments to create many CurrentStatuses.
     *     @example
     *     // Create many CurrentStatuses
     *     const currentStatus = await prisma.currentStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CurrentStatusCreateManyArgs>(
      args?: SelectSubset<T, CurrentStatusCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CurrentStatus.
     * @param {CurrentStatusDeleteArgs} args - Arguments to delete one CurrentStatus.
     * @example
     * // Delete one CurrentStatus
     * const CurrentStatus = await prisma.currentStatus.delete({
     *   where: {
     *     // ... filter to delete one CurrentStatus
     *   }
     * })
     * 
    **/
    delete<T extends CurrentStatusDeleteArgs>(
      args: SelectSubset<T, CurrentStatusDeleteArgs>
    ): Prisma__CurrentStatusClient<CurrentStatusGetPayload<T>>

    /**
     * Update one CurrentStatus.
     * @param {CurrentStatusUpdateArgs} args - Arguments to update one CurrentStatus.
     * @example
     * // Update one CurrentStatus
     * const currentStatus = await prisma.currentStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CurrentStatusUpdateArgs>(
      args: SelectSubset<T, CurrentStatusUpdateArgs>
    ): Prisma__CurrentStatusClient<CurrentStatusGetPayload<T>>

    /**
     * Delete zero or more CurrentStatuses.
     * @param {CurrentStatusDeleteManyArgs} args - Arguments to filter CurrentStatuses to delete.
     * @example
     * // Delete a few CurrentStatuses
     * const { count } = await prisma.currentStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CurrentStatusDeleteManyArgs>(
      args?: SelectSubset<T, CurrentStatusDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CurrentStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CurrentStatuses
     * const currentStatus = await prisma.currentStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CurrentStatusUpdateManyArgs>(
      args: SelectSubset<T, CurrentStatusUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CurrentStatus.
     * @param {CurrentStatusUpsertArgs} args - Arguments to update or create a CurrentStatus.
     * @example
     * // Update or create a CurrentStatus
     * const currentStatus = await prisma.currentStatus.upsert({
     *   create: {
     *     // ... data to create a CurrentStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CurrentStatus we want to update
     *   }
     * })
    **/
    upsert<T extends CurrentStatusUpsertArgs>(
      args: SelectSubset<T, CurrentStatusUpsertArgs>
    ): Prisma__CurrentStatusClient<CurrentStatusGetPayload<T>>

    /**
     * Count the number of CurrentStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentStatusCountArgs} args - Arguments to filter CurrentStatuses to count.
     * @example
     * // Count the number of CurrentStatuses
     * const count = await prisma.currentStatus.count({
     *   where: {
     *     // ... the filter for the CurrentStatuses we want to count
     *   }
     * })
    **/
    count<T extends CurrentStatusCountArgs>(
      args?: Subset<T, CurrentStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrentStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CurrentStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrentStatusAggregateArgs>(args: Subset<T, CurrentStatusAggregateArgs>): Prisma.PrismaPromise<GetCurrentStatusAggregateType<T>>

    /**
     * Group by CurrentStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrentStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CurrentStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CurrentStatusGroupByArgs['orderBy'] }
        : { orderBy?: CurrentStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CurrentStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrentStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for CurrentStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CurrentStatusClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * CurrentStatus base type for findUnique actions
   */
  export type CurrentStatusFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * Filter, which CurrentStatus to fetch.
     */
    where: CurrentStatusWhereUniqueInput
  }

  /**
   * CurrentStatus findUnique
   */
  export interface CurrentStatusFindUniqueArgs extends CurrentStatusFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CurrentStatus findUniqueOrThrow
   */
  export type CurrentStatusFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * Filter, which CurrentStatus to fetch.
     */
    where: CurrentStatusWhereUniqueInput
  }


  /**
   * CurrentStatus base type for findFirst actions
   */
  export type CurrentStatusFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * Filter, which CurrentStatus to fetch.
     */
    where?: CurrentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentStatuses to fetch.
     */
    orderBy?: Enumerable<CurrentStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrentStatuses.
     */
    cursor?: CurrentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrentStatuses.
     */
    distinct?: Enumerable<CurrentStatusScalarFieldEnum>
  }

  /**
   * CurrentStatus findFirst
   */
  export interface CurrentStatusFindFirstArgs extends CurrentStatusFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * CurrentStatus findFirstOrThrow
   */
  export type CurrentStatusFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * Filter, which CurrentStatus to fetch.
     */
    where?: CurrentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentStatuses to fetch.
     */
    orderBy?: Enumerable<CurrentStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CurrentStatuses.
     */
    cursor?: CurrentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CurrentStatuses.
     */
    distinct?: Enumerable<CurrentStatusScalarFieldEnum>
  }


  /**
   * CurrentStatus findMany
   */
  export type CurrentStatusFindManyArgs = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * Filter, which CurrentStatuses to fetch.
     */
    where?: CurrentStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CurrentStatuses to fetch.
     */
    orderBy?: Enumerable<CurrentStatusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CurrentStatuses.
     */
    cursor?: CurrentStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CurrentStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CurrentStatuses.
     */
    skip?: number
    distinct?: Enumerable<CurrentStatusScalarFieldEnum>
  }


  /**
   * CurrentStatus create
   */
  export type CurrentStatusCreateArgs = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * The data needed to create a CurrentStatus.
     */
    data: XOR<CurrentStatusCreateInput, CurrentStatusUncheckedCreateInput>
  }


  /**
   * CurrentStatus createMany
   */
  export type CurrentStatusCreateManyArgs = {
    /**
     * The data used to create many CurrentStatuses.
     */
    data: Enumerable<CurrentStatusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CurrentStatus update
   */
  export type CurrentStatusUpdateArgs = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * The data needed to update a CurrentStatus.
     */
    data: XOR<CurrentStatusUpdateInput, CurrentStatusUncheckedUpdateInput>
    /**
     * Choose, which CurrentStatus to update.
     */
    where: CurrentStatusWhereUniqueInput
  }


  /**
   * CurrentStatus updateMany
   */
  export type CurrentStatusUpdateManyArgs = {
    /**
     * The data used to update CurrentStatuses.
     */
    data: XOR<CurrentStatusUpdateManyMutationInput, CurrentStatusUncheckedUpdateManyInput>
    /**
     * Filter which CurrentStatuses to update
     */
    where?: CurrentStatusWhereInput
  }


  /**
   * CurrentStatus upsert
   */
  export type CurrentStatusUpsertArgs = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * The filter to search for the CurrentStatus to update in case it exists.
     */
    where: CurrentStatusWhereUniqueInput
    /**
     * In case the CurrentStatus found by the `where` argument doesn't exist, create a new CurrentStatus with this data.
     */
    create: XOR<CurrentStatusCreateInput, CurrentStatusUncheckedCreateInput>
    /**
     * In case the CurrentStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CurrentStatusUpdateInput, CurrentStatusUncheckedUpdateInput>
  }


  /**
   * CurrentStatus delete
   */
  export type CurrentStatusDeleteArgs = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
    /**
     * Filter which CurrentStatus to delete.
     */
    where: CurrentStatusWhereUniqueInput
  }


  /**
   * CurrentStatus deleteMany
   */
  export type CurrentStatusDeleteManyArgs = {
    /**
     * Filter which CurrentStatuses to delete
     */
    where?: CurrentStatusWhereInput
  }


  /**
   * CurrentStatus without action
   */
  export type CurrentStatusArgs = {
    /**
     * Select specific fields to fetch from the CurrentStatus
     */
    select?: CurrentStatusSelect | null
  }



  /**
   * Model Confidentiality
   */


  export type AggregateConfidentiality = {
    _count: ConfidentialityCountAggregateOutputType | null
    _min: ConfidentialityMinAggregateOutputType | null
    _max: ConfidentialityMaxAggregateOutputType | null
  }

  export type ConfidentialityMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfidentialityMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConfidentialityCountAggregateOutputType = {
    id: number
    code: number
    name: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConfidentialityMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfidentialityMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConfidentialityCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConfidentialityAggregateArgs = {
    /**
     * Filter which Confidentiality to aggregate.
     */
    where?: ConfidentialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Confidentialities to fetch.
     */
    orderBy?: Enumerable<ConfidentialityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfidentialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Confidentialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Confidentialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Confidentialities
    **/
    _count?: true | ConfidentialityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfidentialityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfidentialityMaxAggregateInputType
  }

  export type GetConfidentialityAggregateType<T extends ConfidentialityAggregateArgs> = {
        [P in keyof T & keyof AggregateConfidentiality]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfidentiality[P]>
      : GetScalarType<T[P], AggregateConfidentiality[P]>
  }




  export type ConfidentialityGroupByArgs = {
    where?: ConfidentialityWhereInput
    orderBy?: Enumerable<ConfidentialityOrderByWithAggregationInput>
    by: ConfidentialityScalarFieldEnum[]
    having?: ConfidentialityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfidentialityCountAggregateInputType | true
    _min?: ConfidentialityMinAggregateInputType
    _max?: ConfidentialityMaxAggregateInputType
  }


  export type ConfidentialityGroupByOutputType = {
    id: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConfidentialityCountAggregateOutputType | null
    _min: ConfidentialityMinAggregateOutputType | null
    _max: ConfidentialityMaxAggregateOutputType | null
  }

  type GetConfidentialityGroupByPayload<T extends ConfidentialityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ConfidentialityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfidentialityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfidentialityGroupByOutputType[P]>
            : GetScalarType<T[P], ConfidentialityGroupByOutputType[P]>
        }
      >
    >


  export type ConfidentialitySelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type ConfidentialityGetPayload<S extends boolean | null | undefined | ConfidentialityArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Confidentiality :
    S extends undefined ? never :
    S extends { include: any } & (ConfidentialityArgs | ConfidentialityFindManyArgs)
    ? Confidentiality 
    : S extends { select: any } & (ConfidentialityArgs | ConfidentialityFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Confidentiality ? Confidentiality[P] : never
  } 
      : Confidentiality


  type ConfidentialityCountArgs = 
    Omit<ConfidentialityFindManyArgs, 'select' | 'include'> & {
      select?: ConfidentialityCountAggregateInputType | true
    }

  export interface ConfidentialityDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Confidentiality that matches the filter.
     * @param {ConfidentialityFindUniqueArgs} args - Arguments to find a Confidentiality
     * @example
     * // Get one Confidentiality
     * const confidentiality = await prisma.confidentiality.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConfidentialityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConfidentialityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Confidentiality'> extends True ? Prisma__ConfidentialityClient<ConfidentialityGetPayload<T>> : Prisma__ConfidentialityClient<ConfidentialityGetPayload<T> | null, null>

    /**
     * Find one Confidentiality that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConfidentialityFindUniqueOrThrowArgs} args - Arguments to find a Confidentiality
     * @example
     * // Get one Confidentiality
     * const confidentiality = await prisma.confidentiality.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConfidentialityFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ConfidentialityFindUniqueOrThrowArgs>
    ): Prisma__ConfidentialityClient<ConfidentialityGetPayload<T>>

    /**
     * Find the first Confidentiality that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfidentialityFindFirstArgs} args - Arguments to find a Confidentiality
     * @example
     * // Get one Confidentiality
     * const confidentiality = await prisma.confidentiality.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConfidentialityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConfidentialityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Confidentiality'> extends True ? Prisma__ConfidentialityClient<ConfidentialityGetPayload<T>> : Prisma__ConfidentialityClient<ConfidentialityGetPayload<T> | null, null>

    /**
     * Find the first Confidentiality that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfidentialityFindFirstOrThrowArgs} args - Arguments to find a Confidentiality
     * @example
     * // Get one Confidentiality
     * const confidentiality = await prisma.confidentiality.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConfidentialityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ConfidentialityFindFirstOrThrowArgs>
    ): Prisma__ConfidentialityClient<ConfidentialityGetPayload<T>>

    /**
     * Find zero or more Confidentialities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfidentialityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Confidentialities
     * const confidentialities = await prisma.confidentiality.findMany()
     * 
     * // Get first 10 Confidentialities
     * const confidentialities = await prisma.confidentiality.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const confidentialityWithIdOnly = await prisma.confidentiality.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConfidentialityFindManyArgs>(
      args?: SelectSubset<T, ConfidentialityFindManyArgs>
    ): Prisma.PrismaPromise<Array<ConfidentialityGetPayload<T>>>

    /**
     * Create a Confidentiality.
     * @param {ConfidentialityCreateArgs} args - Arguments to create a Confidentiality.
     * @example
     * // Create one Confidentiality
     * const Confidentiality = await prisma.confidentiality.create({
     *   data: {
     *     // ... data to create a Confidentiality
     *   }
     * })
     * 
    **/
    create<T extends ConfidentialityCreateArgs>(
      args: SelectSubset<T, ConfidentialityCreateArgs>
    ): Prisma__ConfidentialityClient<ConfidentialityGetPayload<T>>

    /**
     * Create many Confidentialities.
     *     @param {ConfidentialityCreateManyArgs} args - Arguments to create many Confidentialities.
     *     @example
     *     // Create many Confidentialities
     *     const confidentiality = await prisma.confidentiality.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConfidentialityCreateManyArgs>(
      args?: SelectSubset<T, ConfidentialityCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Confidentiality.
     * @param {ConfidentialityDeleteArgs} args - Arguments to delete one Confidentiality.
     * @example
     * // Delete one Confidentiality
     * const Confidentiality = await prisma.confidentiality.delete({
     *   where: {
     *     // ... filter to delete one Confidentiality
     *   }
     * })
     * 
    **/
    delete<T extends ConfidentialityDeleteArgs>(
      args: SelectSubset<T, ConfidentialityDeleteArgs>
    ): Prisma__ConfidentialityClient<ConfidentialityGetPayload<T>>

    /**
     * Update one Confidentiality.
     * @param {ConfidentialityUpdateArgs} args - Arguments to update one Confidentiality.
     * @example
     * // Update one Confidentiality
     * const confidentiality = await prisma.confidentiality.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConfidentialityUpdateArgs>(
      args: SelectSubset<T, ConfidentialityUpdateArgs>
    ): Prisma__ConfidentialityClient<ConfidentialityGetPayload<T>>

    /**
     * Delete zero or more Confidentialities.
     * @param {ConfidentialityDeleteManyArgs} args - Arguments to filter Confidentialities to delete.
     * @example
     * // Delete a few Confidentialities
     * const { count } = await prisma.confidentiality.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConfidentialityDeleteManyArgs>(
      args?: SelectSubset<T, ConfidentialityDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Confidentialities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfidentialityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Confidentialities
     * const confidentiality = await prisma.confidentiality.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConfidentialityUpdateManyArgs>(
      args: SelectSubset<T, ConfidentialityUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Confidentiality.
     * @param {ConfidentialityUpsertArgs} args - Arguments to update or create a Confidentiality.
     * @example
     * // Update or create a Confidentiality
     * const confidentiality = await prisma.confidentiality.upsert({
     *   create: {
     *     // ... data to create a Confidentiality
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Confidentiality we want to update
     *   }
     * })
    **/
    upsert<T extends ConfidentialityUpsertArgs>(
      args: SelectSubset<T, ConfidentialityUpsertArgs>
    ): Prisma__ConfidentialityClient<ConfidentialityGetPayload<T>>

    /**
     * Count the number of Confidentialities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfidentialityCountArgs} args - Arguments to filter Confidentialities to count.
     * @example
     * // Count the number of Confidentialities
     * const count = await prisma.confidentiality.count({
     *   where: {
     *     // ... the filter for the Confidentialities we want to count
     *   }
     * })
    **/
    count<T extends ConfidentialityCountArgs>(
      args?: Subset<T, ConfidentialityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfidentialityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Confidentiality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfidentialityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfidentialityAggregateArgs>(args: Subset<T, ConfidentialityAggregateArgs>): Prisma.PrismaPromise<GetConfidentialityAggregateType<T>>

    /**
     * Group by Confidentiality.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfidentialityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfidentialityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfidentialityGroupByArgs['orderBy'] }
        : { orderBy?: ConfidentialityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfidentialityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfidentialityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Confidentiality.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConfidentialityClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Confidentiality base type for findUnique actions
   */
  export type ConfidentialityFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * Filter, which Confidentiality to fetch.
     */
    where: ConfidentialityWhereUniqueInput
  }

  /**
   * Confidentiality findUnique
   */
  export interface ConfidentialityFindUniqueArgs extends ConfidentialityFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Confidentiality findUniqueOrThrow
   */
  export type ConfidentialityFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * Filter, which Confidentiality to fetch.
     */
    where: ConfidentialityWhereUniqueInput
  }


  /**
   * Confidentiality base type for findFirst actions
   */
  export type ConfidentialityFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * Filter, which Confidentiality to fetch.
     */
    where?: ConfidentialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Confidentialities to fetch.
     */
    orderBy?: Enumerable<ConfidentialityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Confidentialities.
     */
    cursor?: ConfidentialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Confidentialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Confidentialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Confidentialities.
     */
    distinct?: Enumerable<ConfidentialityScalarFieldEnum>
  }

  /**
   * Confidentiality findFirst
   */
  export interface ConfidentialityFindFirstArgs extends ConfidentialityFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Confidentiality findFirstOrThrow
   */
  export type ConfidentialityFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * Filter, which Confidentiality to fetch.
     */
    where?: ConfidentialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Confidentialities to fetch.
     */
    orderBy?: Enumerable<ConfidentialityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Confidentialities.
     */
    cursor?: ConfidentialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Confidentialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Confidentialities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Confidentialities.
     */
    distinct?: Enumerable<ConfidentialityScalarFieldEnum>
  }


  /**
   * Confidentiality findMany
   */
  export type ConfidentialityFindManyArgs = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * Filter, which Confidentialities to fetch.
     */
    where?: ConfidentialityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Confidentialities to fetch.
     */
    orderBy?: Enumerable<ConfidentialityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Confidentialities.
     */
    cursor?: ConfidentialityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Confidentialities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Confidentialities.
     */
    skip?: number
    distinct?: Enumerable<ConfidentialityScalarFieldEnum>
  }


  /**
   * Confidentiality create
   */
  export type ConfidentialityCreateArgs = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * The data needed to create a Confidentiality.
     */
    data: XOR<ConfidentialityCreateInput, ConfidentialityUncheckedCreateInput>
  }


  /**
   * Confidentiality createMany
   */
  export type ConfidentialityCreateManyArgs = {
    /**
     * The data used to create many Confidentialities.
     */
    data: Enumerable<ConfidentialityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Confidentiality update
   */
  export type ConfidentialityUpdateArgs = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * The data needed to update a Confidentiality.
     */
    data: XOR<ConfidentialityUpdateInput, ConfidentialityUncheckedUpdateInput>
    /**
     * Choose, which Confidentiality to update.
     */
    where: ConfidentialityWhereUniqueInput
  }


  /**
   * Confidentiality updateMany
   */
  export type ConfidentialityUpdateManyArgs = {
    /**
     * The data used to update Confidentialities.
     */
    data: XOR<ConfidentialityUpdateManyMutationInput, ConfidentialityUncheckedUpdateManyInput>
    /**
     * Filter which Confidentialities to update
     */
    where?: ConfidentialityWhereInput
  }


  /**
   * Confidentiality upsert
   */
  export type ConfidentialityUpsertArgs = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * The filter to search for the Confidentiality to update in case it exists.
     */
    where: ConfidentialityWhereUniqueInput
    /**
     * In case the Confidentiality found by the `where` argument doesn't exist, create a new Confidentiality with this data.
     */
    create: XOR<ConfidentialityCreateInput, ConfidentialityUncheckedCreateInput>
    /**
     * In case the Confidentiality was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfidentialityUpdateInput, ConfidentialityUncheckedUpdateInput>
  }


  /**
   * Confidentiality delete
   */
  export type ConfidentialityDeleteArgs = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
    /**
     * Filter which Confidentiality to delete.
     */
    where: ConfidentialityWhereUniqueInput
  }


  /**
   * Confidentiality deleteMany
   */
  export type ConfidentialityDeleteManyArgs = {
    /**
     * Filter which Confidentialities to delete
     */
    where?: ConfidentialityWhereInput
  }


  /**
   * Confidentiality without action
   */
  export type ConfidentialityArgs = {
    /**
     * Select specific fields to fetch from the Confidentiality
     */
    select?: ConfidentialitySelect | null
  }



  /**
   * Model DamageFactors
   */


  export type AggregateDamageFactors = {
    _count: DamageFactorsCountAggregateOutputType | null
    _min: DamageFactorsMinAggregateOutputType | null
    _max: DamageFactorsMaxAggregateOutputType | null
  }

  export type DamageFactorsMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DamageFactorsMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DamageFactorsCountAggregateOutputType = {
    id: number
    code: number
    name: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DamageFactorsMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DamageFactorsMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DamageFactorsCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DamageFactorsAggregateArgs = {
    /**
     * Filter which DamageFactors to aggregate.
     */
    where?: DamageFactorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageFactors to fetch.
     */
    orderBy?: Enumerable<DamageFactorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DamageFactorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DamageFactors
    **/
    _count?: true | DamageFactorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DamageFactorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DamageFactorsMaxAggregateInputType
  }

  export type GetDamageFactorsAggregateType<T extends DamageFactorsAggregateArgs> = {
        [P in keyof T & keyof AggregateDamageFactors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDamageFactors[P]>
      : GetScalarType<T[P], AggregateDamageFactors[P]>
  }




  export type DamageFactorsGroupByArgs = {
    where?: DamageFactorsWhereInput
    orderBy?: Enumerable<DamageFactorsOrderByWithAggregationInput>
    by: DamageFactorsScalarFieldEnum[]
    having?: DamageFactorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DamageFactorsCountAggregateInputType | true
    _min?: DamageFactorsMinAggregateInputType
    _max?: DamageFactorsMaxAggregateInputType
  }


  export type DamageFactorsGroupByOutputType = {
    id: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DamageFactorsCountAggregateOutputType | null
    _min: DamageFactorsMinAggregateOutputType | null
    _max: DamageFactorsMaxAggregateOutputType | null
  }

  type GetDamageFactorsGroupByPayload<T extends DamageFactorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DamageFactorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DamageFactorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DamageFactorsGroupByOutputType[P]>
            : GetScalarType<T[P], DamageFactorsGroupByOutputType[P]>
        }
      >
    >


  export type DamageFactorsSelect = {
    id?: boolean
    code?: boolean
    name?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type DamageFactorsGetPayload<S extends boolean | null | undefined | DamageFactorsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DamageFactors :
    S extends undefined ? never :
    S extends { include: any } & (DamageFactorsArgs | DamageFactorsFindManyArgs)
    ? DamageFactors 
    : S extends { select: any } & (DamageFactorsArgs | DamageFactorsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DamageFactors ? DamageFactors[P] : never
  } 
      : DamageFactors


  type DamageFactorsCountArgs = 
    Omit<DamageFactorsFindManyArgs, 'select' | 'include'> & {
      select?: DamageFactorsCountAggregateInputType | true
    }

  export interface DamageFactorsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one DamageFactors that matches the filter.
     * @param {DamageFactorsFindUniqueArgs} args - Arguments to find a DamageFactors
     * @example
     * // Get one DamageFactors
     * const damageFactors = await prisma.damageFactors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DamageFactorsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DamageFactorsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DamageFactors'> extends True ? Prisma__DamageFactorsClient<DamageFactorsGetPayload<T>> : Prisma__DamageFactorsClient<DamageFactorsGetPayload<T> | null, null>

    /**
     * Find one DamageFactors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DamageFactorsFindUniqueOrThrowArgs} args - Arguments to find a DamageFactors
     * @example
     * // Get one DamageFactors
     * const damageFactors = await prisma.damageFactors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DamageFactorsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DamageFactorsFindUniqueOrThrowArgs>
    ): Prisma__DamageFactorsClient<DamageFactorsGetPayload<T>>

    /**
     * Find the first DamageFactors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFactorsFindFirstArgs} args - Arguments to find a DamageFactors
     * @example
     * // Get one DamageFactors
     * const damageFactors = await prisma.damageFactors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DamageFactorsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DamageFactorsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DamageFactors'> extends True ? Prisma__DamageFactorsClient<DamageFactorsGetPayload<T>> : Prisma__DamageFactorsClient<DamageFactorsGetPayload<T> | null, null>

    /**
     * Find the first DamageFactors that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFactorsFindFirstOrThrowArgs} args - Arguments to find a DamageFactors
     * @example
     * // Get one DamageFactors
     * const damageFactors = await prisma.damageFactors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DamageFactorsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DamageFactorsFindFirstOrThrowArgs>
    ): Prisma__DamageFactorsClient<DamageFactorsGetPayload<T>>

    /**
     * Find zero or more DamageFactors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFactorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DamageFactors
     * const damageFactors = await prisma.damageFactors.findMany()
     * 
     * // Get first 10 DamageFactors
     * const damageFactors = await prisma.damageFactors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const damageFactorsWithIdOnly = await prisma.damageFactors.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DamageFactorsFindManyArgs>(
      args?: SelectSubset<T, DamageFactorsFindManyArgs>
    ): Prisma.PrismaPromise<Array<DamageFactorsGetPayload<T>>>

    /**
     * Create a DamageFactors.
     * @param {DamageFactorsCreateArgs} args - Arguments to create a DamageFactors.
     * @example
     * // Create one DamageFactors
     * const DamageFactors = await prisma.damageFactors.create({
     *   data: {
     *     // ... data to create a DamageFactors
     *   }
     * })
     * 
    **/
    create<T extends DamageFactorsCreateArgs>(
      args: SelectSubset<T, DamageFactorsCreateArgs>
    ): Prisma__DamageFactorsClient<DamageFactorsGetPayload<T>>

    /**
     * Create many DamageFactors.
     *     @param {DamageFactorsCreateManyArgs} args - Arguments to create many DamageFactors.
     *     @example
     *     // Create many DamageFactors
     *     const damageFactors = await prisma.damageFactors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DamageFactorsCreateManyArgs>(
      args?: SelectSubset<T, DamageFactorsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DamageFactors.
     * @param {DamageFactorsDeleteArgs} args - Arguments to delete one DamageFactors.
     * @example
     * // Delete one DamageFactors
     * const DamageFactors = await prisma.damageFactors.delete({
     *   where: {
     *     // ... filter to delete one DamageFactors
     *   }
     * })
     * 
    **/
    delete<T extends DamageFactorsDeleteArgs>(
      args: SelectSubset<T, DamageFactorsDeleteArgs>
    ): Prisma__DamageFactorsClient<DamageFactorsGetPayload<T>>

    /**
     * Update one DamageFactors.
     * @param {DamageFactorsUpdateArgs} args - Arguments to update one DamageFactors.
     * @example
     * // Update one DamageFactors
     * const damageFactors = await prisma.damageFactors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DamageFactorsUpdateArgs>(
      args: SelectSubset<T, DamageFactorsUpdateArgs>
    ): Prisma__DamageFactorsClient<DamageFactorsGetPayload<T>>

    /**
     * Delete zero or more DamageFactors.
     * @param {DamageFactorsDeleteManyArgs} args - Arguments to filter DamageFactors to delete.
     * @example
     * // Delete a few DamageFactors
     * const { count } = await prisma.damageFactors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DamageFactorsDeleteManyArgs>(
      args?: SelectSubset<T, DamageFactorsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DamageFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFactorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DamageFactors
     * const damageFactors = await prisma.damageFactors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DamageFactorsUpdateManyArgs>(
      args: SelectSubset<T, DamageFactorsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DamageFactors.
     * @param {DamageFactorsUpsertArgs} args - Arguments to update or create a DamageFactors.
     * @example
     * // Update or create a DamageFactors
     * const damageFactors = await prisma.damageFactors.upsert({
     *   create: {
     *     // ... data to create a DamageFactors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DamageFactors we want to update
     *   }
     * })
    **/
    upsert<T extends DamageFactorsUpsertArgs>(
      args: SelectSubset<T, DamageFactorsUpsertArgs>
    ): Prisma__DamageFactorsClient<DamageFactorsGetPayload<T>>

    /**
     * Count the number of DamageFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFactorsCountArgs} args - Arguments to filter DamageFactors to count.
     * @example
     * // Count the number of DamageFactors
     * const count = await prisma.damageFactors.count({
     *   where: {
     *     // ... the filter for the DamageFactors we want to count
     *   }
     * })
    **/
    count<T extends DamageFactorsCountArgs>(
      args?: Subset<T, DamageFactorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DamageFactorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DamageFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFactorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DamageFactorsAggregateArgs>(args: Subset<T, DamageFactorsAggregateArgs>): Prisma.PrismaPromise<GetDamageFactorsAggregateType<T>>

    /**
     * Group by DamageFactors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DamageFactorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DamageFactorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DamageFactorsGroupByArgs['orderBy'] }
        : { orderBy?: DamageFactorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DamageFactorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDamageFactorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DamageFactors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DamageFactorsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DamageFactors base type for findUnique actions
   */
  export type DamageFactorsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * Filter, which DamageFactors to fetch.
     */
    where: DamageFactorsWhereUniqueInput
  }

  /**
   * DamageFactors findUnique
   */
  export interface DamageFactorsFindUniqueArgs extends DamageFactorsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DamageFactors findUniqueOrThrow
   */
  export type DamageFactorsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * Filter, which DamageFactors to fetch.
     */
    where: DamageFactorsWhereUniqueInput
  }


  /**
   * DamageFactors base type for findFirst actions
   */
  export type DamageFactorsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * Filter, which DamageFactors to fetch.
     */
    where?: DamageFactorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageFactors to fetch.
     */
    orderBy?: Enumerable<DamageFactorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageFactors.
     */
    cursor?: DamageFactorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageFactors.
     */
    distinct?: Enumerable<DamageFactorsScalarFieldEnum>
  }

  /**
   * DamageFactors findFirst
   */
  export interface DamageFactorsFindFirstArgs extends DamageFactorsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DamageFactors findFirstOrThrow
   */
  export type DamageFactorsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * Filter, which DamageFactors to fetch.
     */
    where?: DamageFactorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageFactors to fetch.
     */
    orderBy?: Enumerable<DamageFactorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DamageFactors.
     */
    cursor?: DamageFactorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageFactors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DamageFactors.
     */
    distinct?: Enumerable<DamageFactorsScalarFieldEnum>
  }


  /**
   * DamageFactors findMany
   */
  export type DamageFactorsFindManyArgs = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * Filter, which DamageFactors to fetch.
     */
    where?: DamageFactorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DamageFactors to fetch.
     */
    orderBy?: Enumerable<DamageFactorsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DamageFactors.
     */
    cursor?: DamageFactorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DamageFactors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DamageFactors.
     */
    skip?: number
    distinct?: Enumerable<DamageFactorsScalarFieldEnum>
  }


  /**
   * DamageFactors create
   */
  export type DamageFactorsCreateArgs = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * The data needed to create a DamageFactors.
     */
    data: XOR<DamageFactorsCreateInput, DamageFactorsUncheckedCreateInput>
  }


  /**
   * DamageFactors createMany
   */
  export type DamageFactorsCreateManyArgs = {
    /**
     * The data used to create many DamageFactors.
     */
    data: Enumerable<DamageFactorsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DamageFactors update
   */
  export type DamageFactorsUpdateArgs = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * The data needed to update a DamageFactors.
     */
    data: XOR<DamageFactorsUpdateInput, DamageFactorsUncheckedUpdateInput>
    /**
     * Choose, which DamageFactors to update.
     */
    where: DamageFactorsWhereUniqueInput
  }


  /**
   * DamageFactors updateMany
   */
  export type DamageFactorsUpdateManyArgs = {
    /**
     * The data used to update DamageFactors.
     */
    data: XOR<DamageFactorsUpdateManyMutationInput, DamageFactorsUncheckedUpdateManyInput>
    /**
     * Filter which DamageFactors to update
     */
    where?: DamageFactorsWhereInput
  }


  /**
   * DamageFactors upsert
   */
  export type DamageFactorsUpsertArgs = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * The filter to search for the DamageFactors to update in case it exists.
     */
    where: DamageFactorsWhereUniqueInput
    /**
     * In case the DamageFactors found by the `where` argument doesn't exist, create a new DamageFactors with this data.
     */
    create: XOR<DamageFactorsCreateInput, DamageFactorsUncheckedCreateInput>
    /**
     * In case the DamageFactors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DamageFactorsUpdateInput, DamageFactorsUncheckedUpdateInput>
  }


  /**
   * DamageFactors delete
   */
  export type DamageFactorsDeleteArgs = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
    /**
     * Filter which DamageFactors to delete.
     */
    where: DamageFactorsWhereUniqueInput
  }


  /**
   * DamageFactors deleteMany
   */
  export type DamageFactorsDeleteManyArgs = {
    /**
     * Filter which DamageFactors to delete
     */
    where?: DamageFactorsWhereInput
  }


  /**
   * DamageFactors without action
   */
  export type DamageFactorsArgs = {
    /**
     * Select specific fields to fetch from the DamageFactors
     */
    select?: DamageFactorsSelect | null
  }



  /**
   * Model SubjectDamage
   */


  export type AggregateSubjectDamage = {
    _count: SubjectDamageCountAggregateOutputType | null
    _min: SubjectDamageMinAggregateOutputType | null
    _max: SubjectDamageMaxAggregateOutputType | null
  }

  export type SubjectDamageMinAggregateOutputType = {
    id: string | null
    code: string | null
    damage: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectDamageMaxAggregateOutputType = {
    id: string | null
    code: string | null
    damage: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectDamageCountAggregateOutputType = {
    id: number
    code: number
    damage: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectDamageMinAggregateInputType = {
    id?: true
    code?: true
    damage?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectDamageMaxAggregateInputType = {
    id?: true
    code?: true
    damage?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectDamageCountAggregateInputType = {
    id?: true
    code?: true
    damage?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectDamageAggregateArgs = {
    /**
     * Filter which SubjectDamage to aggregate.
     */
    where?: SubjectDamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectDamages to fetch.
     */
    orderBy?: Enumerable<SubjectDamageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectDamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectDamages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectDamages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubjectDamages
    **/
    _count?: true | SubjectDamageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectDamageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectDamageMaxAggregateInputType
  }

  export type GetSubjectDamageAggregateType<T extends SubjectDamageAggregateArgs> = {
        [P in keyof T & keyof AggregateSubjectDamage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubjectDamage[P]>
      : GetScalarType<T[P], AggregateSubjectDamage[P]>
  }




  export type SubjectDamageGroupByArgs = {
    where?: SubjectDamageWhereInput
    orderBy?: Enumerable<SubjectDamageOrderByWithAggregationInput>
    by: SubjectDamageScalarFieldEnum[]
    having?: SubjectDamageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectDamageCountAggregateInputType | true
    _min?: SubjectDamageMinAggregateInputType
    _max?: SubjectDamageMaxAggregateInputType
  }


  export type SubjectDamageGroupByOutputType = {
    id: string
    code: string
    damage: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubjectDamageCountAggregateOutputType | null
    _min: SubjectDamageMinAggregateOutputType | null
    _max: SubjectDamageMaxAggregateOutputType | null
  }

  type GetSubjectDamageGroupByPayload<T extends SubjectDamageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubjectDamageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectDamageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectDamageGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectDamageGroupByOutputType[P]>
        }
      >
    >


  export type SubjectDamageSelect = {
    id?: boolean
    code?: boolean
    damage?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type SubjectDamageGetPayload<S extends boolean | null | undefined | SubjectDamageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SubjectDamage :
    S extends undefined ? never :
    S extends { include: any } & (SubjectDamageArgs | SubjectDamageFindManyArgs)
    ? SubjectDamage 
    : S extends { select: any } & (SubjectDamageArgs | SubjectDamageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SubjectDamage ? SubjectDamage[P] : never
  } 
      : SubjectDamage


  type SubjectDamageCountArgs = 
    Omit<SubjectDamageFindManyArgs, 'select' | 'include'> & {
      select?: SubjectDamageCountAggregateInputType | true
    }

  export interface SubjectDamageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one SubjectDamage that matches the filter.
     * @param {SubjectDamageFindUniqueArgs} args - Arguments to find a SubjectDamage
     * @example
     * // Get one SubjectDamage
     * const subjectDamage = await prisma.subjectDamage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubjectDamageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SubjectDamageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SubjectDamage'> extends True ? Prisma__SubjectDamageClient<SubjectDamageGetPayload<T>> : Prisma__SubjectDamageClient<SubjectDamageGetPayload<T> | null, null>

    /**
     * Find one SubjectDamage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubjectDamageFindUniqueOrThrowArgs} args - Arguments to find a SubjectDamage
     * @example
     * // Get one SubjectDamage
     * const subjectDamage = await prisma.subjectDamage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubjectDamageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SubjectDamageFindUniqueOrThrowArgs>
    ): Prisma__SubjectDamageClient<SubjectDamageGetPayload<T>>

    /**
     * Find the first SubjectDamage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectDamageFindFirstArgs} args - Arguments to find a SubjectDamage
     * @example
     * // Get one SubjectDamage
     * const subjectDamage = await prisma.subjectDamage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubjectDamageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SubjectDamageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SubjectDamage'> extends True ? Prisma__SubjectDamageClient<SubjectDamageGetPayload<T>> : Prisma__SubjectDamageClient<SubjectDamageGetPayload<T> | null, null>

    /**
     * Find the first SubjectDamage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectDamageFindFirstOrThrowArgs} args - Arguments to find a SubjectDamage
     * @example
     * // Get one SubjectDamage
     * const subjectDamage = await prisma.subjectDamage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubjectDamageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubjectDamageFindFirstOrThrowArgs>
    ): Prisma__SubjectDamageClient<SubjectDamageGetPayload<T>>

    /**
     * Find zero or more SubjectDamages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectDamageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubjectDamages
     * const subjectDamages = await prisma.subjectDamage.findMany()
     * 
     * // Get first 10 SubjectDamages
     * const subjectDamages = await prisma.subjectDamage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectDamageWithIdOnly = await prisma.subjectDamage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubjectDamageFindManyArgs>(
      args?: SelectSubset<T, SubjectDamageFindManyArgs>
    ): Prisma.PrismaPromise<Array<SubjectDamageGetPayload<T>>>

    /**
     * Create a SubjectDamage.
     * @param {SubjectDamageCreateArgs} args - Arguments to create a SubjectDamage.
     * @example
     * // Create one SubjectDamage
     * const SubjectDamage = await prisma.subjectDamage.create({
     *   data: {
     *     // ... data to create a SubjectDamage
     *   }
     * })
     * 
    **/
    create<T extends SubjectDamageCreateArgs>(
      args: SelectSubset<T, SubjectDamageCreateArgs>
    ): Prisma__SubjectDamageClient<SubjectDamageGetPayload<T>>

    /**
     * Create many SubjectDamages.
     *     @param {SubjectDamageCreateManyArgs} args - Arguments to create many SubjectDamages.
     *     @example
     *     // Create many SubjectDamages
     *     const subjectDamage = await prisma.subjectDamage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubjectDamageCreateManyArgs>(
      args?: SelectSubset<T, SubjectDamageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubjectDamage.
     * @param {SubjectDamageDeleteArgs} args - Arguments to delete one SubjectDamage.
     * @example
     * // Delete one SubjectDamage
     * const SubjectDamage = await prisma.subjectDamage.delete({
     *   where: {
     *     // ... filter to delete one SubjectDamage
     *   }
     * })
     * 
    **/
    delete<T extends SubjectDamageDeleteArgs>(
      args: SelectSubset<T, SubjectDamageDeleteArgs>
    ): Prisma__SubjectDamageClient<SubjectDamageGetPayload<T>>

    /**
     * Update one SubjectDamage.
     * @param {SubjectDamageUpdateArgs} args - Arguments to update one SubjectDamage.
     * @example
     * // Update one SubjectDamage
     * const subjectDamage = await prisma.subjectDamage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubjectDamageUpdateArgs>(
      args: SelectSubset<T, SubjectDamageUpdateArgs>
    ): Prisma__SubjectDamageClient<SubjectDamageGetPayload<T>>

    /**
     * Delete zero or more SubjectDamages.
     * @param {SubjectDamageDeleteManyArgs} args - Arguments to filter SubjectDamages to delete.
     * @example
     * // Delete a few SubjectDamages
     * const { count } = await prisma.subjectDamage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubjectDamageDeleteManyArgs>(
      args?: SelectSubset<T, SubjectDamageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubjectDamages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectDamageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubjectDamages
     * const subjectDamage = await prisma.subjectDamage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubjectDamageUpdateManyArgs>(
      args: SelectSubset<T, SubjectDamageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubjectDamage.
     * @param {SubjectDamageUpsertArgs} args - Arguments to update or create a SubjectDamage.
     * @example
     * // Update or create a SubjectDamage
     * const subjectDamage = await prisma.subjectDamage.upsert({
     *   create: {
     *     // ... data to create a SubjectDamage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubjectDamage we want to update
     *   }
     * })
    **/
    upsert<T extends SubjectDamageUpsertArgs>(
      args: SelectSubset<T, SubjectDamageUpsertArgs>
    ): Prisma__SubjectDamageClient<SubjectDamageGetPayload<T>>

    /**
     * Count the number of SubjectDamages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectDamageCountArgs} args - Arguments to filter SubjectDamages to count.
     * @example
     * // Count the number of SubjectDamages
     * const count = await prisma.subjectDamage.count({
     *   where: {
     *     // ... the filter for the SubjectDamages we want to count
     *   }
     * })
    **/
    count<T extends SubjectDamageCountArgs>(
      args?: Subset<T, SubjectDamageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectDamageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubjectDamage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectDamageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectDamageAggregateArgs>(args: Subset<T, SubjectDamageAggregateArgs>): Prisma.PrismaPromise<GetSubjectDamageAggregateType<T>>

    /**
     * Group by SubjectDamage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectDamageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectDamageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectDamageGroupByArgs['orderBy'] }
        : { orderBy?: SubjectDamageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectDamageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectDamageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SubjectDamage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SubjectDamageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SubjectDamage base type for findUnique actions
   */
  export type SubjectDamageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * Filter, which SubjectDamage to fetch.
     */
    where: SubjectDamageWhereUniqueInput
  }

  /**
   * SubjectDamage findUnique
   */
  export interface SubjectDamageFindUniqueArgs extends SubjectDamageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubjectDamage findUniqueOrThrow
   */
  export type SubjectDamageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * Filter, which SubjectDamage to fetch.
     */
    where: SubjectDamageWhereUniqueInput
  }


  /**
   * SubjectDamage base type for findFirst actions
   */
  export type SubjectDamageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * Filter, which SubjectDamage to fetch.
     */
    where?: SubjectDamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectDamages to fetch.
     */
    orderBy?: Enumerable<SubjectDamageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubjectDamages.
     */
    cursor?: SubjectDamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectDamages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectDamages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubjectDamages.
     */
    distinct?: Enumerable<SubjectDamageScalarFieldEnum>
  }

  /**
   * SubjectDamage findFirst
   */
  export interface SubjectDamageFindFirstArgs extends SubjectDamageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SubjectDamage findFirstOrThrow
   */
  export type SubjectDamageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * Filter, which SubjectDamage to fetch.
     */
    where?: SubjectDamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectDamages to fetch.
     */
    orderBy?: Enumerable<SubjectDamageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubjectDamages.
     */
    cursor?: SubjectDamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectDamages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectDamages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubjectDamages.
     */
    distinct?: Enumerable<SubjectDamageScalarFieldEnum>
  }


  /**
   * SubjectDamage findMany
   */
  export type SubjectDamageFindManyArgs = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * Filter, which SubjectDamages to fetch.
     */
    where?: SubjectDamageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubjectDamages to fetch.
     */
    orderBy?: Enumerable<SubjectDamageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubjectDamages.
     */
    cursor?: SubjectDamageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubjectDamages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubjectDamages.
     */
    skip?: number
    distinct?: Enumerable<SubjectDamageScalarFieldEnum>
  }


  /**
   * SubjectDamage create
   */
  export type SubjectDamageCreateArgs = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * The data needed to create a SubjectDamage.
     */
    data: XOR<SubjectDamageCreateInput, SubjectDamageUncheckedCreateInput>
  }


  /**
   * SubjectDamage createMany
   */
  export type SubjectDamageCreateManyArgs = {
    /**
     * The data used to create many SubjectDamages.
     */
    data: Enumerable<SubjectDamageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SubjectDamage update
   */
  export type SubjectDamageUpdateArgs = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * The data needed to update a SubjectDamage.
     */
    data: XOR<SubjectDamageUpdateInput, SubjectDamageUncheckedUpdateInput>
    /**
     * Choose, which SubjectDamage to update.
     */
    where: SubjectDamageWhereUniqueInput
  }


  /**
   * SubjectDamage updateMany
   */
  export type SubjectDamageUpdateManyArgs = {
    /**
     * The data used to update SubjectDamages.
     */
    data: XOR<SubjectDamageUpdateManyMutationInput, SubjectDamageUncheckedUpdateManyInput>
    /**
     * Filter which SubjectDamages to update
     */
    where?: SubjectDamageWhereInput
  }


  /**
   * SubjectDamage upsert
   */
  export type SubjectDamageUpsertArgs = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * The filter to search for the SubjectDamage to update in case it exists.
     */
    where: SubjectDamageWhereUniqueInput
    /**
     * In case the SubjectDamage found by the `where` argument doesn't exist, create a new SubjectDamage with this data.
     */
    create: XOR<SubjectDamageCreateInput, SubjectDamageUncheckedCreateInput>
    /**
     * In case the SubjectDamage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectDamageUpdateInput, SubjectDamageUncheckedUpdateInput>
  }


  /**
   * SubjectDamage delete
   */
  export type SubjectDamageDeleteArgs = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
    /**
     * Filter which SubjectDamage to delete.
     */
    where: SubjectDamageWhereUniqueInput
  }


  /**
   * SubjectDamage deleteMany
   */
  export type SubjectDamageDeleteManyArgs = {
    /**
     * Filter which SubjectDamages to delete
     */
    where?: SubjectDamageWhereInput
  }


  /**
   * SubjectDamage without action
   */
  export type SubjectDamageArgs = {
    /**
     * Select specific fields to fetch from the SubjectDamage
     */
    select?: SubjectDamageSelect | null
  }



  /**
   * Model EmployeeName
   */


  export type AggregateEmployeeName = {
    _count: EmployeeNameCountAggregateOutputType | null
    _min: EmployeeNameMinAggregateOutputType | null
    _max: EmployeeNameMaxAggregateOutputType | null
  }

  export type EmployeeNameMinAggregateOutputType = {
    id: string | null
    code: string | null
    fullName: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeNameMaxAggregateOutputType = {
    id: string | null
    code: string | null
    fullName: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeNameCountAggregateOutputType = {
    id: number
    code: number
    fullName: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeNameMinAggregateInputType = {
    id?: true
    code?: true
    fullName?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeNameMaxAggregateInputType = {
    id?: true
    code?: true
    fullName?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeNameCountAggregateInputType = {
    id?: true
    code?: true
    fullName?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeNameAggregateArgs = {
    /**
     * Filter which EmployeeName to aggregate.
     */
    where?: EmployeeNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeNames to fetch.
     */
    orderBy?: Enumerable<EmployeeNameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeNames
    **/
    _count?: true | EmployeeNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeNameMaxAggregateInputType
  }

  export type GetEmployeeNameAggregateType<T extends EmployeeNameAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeName[P]>
      : GetScalarType<T[P], AggregateEmployeeName[P]>
  }




  export type EmployeeNameGroupByArgs = {
    where?: EmployeeNameWhereInput
    orderBy?: Enumerable<EmployeeNameOrderByWithAggregationInput>
    by: EmployeeNameScalarFieldEnum[]
    having?: EmployeeNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeNameCountAggregateInputType | true
    _min?: EmployeeNameMinAggregateInputType
    _max?: EmployeeNameMaxAggregateInputType
  }


  export type EmployeeNameGroupByOutputType = {
    id: string
    code: string
    fullName: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeNameCountAggregateOutputType | null
    _min: EmployeeNameMinAggregateOutputType | null
    _max: EmployeeNameMaxAggregateOutputType | null
  }

  type GetEmployeeNameGroupByPayload<T extends EmployeeNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EmployeeNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeNameGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeNameGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeNameSelect = {
    id?: boolean
    code?: boolean
    fullName?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type EmployeeNameGetPayload<S extends boolean | null | undefined | EmployeeNameArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EmployeeName :
    S extends undefined ? never :
    S extends { include: any } & (EmployeeNameArgs | EmployeeNameFindManyArgs)
    ? EmployeeName 
    : S extends { select: any } & (EmployeeNameArgs | EmployeeNameFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EmployeeName ? EmployeeName[P] : never
  } 
      : EmployeeName


  type EmployeeNameCountArgs = 
    Omit<EmployeeNameFindManyArgs, 'select' | 'include'> & {
      select?: EmployeeNameCountAggregateInputType | true
    }

  export interface EmployeeNameDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one EmployeeName that matches the filter.
     * @param {EmployeeNameFindUniqueArgs} args - Arguments to find a EmployeeName
     * @example
     * // Get one EmployeeName
     * const employeeName = await prisma.employeeName.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmployeeNameFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EmployeeNameFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EmployeeName'> extends True ? Prisma__EmployeeNameClient<EmployeeNameGetPayload<T>> : Prisma__EmployeeNameClient<EmployeeNameGetPayload<T> | null, null>

    /**
     * Find one EmployeeName that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmployeeNameFindUniqueOrThrowArgs} args - Arguments to find a EmployeeName
     * @example
     * // Get one EmployeeName
     * const employeeName = await prisma.employeeName.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmployeeNameFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EmployeeNameFindUniqueOrThrowArgs>
    ): Prisma__EmployeeNameClient<EmployeeNameGetPayload<T>>

    /**
     * Find the first EmployeeName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeNameFindFirstArgs} args - Arguments to find a EmployeeName
     * @example
     * // Get one EmployeeName
     * const employeeName = await prisma.employeeName.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmployeeNameFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EmployeeNameFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EmployeeName'> extends True ? Prisma__EmployeeNameClient<EmployeeNameGetPayload<T>> : Prisma__EmployeeNameClient<EmployeeNameGetPayload<T> | null, null>

    /**
     * Find the first EmployeeName that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeNameFindFirstOrThrowArgs} args - Arguments to find a EmployeeName
     * @example
     * // Get one EmployeeName
     * const employeeName = await prisma.employeeName.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmployeeNameFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EmployeeNameFindFirstOrThrowArgs>
    ): Prisma__EmployeeNameClient<EmployeeNameGetPayload<T>>

    /**
     * Find zero or more EmployeeNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeNameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeNames
     * const employeeNames = await prisma.employeeName.findMany()
     * 
     * // Get first 10 EmployeeNames
     * const employeeNames = await prisma.employeeName.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeNameWithIdOnly = await prisma.employeeName.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmployeeNameFindManyArgs>(
      args?: SelectSubset<T, EmployeeNameFindManyArgs>
    ): Prisma.PrismaPromise<Array<EmployeeNameGetPayload<T>>>

    /**
     * Create a EmployeeName.
     * @param {EmployeeNameCreateArgs} args - Arguments to create a EmployeeName.
     * @example
     * // Create one EmployeeName
     * const EmployeeName = await prisma.employeeName.create({
     *   data: {
     *     // ... data to create a EmployeeName
     *   }
     * })
     * 
    **/
    create<T extends EmployeeNameCreateArgs>(
      args: SelectSubset<T, EmployeeNameCreateArgs>
    ): Prisma__EmployeeNameClient<EmployeeNameGetPayload<T>>

    /**
     * Create many EmployeeNames.
     *     @param {EmployeeNameCreateManyArgs} args - Arguments to create many EmployeeNames.
     *     @example
     *     // Create many EmployeeNames
     *     const employeeName = await prisma.employeeName.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmployeeNameCreateManyArgs>(
      args?: SelectSubset<T, EmployeeNameCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeName.
     * @param {EmployeeNameDeleteArgs} args - Arguments to delete one EmployeeName.
     * @example
     * // Delete one EmployeeName
     * const EmployeeName = await prisma.employeeName.delete({
     *   where: {
     *     // ... filter to delete one EmployeeName
     *   }
     * })
     * 
    **/
    delete<T extends EmployeeNameDeleteArgs>(
      args: SelectSubset<T, EmployeeNameDeleteArgs>
    ): Prisma__EmployeeNameClient<EmployeeNameGetPayload<T>>

    /**
     * Update one EmployeeName.
     * @param {EmployeeNameUpdateArgs} args - Arguments to update one EmployeeName.
     * @example
     * // Update one EmployeeName
     * const employeeName = await prisma.employeeName.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmployeeNameUpdateArgs>(
      args: SelectSubset<T, EmployeeNameUpdateArgs>
    ): Prisma__EmployeeNameClient<EmployeeNameGetPayload<T>>

    /**
     * Delete zero or more EmployeeNames.
     * @param {EmployeeNameDeleteManyArgs} args - Arguments to filter EmployeeNames to delete.
     * @example
     * // Delete a few EmployeeNames
     * const { count } = await prisma.employeeName.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmployeeNameDeleteManyArgs>(
      args?: SelectSubset<T, EmployeeNameDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeNames
     * const employeeName = await prisma.employeeName.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmployeeNameUpdateManyArgs>(
      args: SelectSubset<T, EmployeeNameUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeName.
     * @param {EmployeeNameUpsertArgs} args - Arguments to update or create a EmployeeName.
     * @example
     * // Update or create a EmployeeName
     * const employeeName = await prisma.employeeName.upsert({
     *   create: {
     *     // ... data to create a EmployeeName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeName we want to update
     *   }
     * })
    **/
    upsert<T extends EmployeeNameUpsertArgs>(
      args: SelectSubset<T, EmployeeNameUpsertArgs>
    ): Prisma__EmployeeNameClient<EmployeeNameGetPayload<T>>

    /**
     * Count the number of EmployeeNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeNameCountArgs} args - Arguments to filter EmployeeNames to count.
     * @example
     * // Count the number of EmployeeNames
     * const count = await prisma.employeeName.count({
     *   where: {
     *     // ... the filter for the EmployeeNames we want to count
     *   }
     * })
    **/
    count<T extends EmployeeNameCountArgs>(
      args?: Subset<T, EmployeeNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeNameAggregateArgs>(args: Subset<T, EmployeeNameAggregateArgs>): Prisma.PrismaPromise<GetEmployeeNameAggregateType<T>>

    /**
     * Group by EmployeeName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeNameGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EmployeeNameClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EmployeeName base type for findUnique actions
   */
  export type EmployeeNameFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * Filter, which EmployeeName to fetch.
     */
    where: EmployeeNameWhereUniqueInput
  }

  /**
   * EmployeeName findUnique
   */
  export interface EmployeeNameFindUniqueArgs extends EmployeeNameFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EmployeeName findUniqueOrThrow
   */
  export type EmployeeNameFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * Filter, which EmployeeName to fetch.
     */
    where: EmployeeNameWhereUniqueInput
  }


  /**
   * EmployeeName base type for findFirst actions
   */
  export type EmployeeNameFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * Filter, which EmployeeName to fetch.
     */
    where?: EmployeeNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeNames to fetch.
     */
    orderBy?: Enumerable<EmployeeNameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeNames.
     */
    cursor?: EmployeeNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeNames.
     */
    distinct?: Enumerable<EmployeeNameScalarFieldEnum>
  }

  /**
   * EmployeeName findFirst
   */
  export interface EmployeeNameFindFirstArgs extends EmployeeNameFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EmployeeName findFirstOrThrow
   */
  export type EmployeeNameFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * Filter, which EmployeeName to fetch.
     */
    where?: EmployeeNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeNames to fetch.
     */
    orderBy?: Enumerable<EmployeeNameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeNames.
     */
    cursor?: EmployeeNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeNames.
     */
    distinct?: Enumerable<EmployeeNameScalarFieldEnum>
  }


  /**
   * EmployeeName findMany
   */
  export type EmployeeNameFindManyArgs = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * Filter, which EmployeeNames to fetch.
     */
    where?: EmployeeNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeNames to fetch.
     */
    orderBy?: Enumerable<EmployeeNameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeNames.
     */
    cursor?: EmployeeNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeNames.
     */
    skip?: number
    distinct?: Enumerable<EmployeeNameScalarFieldEnum>
  }


  /**
   * EmployeeName create
   */
  export type EmployeeNameCreateArgs = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * The data needed to create a EmployeeName.
     */
    data: XOR<EmployeeNameCreateInput, EmployeeNameUncheckedCreateInput>
  }


  /**
   * EmployeeName createMany
   */
  export type EmployeeNameCreateManyArgs = {
    /**
     * The data used to create many EmployeeNames.
     */
    data: Enumerable<EmployeeNameCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EmployeeName update
   */
  export type EmployeeNameUpdateArgs = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * The data needed to update a EmployeeName.
     */
    data: XOR<EmployeeNameUpdateInput, EmployeeNameUncheckedUpdateInput>
    /**
     * Choose, which EmployeeName to update.
     */
    where: EmployeeNameWhereUniqueInput
  }


  /**
   * EmployeeName updateMany
   */
  export type EmployeeNameUpdateManyArgs = {
    /**
     * The data used to update EmployeeNames.
     */
    data: XOR<EmployeeNameUpdateManyMutationInput, EmployeeNameUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeNames to update
     */
    where?: EmployeeNameWhereInput
  }


  /**
   * EmployeeName upsert
   */
  export type EmployeeNameUpsertArgs = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * The filter to search for the EmployeeName to update in case it exists.
     */
    where: EmployeeNameWhereUniqueInput
    /**
     * In case the EmployeeName found by the `where` argument doesn't exist, create a new EmployeeName with this data.
     */
    create: XOR<EmployeeNameCreateInput, EmployeeNameUncheckedCreateInput>
    /**
     * In case the EmployeeName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeNameUpdateInput, EmployeeNameUncheckedUpdateInput>
  }


  /**
   * EmployeeName delete
   */
  export type EmployeeNameDeleteArgs = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
    /**
     * Filter which EmployeeName to delete.
     */
    where: EmployeeNameWhereUniqueInput
  }


  /**
   * EmployeeName deleteMany
   */
  export type EmployeeNameDeleteManyArgs = {
    /**
     * Filter which EmployeeNames to delete
     */
    where?: EmployeeNameWhereInput
  }


  /**
   * EmployeeName without action
   */
  export type EmployeeNameArgs = {
    /**
     * Select specific fields to fetch from the EmployeeName
     */
    select?: EmployeeNameSelect | null
  }



  /**
   * Model EditEmployeeName
   */


  export type AggregateEditEmployeeName = {
    _count: EditEmployeeNameCountAggregateOutputType | null
    _min: EditEmployeeNameMinAggregateOutputType | null
    _max: EditEmployeeNameMaxAggregateOutputType | null
  }

  export type EditEmployeeNameMinAggregateOutputType = {
    id: string | null
    code: string | null
    fullName: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EditEmployeeNameMaxAggregateOutputType = {
    id: string | null
    code: string | null
    fullName: string | null
    nameuz: string | null
    nameru: string | null
    creatorId: string | null
    editorId: string | null
    removerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EditEmployeeNameCountAggregateOutputType = {
    id: number
    code: number
    fullName: number
    nameuz: number
    nameru: number
    creatorId: number
    editorId: number
    removerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EditEmployeeNameMinAggregateInputType = {
    id?: true
    code?: true
    fullName?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EditEmployeeNameMaxAggregateInputType = {
    id?: true
    code?: true
    fullName?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EditEmployeeNameCountAggregateInputType = {
    id?: true
    code?: true
    fullName?: true
    nameuz?: true
    nameru?: true
    creatorId?: true
    editorId?: true
    removerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EditEmployeeNameAggregateArgs = {
    /**
     * Filter which EditEmployeeName to aggregate.
     */
    where?: EditEmployeeNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditEmployeeNames to fetch.
     */
    orderBy?: Enumerable<EditEmployeeNameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EditEmployeeNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditEmployeeNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditEmployeeNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EditEmployeeNames
    **/
    _count?: true | EditEmployeeNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EditEmployeeNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EditEmployeeNameMaxAggregateInputType
  }

  export type GetEditEmployeeNameAggregateType<T extends EditEmployeeNameAggregateArgs> = {
        [P in keyof T & keyof AggregateEditEmployeeName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEditEmployeeName[P]>
      : GetScalarType<T[P], AggregateEditEmployeeName[P]>
  }




  export type EditEmployeeNameGroupByArgs = {
    where?: EditEmployeeNameWhereInput
    orderBy?: Enumerable<EditEmployeeNameOrderByWithAggregationInput>
    by: EditEmployeeNameScalarFieldEnum[]
    having?: EditEmployeeNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EditEmployeeNameCountAggregateInputType | true
    _min?: EditEmployeeNameMinAggregateInputType
    _max?: EditEmployeeNameMaxAggregateInputType
  }


  export type EditEmployeeNameGroupByOutputType = {
    id: string
    code: string
    fullName: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EditEmployeeNameCountAggregateOutputType | null
    _min: EditEmployeeNameMinAggregateOutputType | null
    _max: EditEmployeeNameMaxAggregateOutputType | null
  }

  type GetEditEmployeeNameGroupByPayload<T extends EditEmployeeNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EditEmployeeNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EditEmployeeNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EditEmployeeNameGroupByOutputType[P]>
            : GetScalarType<T[P], EditEmployeeNameGroupByOutputType[P]>
        }
      >
    >


  export type EditEmployeeNameSelect = {
    id?: boolean
    code?: boolean
    fullName?: boolean
    nameuz?: boolean
    nameru?: boolean
    creatorId?: boolean
    editorId?: boolean
    removerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type EditEmployeeNameGetPayload<S extends boolean | null | undefined | EditEmployeeNameArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EditEmployeeName :
    S extends undefined ? never :
    S extends { include: any } & (EditEmployeeNameArgs | EditEmployeeNameFindManyArgs)
    ? EditEmployeeName 
    : S extends { select: any } & (EditEmployeeNameArgs | EditEmployeeNameFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EditEmployeeName ? EditEmployeeName[P] : never
  } 
      : EditEmployeeName


  type EditEmployeeNameCountArgs = 
    Omit<EditEmployeeNameFindManyArgs, 'select' | 'include'> & {
      select?: EditEmployeeNameCountAggregateInputType | true
    }

  export interface EditEmployeeNameDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one EditEmployeeName that matches the filter.
     * @param {EditEmployeeNameFindUniqueArgs} args - Arguments to find a EditEmployeeName
     * @example
     * // Get one EditEmployeeName
     * const editEmployeeName = await prisma.editEmployeeName.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EditEmployeeNameFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EditEmployeeNameFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EditEmployeeName'> extends True ? Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T>> : Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T> | null, null>

    /**
     * Find one EditEmployeeName that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EditEmployeeNameFindUniqueOrThrowArgs} args - Arguments to find a EditEmployeeName
     * @example
     * // Get one EditEmployeeName
     * const editEmployeeName = await prisma.editEmployeeName.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EditEmployeeNameFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, EditEmployeeNameFindUniqueOrThrowArgs>
    ): Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T>>

    /**
     * Find the first EditEmployeeName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditEmployeeNameFindFirstArgs} args - Arguments to find a EditEmployeeName
     * @example
     * // Get one EditEmployeeName
     * const editEmployeeName = await prisma.editEmployeeName.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EditEmployeeNameFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EditEmployeeNameFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EditEmployeeName'> extends True ? Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T>> : Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T> | null, null>

    /**
     * Find the first EditEmployeeName that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditEmployeeNameFindFirstOrThrowArgs} args - Arguments to find a EditEmployeeName
     * @example
     * // Get one EditEmployeeName
     * const editEmployeeName = await prisma.editEmployeeName.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EditEmployeeNameFindFirstOrThrowArgs>(
      args?: SelectSubset<T, EditEmployeeNameFindFirstOrThrowArgs>
    ): Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T>>

    /**
     * Find zero or more EditEmployeeNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditEmployeeNameFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EditEmployeeNames
     * const editEmployeeNames = await prisma.editEmployeeName.findMany()
     * 
     * // Get first 10 EditEmployeeNames
     * const editEmployeeNames = await prisma.editEmployeeName.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const editEmployeeNameWithIdOnly = await prisma.editEmployeeName.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EditEmployeeNameFindManyArgs>(
      args?: SelectSubset<T, EditEmployeeNameFindManyArgs>
    ): Prisma.PrismaPromise<Array<EditEmployeeNameGetPayload<T>>>

    /**
     * Create a EditEmployeeName.
     * @param {EditEmployeeNameCreateArgs} args - Arguments to create a EditEmployeeName.
     * @example
     * // Create one EditEmployeeName
     * const EditEmployeeName = await prisma.editEmployeeName.create({
     *   data: {
     *     // ... data to create a EditEmployeeName
     *   }
     * })
     * 
    **/
    create<T extends EditEmployeeNameCreateArgs>(
      args: SelectSubset<T, EditEmployeeNameCreateArgs>
    ): Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T>>

    /**
     * Create many EditEmployeeNames.
     *     @param {EditEmployeeNameCreateManyArgs} args - Arguments to create many EditEmployeeNames.
     *     @example
     *     // Create many EditEmployeeNames
     *     const editEmployeeName = await prisma.editEmployeeName.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EditEmployeeNameCreateManyArgs>(
      args?: SelectSubset<T, EditEmployeeNameCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EditEmployeeName.
     * @param {EditEmployeeNameDeleteArgs} args - Arguments to delete one EditEmployeeName.
     * @example
     * // Delete one EditEmployeeName
     * const EditEmployeeName = await prisma.editEmployeeName.delete({
     *   where: {
     *     // ... filter to delete one EditEmployeeName
     *   }
     * })
     * 
    **/
    delete<T extends EditEmployeeNameDeleteArgs>(
      args: SelectSubset<T, EditEmployeeNameDeleteArgs>
    ): Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T>>

    /**
     * Update one EditEmployeeName.
     * @param {EditEmployeeNameUpdateArgs} args - Arguments to update one EditEmployeeName.
     * @example
     * // Update one EditEmployeeName
     * const editEmployeeName = await prisma.editEmployeeName.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EditEmployeeNameUpdateArgs>(
      args: SelectSubset<T, EditEmployeeNameUpdateArgs>
    ): Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T>>

    /**
     * Delete zero or more EditEmployeeNames.
     * @param {EditEmployeeNameDeleteManyArgs} args - Arguments to filter EditEmployeeNames to delete.
     * @example
     * // Delete a few EditEmployeeNames
     * const { count } = await prisma.editEmployeeName.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EditEmployeeNameDeleteManyArgs>(
      args?: SelectSubset<T, EditEmployeeNameDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EditEmployeeNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditEmployeeNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EditEmployeeNames
     * const editEmployeeName = await prisma.editEmployeeName.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EditEmployeeNameUpdateManyArgs>(
      args: SelectSubset<T, EditEmployeeNameUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EditEmployeeName.
     * @param {EditEmployeeNameUpsertArgs} args - Arguments to update or create a EditEmployeeName.
     * @example
     * // Update or create a EditEmployeeName
     * const editEmployeeName = await prisma.editEmployeeName.upsert({
     *   create: {
     *     // ... data to create a EditEmployeeName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EditEmployeeName we want to update
     *   }
     * })
    **/
    upsert<T extends EditEmployeeNameUpsertArgs>(
      args: SelectSubset<T, EditEmployeeNameUpsertArgs>
    ): Prisma__EditEmployeeNameClient<EditEmployeeNameGetPayload<T>>

    /**
     * Count the number of EditEmployeeNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditEmployeeNameCountArgs} args - Arguments to filter EditEmployeeNames to count.
     * @example
     * // Count the number of EditEmployeeNames
     * const count = await prisma.editEmployeeName.count({
     *   where: {
     *     // ... the filter for the EditEmployeeNames we want to count
     *   }
     * })
    **/
    count<T extends EditEmployeeNameCountArgs>(
      args?: Subset<T, EditEmployeeNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EditEmployeeNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EditEmployeeName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditEmployeeNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EditEmployeeNameAggregateArgs>(args: Subset<T, EditEmployeeNameAggregateArgs>): Prisma.PrismaPromise<GetEditEmployeeNameAggregateType<T>>

    /**
     * Group by EditEmployeeName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditEmployeeNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EditEmployeeNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EditEmployeeNameGroupByArgs['orderBy'] }
        : { orderBy?: EditEmployeeNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EditEmployeeNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEditEmployeeNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EditEmployeeName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EditEmployeeNameClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EditEmployeeName base type for findUnique actions
   */
  export type EditEmployeeNameFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * Filter, which EditEmployeeName to fetch.
     */
    where: EditEmployeeNameWhereUniqueInput
  }

  /**
   * EditEmployeeName findUnique
   */
  export interface EditEmployeeNameFindUniqueArgs extends EditEmployeeNameFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EditEmployeeName findUniqueOrThrow
   */
  export type EditEmployeeNameFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * Filter, which EditEmployeeName to fetch.
     */
    where: EditEmployeeNameWhereUniqueInput
  }


  /**
   * EditEmployeeName base type for findFirst actions
   */
  export type EditEmployeeNameFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * Filter, which EditEmployeeName to fetch.
     */
    where?: EditEmployeeNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditEmployeeNames to fetch.
     */
    orderBy?: Enumerable<EditEmployeeNameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EditEmployeeNames.
     */
    cursor?: EditEmployeeNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditEmployeeNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditEmployeeNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EditEmployeeNames.
     */
    distinct?: Enumerable<EditEmployeeNameScalarFieldEnum>
  }

  /**
   * EditEmployeeName findFirst
   */
  export interface EditEmployeeNameFindFirstArgs extends EditEmployeeNameFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EditEmployeeName findFirstOrThrow
   */
  export type EditEmployeeNameFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * Filter, which EditEmployeeName to fetch.
     */
    where?: EditEmployeeNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditEmployeeNames to fetch.
     */
    orderBy?: Enumerable<EditEmployeeNameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EditEmployeeNames.
     */
    cursor?: EditEmployeeNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditEmployeeNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditEmployeeNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EditEmployeeNames.
     */
    distinct?: Enumerable<EditEmployeeNameScalarFieldEnum>
  }


  /**
   * EditEmployeeName findMany
   */
  export type EditEmployeeNameFindManyArgs = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * Filter, which EditEmployeeNames to fetch.
     */
    where?: EditEmployeeNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EditEmployeeNames to fetch.
     */
    orderBy?: Enumerable<EditEmployeeNameOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EditEmployeeNames.
     */
    cursor?: EditEmployeeNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EditEmployeeNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EditEmployeeNames.
     */
    skip?: number
    distinct?: Enumerable<EditEmployeeNameScalarFieldEnum>
  }


  /**
   * EditEmployeeName create
   */
  export type EditEmployeeNameCreateArgs = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * The data needed to create a EditEmployeeName.
     */
    data: XOR<EditEmployeeNameCreateInput, EditEmployeeNameUncheckedCreateInput>
  }


  /**
   * EditEmployeeName createMany
   */
  export type EditEmployeeNameCreateManyArgs = {
    /**
     * The data used to create many EditEmployeeNames.
     */
    data: Enumerable<EditEmployeeNameCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EditEmployeeName update
   */
  export type EditEmployeeNameUpdateArgs = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * The data needed to update a EditEmployeeName.
     */
    data: XOR<EditEmployeeNameUpdateInput, EditEmployeeNameUncheckedUpdateInput>
    /**
     * Choose, which EditEmployeeName to update.
     */
    where: EditEmployeeNameWhereUniqueInput
  }


  /**
   * EditEmployeeName updateMany
   */
  export type EditEmployeeNameUpdateManyArgs = {
    /**
     * The data used to update EditEmployeeNames.
     */
    data: XOR<EditEmployeeNameUpdateManyMutationInput, EditEmployeeNameUncheckedUpdateManyInput>
    /**
     * Filter which EditEmployeeNames to update
     */
    where?: EditEmployeeNameWhereInput
  }


  /**
   * EditEmployeeName upsert
   */
  export type EditEmployeeNameUpsertArgs = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * The filter to search for the EditEmployeeName to update in case it exists.
     */
    where: EditEmployeeNameWhereUniqueInput
    /**
     * In case the EditEmployeeName found by the `where` argument doesn't exist, create a new EditEmployeeName with this data.
     */
    create: XOR<EditEmployeeNameCreateInput, EditEmployeeNameUncheckedCreateInput>
    /**
     * In case the EditEmployeeName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EditEmployeeNameUpdateInput, EditEmployeeNameUncheckedUpdateInput>
  }


  /**
   * EditEmployeeName delete
   */
  export type EditEmployeeNameDeleteArgs = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
    /**
     * Filter which EditEmployeeName to delete.
     */
    where: EditEmployeeNameWhereUniqueInput
  }


  /**
   * EditEmployeeName deleteMany
   */
  export type EditEmployeeNameDeleteManyArgs = {
    /**
     * Filter which EditEmployeeNames to delete
     */
    where?: EditEmployeeNameWhereInput
  }


  /**
   * EditEmployeeName without action
   */
  export type EditEmployeeNameArgs = {
    /**
     * Select specific fields to fetch from the EditEmployeeName
     */
    select?: EditEmployeeNameSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AboutMeansScalarFieldEnum: {
    id: 'id',
    code: 'code',
    toolDetails: 'toolDetails',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AboutMeansScalarFieldEnum = (typeof AboutMeansScalarFieldEnum)[keyof typeof AboutMeansScalarFieldEnum]


  export const AsDetectedScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AsDetectedScalarFieldEnum = (typeof AsDetectedScalarFieldEnum)[keyof typeof AsDetectedScalarFieldEnum]


  export const AttackedDomainEmailScalarFieldEnum: {
    id: 'id',
    code: 'code',
    email: 'email',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttackedDomainEmailScalarFieldEnum = (typeof AttackedDomainEmailScalarFieldEnum)[keyof typeof AttackedDomainEmailScalarFieldEnum]


  export const AttackedDomainScalarFieldEnum: {
    id: 'id',
    hosting: 'hosting',
    domainSupport: 'domainSupport',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttackedDomainScalarFieldEnum = (typeof AttackedDomainScalarFieldEnum)[keyof typeof AttackedDomainScalarFieldEnum]


  export const AttackedDomainUriScalarFieldEnum: {
    id: 'id',
    code: 'code',
    organizationWebsite: 'organizationWebsite',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttackedDomainUriScalarFieldEnum = (typeof AttackedDomainUriScalarFieldEnum)[keyof typeof AttackedDomainUriScalarFieldEnum]


  export const ConfidentialityScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConfidentialityScalarFieldEnum = (typeof ConfidentialityScalarFieldEnum)[keyof typeof ConfidentialityScalarFieldEnum]


  export const CurrentStatusScalarFieldEnum: {
    id: 'id',
    code: 'code',
    nameStatus: 'nameStatus',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CurrentStatusScalarFieldEnum = (typeof CurrentStatusScalarFieldEnum)[keyof typeof CurrentStatusScalarFieldEnum]


  export const DamageFactorsScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DamageFactorsScalarFieldEnum = (typeof DamageFactorsScalarFieldEnum)[keyof typeof DamageFactorsScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    listOrgId: 'listOrgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const DetectedStatusScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DetectedStatusScalarFieldEnum = (typeof DetectedStatusScalarFieldEnum)[keyof typeof DetectedStatusScalarFieldEnum]


  export const EditEmployeeNameScalarFieldEnum: {
    id: 'id',
    code: 'code',
    fullName: 'fullName',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EditEmployeeNameScalarFieldEnum = (typeof EditEmployeeNameScalarFieldEnum)[keyof typeof EditEmployeeNameScalarFieldEnum]


  export const EmployeeNameScalarFieldEnum: {
    id: 'id',
    code: 'code',
    fullName: 'fullName',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeNameScalarFieldEnum = (typeof EmployeeNameScalarFieldEnum)[keyof typeof EmployeeNameScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    organization: 'organization',
    departmentId: 'departmentId',
    position: 'position',
    email: 'email',
    phone: 'phone',
    roleId: 'roleId',
    photo: 'photo',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const GroupComponentsScalarFieldEnum: {
    id: 'id',
    code: 'code',
    nameGroup: 'nameGroup',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GroupComponentsScalarFieldEnum = (typeof GroupComponentsScalarFieldEnum)[keyof typeof GroupComponentsScalarFieldEnum]


  export const HarmfulDomainEmailScalarFieldEnum: {
    id: 'id',
    code: 'code',
    email: 'email',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HarmfulDomainEmailScalarFieldEnum = (typeof HarmfulDomainEmailScalarFieldEnum)[keyof typeof HarmfulDomainEmailScalarFieldEnum]


  export const HarmfulDomainScalarFieldEnum: {
    id: 'id',
    hosting: 'hosting',
    domainSupport: 'domainSupport',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HarmfulDomainScalarFieldEnum = (typeof HarmfulDomainScalarFieldEnum)[keyof typeof HarmfulDomainScalarFieldEnum]


  export const HarmfulDomainUriScalarFieldEnum: {
    id: 'id',
    code: 'code',
    organizationWebsite: 'organizationWebsite',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HarmfulDomainUriScalarFieldEnum = (typeof HarmfulDomainUriScalarFieldEnum)[keyof typeof HarmfulDomainUriScalarFieldEnum]


  export const HotLineScalarFieldEnum: {
    id: 'id',
    date: 'date',
    fullName: 'fullName',
    contact: 'contact',
    description: 'description',
    answer: 'answer',
    employeeId: 'employeeId',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotLineScalarFieldEnum = (typeof HotLineScalarFieldEnum)[keyof typeof HotLineScalarFieldEnum]


  export const ImpactComponentScalarFieldEnum: {
    id: 'id',
    code: 'code',
    impactComponents: 'impactComponents',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImpactComponentScalarFieldEnum = (typeof ImpactComponentScalarFieldEnum)[keyof typeof ImpactComponentScalarFieldEnum]


  export const ImpactObjectScalarFieldEnum: {
    id: 'id',
    code: 'code',
    objectsInfluence: 'objectsInfluence',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImpactObjectScalarFieldEnum = (typeof ImpactObjectScalarFieldEnum)[keyof typeof ImpactObjectScalarFieldEnum]


  export const ListOrgScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ListOrgScalarFieldEnum = (typeof ListOrgScalarFieldEnum)[keyof typeof ListOrgScalarFieldEnum]


  export const MarkLimitScalarFieldEnum: {
    id: 'id',
    code: 'code',
    privacySymbol: 'privacySymbol',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarkLimitScalarFieldEnum = (typeof MarkLimitScalarFieldEnum)[keyof typeof MarkLimitScalarFieldEnum]


  export const MethodViolatorScalarFieldEnum: {
    id: 'id',
    techniqueCode: 'techniqueCode',
    nameTechnique: 'nameTechnique',
    MITRECode: 'MITRECode',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MethodViolatorScalarFieldEnum = (typeof MethodViolatorScalarFieldEnum)[keyof typeof MethodViolatorScalarFieldEnum]


  export const MotivationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    hackerGroups: 'hackerGroups',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MotivationScalarFieldEnum = (typeof MotivationScalarFieldEnum)[keyof typeof MotivationScalarFieldEnum]


  export const PersonalScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    positionId: 'positionId',
    listOrgId: 'listOrgId',
    departmentId: 'departmentId',
    subDepartmentId: 'subDepartmentId',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PersonalScalarFieldEnum = (typeof PersonalScalarFieldEnum)[keyof typeof PersonalScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    listOrgId: 'listOrgId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ResGeographyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    geographicregions: 'geographicregions',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResGeographyScalarFieldEnum = (typeof ResGeographyScalarFieldEnum)[keyof typeof ResGeographyScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const ServiceSueScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceSueScalarFieldEnum = (typeof ServiceSueScalarFieldEnum)[keyof typeof ServiceSueScalarFieldEnum]


  export const SeverityLevelScalarFieldEnum: {
    id: 'id',
    code: 'code',
    severityLevel: 'severityLevel',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeverityLevelScalarFieldEnum = (typeof SeverityLevelScalarFieldEnum)[keyof typeof SeverityLevelScalarFieldEnum]


  export const SortForceScalarFieldEnum: {
    id: 'id',
    code: 'code',
    incidentSeverity: 'incidentSeverity',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SortForceScalarFieldEnum = (typeof SortForceScalarFieldEnum)[keyof typeof SortForceScalarFieldEnum]


  export const SortGravityScalarFieldEnum: {
    id: 'id',
    code: 'code',
    incidentSeverity: 'incidentSeverity',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SortGravityScalarFieldEnum = (typeof SortGravityScalarFieldEnum)[keyof typeof SortGravityScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubDepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    departmentId: 'departmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubDepartmentScalarFieldEnum = (typeof SubDepartmentScalarFieldEnum)[keyof typeof SubDepartmentScalarFieldEnum]


  export const SubjectDamageScalarFieldEnum: {
    id: 'id',
    code: 'code',
    damage: 'damage',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectDamageScalarFieldEnum = (typeof SubjectDamageScalarFieldEnum)[keyof typeof SubjectDamageScalarFieldEnum]


  export const TacticsViolatorScalarFieldEnum: {
    id: 'id',
    code: 'code',
    objectAttack: 'objectAttack',
    stages: 'stages',
    description: 'description',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TacticsViolatorScalarFieldEnum = (typeof TacticsViolatorScalarFieldEnum)[keyof typeof TacticsViolatorScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TypeComponentsScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TypeComponentsScalarFieldEnum = (typeof TypeComponentsScalarFieldEnum)[keyof typeof TypeComponentsScalarFieldEnum]


  export const TypeComputerScalarFieldEnum: {
    id: 'id',
    incidentTypes: 'incidentTypes',
    code: 'code',
    vector: 'vector',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TypeComputerScalarFieldEnum = (typeof TypeComputerScalarFieldEnum)[keyof typeof TypeComputerScalarFieldEnum]


  export const TypeIncidentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameuz: 'nameuz',
    nameru: 'nameru',
    code: 'code',
    vector: 'vector',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TypeIncidentScalarFieldEnum = (typeof TypeIncidentScalarFieldEnum)[keyof typeof TypeIncidentScalarFieldEnum]


  export const TypicalThreatScalarFieldEnum: {
    id: 'id',
    gangTools: 'gangTools',
    toolType: 'toolType',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TypicalThreatScalarFieldEnum = (typeof TypicalThreatScalarFieldEnum)[keyof typeof TypicalThreatScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    refreshToken: 'refreshToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VulnerabilityScalarFieldEnum: {
    id: 'id',
    code: 'code',
    cellPhone: 'cellPhone',
    nameuz: 'nameuz',
    nameru: 'nameru',
    creatorId: 'creatorId',
    editorId: 'editorId',
    removerId: 'removerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VulnerabilityScalarFieldEnum = (typeof VulnerabilityScalarFieldEnum)[keyof typeof VulnerabilityScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    username?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: Enumerable<EmployeeWhereInput>
    OR?: Enumerable<EmployeeWhereInput>
    NOT?: Enumerable<EmployeeWhereInput>
    id?: StringFilter | string
    fullName?: StringFilter | string
    organization?: StringFilter | string
    departmentId?: StringFilter | string
    position?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    roleId?: StringFilter | string
    photo?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    role?: XOR<RoleRelationFilter, RoleWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    organization?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    roleId?: SortOrder
    photo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EmployeeWhereUniqueInput = {
    id?: string
    email?: string
    userId?: string
  }

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    organization?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    roleId?: SortOrder
    photo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmployeeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    organization?: StringWithAggregatesFilter | string
    departmentId?: StringWithAggregatesFilter | string
    position?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    roleId?: StringWithAggregatesFilter | string
    photo?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: Enumerable<DepartmentWhereInput>
    OR?: Enumerable<DepartmentWhereInput>
    NOT?: Enumerable<DepartmentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringNullableFilter | string | null
    nameru?: StringNullableFilter | string | null
    listOrgId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    listOrg?: XOR<ListOrgRelationFilter, ListOrgWhereInput>
    employee?: EmployeeListRelationFilter
    personal?: PersonalListRelationFilter
    subdepartment?: SubDepartmentListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listOrg?: ListOrgOrderByWithRelationInput
    employee?: EmployeeOrderByRelationAggregateInput
    personal?: PersonalOrderByRelationAggregateInput
    subdepartment?: SubDepartmentOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DepartmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DepartmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DepartmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringNullableWithAggregatesFilter | string | null
    nameru?: StringNullableWithAggregatesFilter | string | null
    listOrgId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubDepartmentWhereInput = {
    AND?: Enumerable<SubDepartmentWhereInput>
    OR?: Enumerable<SubDepartmentWhereInput>
    NOT?: Enumerable<SubDepartmentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringNullableFilter | string | null
    nameru?: StringNullableFilter | string | null
    departmentId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    personal?: PersonalListRelationFilter
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
  }

  export type SubDepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personal?: PersonalOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
  }

  export type SubDepartmentWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type SubDepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubDepartmentCountOrderByAggregateInput
    _max?: SubDepartmentMaxOrderByAggregateInput
    _min?: SubDepartmentMinOrderByAggregateInput
  }

  export type SubDepartmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubDepartmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubDepartmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubDepartmentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringNullableWithAggregatesFilter | string | null
    nameru?: StringNullableWithAggregatesFilter | string | null
    departmentId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    employee?: EmployeeListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RoleScalarWhereWithAggregatesInput>
    OR?: Enumerable<RoleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RoleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PositionWhereInput = {
    AND?: Enumerable<PositionWhereInput>
    OR?: Enumerable<PositionWhereInput>
    NOT?: Enumerable<PositionWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringNullableFilter | string | null
    nameru?: StringNullableFilter | string | null
    listOrgId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    personal?: PersonalListRelationFilter
    listOrg?: XOR<ListOrgRelationFilter, ListOrgWhereInput>
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    personal?: PersonalOrderByRelationAggregateInput
    listOrg?: ListOrgOrderByWithRelationInput
  }

  export type PositionWhereUniqueInput = {
    id?: string
  }

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PositionScalarWhereWithAggregatesInput>
    OR?: Enumerable<PositionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PositionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringNullableWithAggregatesFilter | string | null
    nameru?: StringNullableWithAggregatesFilter | string | null
    listOrgId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TypeIncidentWhereInput = {
    AND?: Enumerable<TypeIncidentWhereInput>
    OR?: Enumerable<TypeIncidentWhereInput>
    NOT?: Enumerable<TypeIncidentWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    code?: StringFilter | string
    vector?: StringFilter | string
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TypeIncidentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeIncidentWhereUniqueInput = {
    id?: string
    name?: string
    code?: string
  }

  export type TypeIncidentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TypeIncidentCountOrderByAggregateInput
    _max?: TypeIncidentMaxOrderByAggregateInput
    _min?: TypeIncidentMinOrderByAggregateInput
  }

  export type TypeIncidentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypeIncidentScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypeIncidentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypeIncidentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    vector?: StringWithAggregatesFilter | string
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ListOrgWhereInput = {
    AND?: Enumerable<ListOrgWhereInput>
    OR?: Enumerable<ListOrgWhereInput>
    NOT?: Enumerable<ListOrgWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringNullableFilter | string | null
    nameru?: StringNullableFilter | string | null
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    department?: DepartmentListRelationFilter
    personal?: PersonalListRelationFilter
    position?: PositionListRelationFilter
  }

  export type ListOrgOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByRelationAggregateInput
    personal?: PersonalOrderByRelationAggregateInput
    position?: PositionOrderByRelationAggregateInput
  }

  export type ListOrgWhereUniqueInput = {
    id?: string
  }

  export type ListOrgOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ListOrgCountOrderByAggregateInput
    _max?: ListOrgMaxOrderByAggregateInput
    _min?: ListOrgMinOrderByAggregateInput
  }

  export type ListOrgScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ListOrgScalarWhereWithAggregatesInput>
    OR?: Enumerable<ListOrgScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ListOrgScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringNullableWithAggregatesFilter | string | null
    nameru?: StringNullableWithAggregatesFilter | string | null
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PersonalWhereInput = {
    AND?: Enumerable<PersonalWhereInput>
    OR?: Enumerable<PersonalWhereInput>
    NOT?: Enumerable<PersonalWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    middleName?: StringNullableFilter | string | null
    lastName?: StringFilter | string
    phone?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    positionId?: StringFilter | string
    listOrgId?: StringFilter | string
    departmentId?: StringFilter | string
    subDepartmentId?: StringNullableFilter | string | null
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    department?: XOR<DepartmentRelationFilter, DepartmentWhereInput>
    listOrg?: XOR<ListOrgRelationFilter, ListOrgWhereInput>
    position?: XOR<PositionRelationFilter, PositionWhereInput>
    subDepartment?: XOR<SubDepartmentRelationFilter, SubDepartmentWhereInput> | null
  }

  export type PersonalOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    positionId?: SortOrder
    listOrgId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    listOrg?: ListOrgOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    subDepartment?: SubDepartmentOrderByWithRelationInput
  }

  export type PersonalWhereUniqueInput = {
    id?: string
  }

  export type PersonalOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    positionId?: SortOrder
    listOrgId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PersonalCountOrderByAggregateInput
    _max?: PersonalMaxOrderByAggregateInput
    _min?: PersonalMinOrderByAggregateInput
  }

  export type PersonalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    OR?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PersonalScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    middleName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringWithAggregatesFilter | string
    phone?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    positionId?: StringWithAggregatesFilter | string
    listOrgId?: StringWithAggregatesFilter | string
    departmentId?: StringWithAggregatesFilter | string
    subDepartmentId?: StringNullableWithAggregatesFilter | string | null
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HotLineWhereInput = {
    AND?: Enumerable<HotLineWhereInput>
    OR?: Enumerable<HotLineWhereInput>
    NOT?: Enumerable<HotLineWhereInput>
    id?: StringFilter | string
    date?: DateTimeFilter | Date | string
    fullName?: StringFilter | string
    contact?: StringFilter | string
    description?: StringFilter | string
    answer?: StringFilter | string
    employeeId?: StringFilter | string
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type HotLineOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    fullName?: SortOrder
    contact?: SortOrder
    description?: SortOrder
    answer?: SortOrder
    employeeId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotLineWhereUniqueInput = {
    id?: string
    fullName?: string
  }

  export type HotLineOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    fullName?: SortOrder
    contact?: SortOrder
    description?: SortOrder
    answer?: SortOrder
    employeeId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotLineCountOrderByAggregateInput
    _max?: HotLineMaxOrderByAggregateInput
    _min?: HotLineMinOrderByAggregateInput
  }

  export type HotLineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HotLineScalarWhereWithAggregatesInput>
    OR?: Enumerable<HotLineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HotLineScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    fullName?: StringWithAggregatesFilter | string
    contact?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    answer?: StringWithAggregatesFilter | string
    employeeId?: StringWithAggregatesFilter | string
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ServiceSueWhereInput = {
    AND?: Enumerable<ServiceSueWhereInput>
    OR?: Enumerable<ServiceSueWhereInput>
    NOT?: Enumerable<ServiceSueWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ServiceSueOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSueWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type ServiceSueOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceSueCountOrderByAggregateInput
    _max?: ServiceSueMaxOrderByAggregateInput
    _min?: ServiceSueMinOrderByAggregateInput
  }

  export type ServiceSueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServiceSueScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServiceSueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServiceSueScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TypeComputerWhereInput = {
    AND?: Enumerable<TypeComputerWhereInput>
    OR?: Enumerable<TypeComputerWhereInput>
    NOT?: Enumerable<TypeComputerWhereInput>
    id?: StringFilter | string
    incidentTypes?: StringFilter | string
    code?: StringFilter | string
    vector?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TypeComputerOrderByWithRelationInput = {
    id?: SortOrder
    incidentTypes?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeComputerWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type TypeComputerOrderByWithAggregationInput = {
    id?: SortOrder
    incidentTypes?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TypeComputerCountOrderByAggregateInput
    _max?: TypeComputerMaxOrderByAggregateInput
    _min?: TypeComputerMinOrderByAggregateInput
  }

  export type TypeComputerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypeComputerScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypeComputerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypeComputerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    incidentTypes?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    vector?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AboutMeansWhereInput = {
    AND?: Enumerable<AboutMeansWhereInput>
    OR?: Enumerable<AboutMeansWhereInput>
    NOT?: Enumerable<AboutMeansWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    toolDetails?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AboutMeansOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    toolDetails?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutMeansWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type AboutMeansOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    toolDetails?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AboutMeansCountOrderByAggregateInput
    _max?: AboutMeansMaxOrderByAggregateInput
    _min?: AboutMeansMinOrderByAggregateInput
  }

  export type AboutMeansScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AboutMeansScalarWhereWithAggregatesInput>
    OR?: Enumerable<AboutMeansScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AboutMeansScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    toolDetails?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SeverityLevelWhereInput = {
    AND?: Enumerable<SeverityLevelWhereInput>
    OR?: Enumerable<SeverityLevelWhereInput>
    NOT?: Enumerable<SeverityLevelWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    severityLevel?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SeverityLevelOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    severityLevel?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeverityLevelWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type SeverityLevelOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    severityLevel?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeverityLevelCountOrderByAggregateInput
    _max?: SeverityLevelMaxOrderByAggregateInput
    _min?: SeverityLevelMinOrderByAggregateInput
  }

  export type SeverityLevelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SeverityLevelScalarWhereWithAggregatesInput>
    OR?: Enumerable<SeverityLevelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SeverityLevelScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    severityLevel?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SortForceWhereInput = {
    AND?: Enumerable<SortForceWhereInput>
    OR?: Enumerable<SortForceWhereInput>
    NOT?: Enumerable<SortForceWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    incidentSeverity?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SortForceOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortForceWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type SortForceOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SortForceCountOrderByAggregateInput
    _max?: SortForceMaxOrderByAggregateInput
    _min?: SortForceMinOrderByAggregateInput
  }

  export type SortForceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SortForceScalarWhereWithAggregatesInput>
    OR?: Enumerable<SortForceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SortForceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    incidentSeverity?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SortGravityWhereInput = {
    AND?: Enumerable<SortGravityWhereInput>
    OR?: Enumerable<SortGravityWhereInput>
    NOT?: Enumerable<SortGravityWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    incidentSeverity?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SortGravityOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortGravityWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type SortGravityOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SortGravityCountOrderByAggregateInput
    _max?: SortGravityMaxOrderByAggregateInput
    _min?: SortGravityMinOrderByAggregateInput
  }

  export type SortGravityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SortGravityScalarWhereWithAggregatesInput>
    OR?: Enumerable<SortGravityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SortGravityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    incidentSeverity?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringNullableWithAggregatesFilter | string | null
    editorId?: StringNullableWithAggregatesFilter | string | null
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MarkLimitWhereInput = {
    AND?: Enumerable<MarkLimitWhereInput>
    OR?: Enumerable<MarkLimitWhereInput>
    NOT?: Enumerable<MarkLimitWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    privacySymbol?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MarkLimitOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    privacySymbol?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarkLimitWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type MarkLimitOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    privacySymbol?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarkLimitCountOrderByAggregateInput
    _max?: MarkLimitMaxOrderByAggregateInput
    _min?: MarkLimitMinOrderByAggregateInput
  }

  export type MarkLimitScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MarkLimitScalarWhereWithAggregatesInput>
    OR?: Enumerable<MarkLimitScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MarkLimitScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    privacySymbol?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AttackedDomainWhereInput = {
    AND?: Enumerable<AttackedDomainWhereInput>
    OR?: Enumerable<AttackedDomainWhereInput>
    NOT?: Enumerable<AttackedDomainWhereInput>
    id?: StringFilter | string
    hosting?: StringFilter | string
    domainSupport?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AttackedDomainOrderByWithRelationInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainWhereUniqueInput = {
    id?: string
    domainSupport?: string
  }

  export type AttackedDomainOrderByWithAggregationInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttackedDomainCountOrderByAggregateInput
    _max?: AttackedDomainMaxOrderByAggregateInput
    _min?: AttackedDomainMinOrderByAggregateInput
  }

  export type AttackedDomainScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttackedDomainScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttackedDomainScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttackedDomainScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    hosting?: StringWithAggregatesFilter | string
    domainSupport?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AttackedDomainUriWhereInput = {
    AND?: Enumerable<AttackedDomainUriWhereInput>
    OR?: Enumerable<AttackedDomainUriWhereInput>
    NOT?: Enumerable<AttackedDomainUriWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    organizationWebsite?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AttackedDomainUriOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainUriWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type AttackedDomainUriOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttackedDomainUriCountOrderByAggregateInput
    _max?: AttackedDomainUriMaxOrderByAggregateInput
    _min?: AttackedDomainUriMinOrderByAggregateInput
  }

  export type AttackedDomainUriScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttackedDomainUriScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttackedDomainUriScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttackedDomainUriScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    organizationWebsite?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AttackedDomainEmailWhereInput = {
    AND?: Enumerable<AttackedDomainEmailWhereInput>
    OR?: Enumerable<AttackedDomainEmailWhereInput>
    NOT?: Enumerable<AttackedDomainEmailWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    email?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AttackedDomainEmailOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainEmailWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type AttackedDomainEmailOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttackedDomainEmailCountOrderByAggregateInput
    _max?: AttackedDomainEmailMaxOrderByAggregateInput
    _min?: AttackedDomainEmailMinOrderByAggregateInput
  }

  export type AttackedDomainEmailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AttackedDomainEmailScalarWhereWithAggregatesInput>
    OR?: Enumerable<AttackedDomainEmailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AttackedDomainEmailScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HarmfulDomainWhereInput = {
    AND?: Enumerable<HarmfulDomainWhereInput>
    OR?: Enumerable<HarmfulDomainWhereInput>
    NOT?: Enumerable<HarmfulDomainWhereInput>
    id?: StringFilter | string
    hosting?: StringFilter | string
    domainSupport?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type HarmfulDomainOrderByWithRelationInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainWhereUniqueInput = {
    id?: string
  }

  export type HarmfulDomainOrderByWithAggregationInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HarmfulDomainCountOrderByAggregateInput
    _max?: HarmfulDomainMaxOrderByAggregateInput
    _min?: HarmfulDomainMinOrderByAggregateInput
  }

  export type HarmfulDomainScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HarmfulDomainScalarWhereWithAggregatesInput>
    OR?: Enumerable<HarmfulDomainScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HarmfulDomainScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    hosting?: StringWithAggregatesFilter | string
    domainSupport?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HarmfulDomainUriWhereInput = {
    AND?: Enumerable<HarmfulDomainUriWhereInput>
    OR?: Enumerable<HarmfulDomainUriWhereInput>
    NOT?: Enumerable<HarmfulDomainUriWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    organizationWebsite?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type HarmfulDomainUriOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainUriWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type HarmfulDomainUriOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HarmfulDomainUriCountOrderByAggregateInput
    _max?: HarmfulDomainUriMaxOrderByAggregateInput
    _min?: HarmfulDomainUriMinOrderByAggregateInput
  }

  export type HarmfulDomainUriScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HarmfulDomainUriScalarWhereWithAggregatesInput>
    OR?: Enumerable<HarmfulDomainUriScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HarmfulDomainUriScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    organizationWebsite?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type HarmfulDomainEmailWhereInput = {
    AND?: Enumerable<HarmfulDomainEmailWhereInput>
    OR?: Enumerable<HarmfulDomainEmailWhereInput>
    NOT?: Enumerable<HarmfulDomainEmailWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    email?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type HarmfulDomainEmailOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainEmailWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type HarmfulDomainEmailOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HarmfulDomainEmailCountOrderByAggregateInput
    _max?: HarmfulDomainEmailMaxOrderByAggregateInput
    _min?: HarmfulDomainEmailMinOrderByAggregateInput
  }

  export type HarmfulDomainEmailScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HarmfulDomainEmailScalarWhereWithAggregatesInput>
    OR?: Enumerable<HarmfulDomainEmailScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HarmfulDomainEmailScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type VulnerabilityWhereInput = {
    AND?: Enumerable<VulnerabilityWhereInput>
    OR?: Enumerable<VulnerabilityWhereInput>
    NOT?: Enumerable<VulnerabilityWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    cellPhone?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type VulnerabilityOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    cellPhone?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VulnerabilityWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type VulnerabilityOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    cellPhone?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VulnerabilityCountOrderByAggregateInput
    _max?: VulnerabilityMaxOrderByAggregateInput
    _min?: VulnerabilityMinOrderByAggregateInput
  }

  export type VulnerabilityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VulnerabilityScalarWhereWithAggregatesInput>
    OR?: Enumerable<VulnerabilityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VulnerabilityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    cellPhone?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AsDetectedWhereInput = {
    AND?: Enumerable<AsDetectedWhereInput>
    OR?: Enumerable<AsDetectedWhereInput>
    NOT?: Enumerable<AsDetectedWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AsDetectedOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsDetectedWhereUniqueInput = {
    id?: string
  }

  export type AsDetectedOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AsDetectedCountOrderByAggregateInput
    _max?: AsDetectedMaxOrderByAggregateInput
    _min?: AsDetectedMinOrderByAggregateInput
  }

  export type AsDetectedScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AsDetectedScalarWhereWithAggregatesInput>
    OR?: Enumerable<AsDetectedScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AsDetectedScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DetectedStatusWhereInput = {
    AND?: Enumerable<DetectedStatusWhereInput>
    OR?: Enumerable<DetectedStatusWhereInput>
    NOT?: Enumerable<DetectedStatusWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DetectedStatusOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetectedStatusWhereUniqueInput = {
    id?: string
  }

  export type DetectedStatusOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DetectedStatusCountOrderByAggregateInput
    _max?: DetectedStatusMaxOrderByAggregateInput
    _min?: DetectedStatusMinOrderByAggregateInput
  }

  export type DetectedStatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DetectedStatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<DetectedStatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DetectedStatusScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ImpactObjectWhereInput = {
    AND?: Enumerable<ImpactObjectWhereInput>
    OR?: Enumerable<ImpactObjectWhereInput>
    NOT?: Enumerable<ImpactObjectWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    objectsInfluence?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ImpactObjectOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    objectsInfluence?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpactObjectWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type ImpactObjectOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    objectsInfluence?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImpactObjectCountOrderByAggregateInput
    _max?: ImpactObjectMaxOrderByAggregateInput
    _min?: ImpactObjectMinOrderByAggregateInput
  }

  export type ImpactObjectScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImpactObjectScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImpactObjectScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImpactObjectScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    objectsInfluence?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TypeComponentsWhereInput = {
    AND?: Enumerable<TypeComponentsWhereInput>
    OR?: Enumerable<TypeComponentsWhereInput>
    NOT?: Enumerable<TypeComponentsWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TypeComponentsOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeComponentsWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type TypeComponentsOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TypeComponentsCountOrderByAggregateInput
    _max?: TypeComponentsMaxOrderByAggregateInput
    _min?: TypeComponentsMinOrderByAggregateInput
  }

  export type TypeComponentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypeComponentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypeComponentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypeComponentsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type GroupComponentsWhereInput = {
    AND?: Enumerable<GroupComponentsWhereInput>
    OR?: Enumerable<GroupComponentsWhereInput>
    NOT?: Enumerable<GroupComponentsWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    nameGroup?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type GroupComponentsOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    nameGroup?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupComponentsWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type GroupComponentsOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    nameGroup?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GroupComponentsCountOrderByAggregateInput
    _max?: GroupComponentsMaxOrderByAggregateInput
    _min?: GroupComponentsMinOrderByAggregateInput
  }

  export type GroupComponentsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<GroupComponentsScalarWhereWithAggregatesInput>
    OR?: Enumerable<GroupComponentsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<GroupComponentsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    nameGroup?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ImpactComponentWhereInput = {
    AND?: Enumerable<ImpactComponentWhereInput>
    OR?: Enumerable<ImpactComponentWhereInput>
    NOT?: Enumerable<ImpactComponentWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    impactComponents?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ImpactComponentOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    impactComponents?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpactComponentWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type ImpactComponentOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    impactComponents?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImpactComponentCountOrderByAggregateInput
    _max?: ImpactComponentMaxOrderByAggregateInput
    _min?: ImpactComponentMinOrderByAggregateInput
  }

  export type ImpactComponentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImpactComponentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImpactComponentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImpactComponentScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    impactComponents?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MotivationWhereInput = {
    AND?: Enumerable<MotivationWhereInput>
    OR?: Enumerable<MotivationWhereInput>
    NOT?: Enumerable<MotivationWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    hackerGroups?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MotivationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    hackerGroups?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotivationWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type MotivationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    hackerGroups?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MotivationCountOrderByAggregateInput
    _max?: MotivationMaxOrderByAggregateInput
    _min?: MotivationMinOrderByAggregateInput
  }

  export type MotivationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MotivationScalarWhereWithAggregatesInput>
    OR?: Enumerable<MotivationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MotivationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    hackerGroups?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MethodViolatorWhereInput = {
    AND?: Enumerable<MethodViolatorWhereInput>
    OR?: Enumerable<MethodViolatorWhereInput>
    NOT?: Enumerable<MethodViolatorWhereInput>
    id?: StringFilter | string
    techniqueCode?: StringFilter | string
    nameTechnique?: StringFilter | string
    MITRECode?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type MethodViolatorOrderByWithRelationInput = {
    id?: SortOrder
    techniqueCode?: SortOrder
    nameTechnique?: SortOrder
    MITRECode?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MethodViolatorWhereUniqueInput = {
    id?: string
    techniqueCode?: string
    MITRECode?: string
  }

  export type MethodViolatorOrderByWithAggregationInput = {
    id?: SortOrder
    techniqueCode?: SortOrder
    nameTechnique?: SortOrder
    MITRECode?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MethodViolatorCountOrderByAggregateInput
    _max?: MethodViolatorMaxOrderByAggregateInput
    _min?: MethodViolatorMinOrderByAggregateInput
  }

  export type MethodViolatorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MethodViolatorScalarWhereWithAggregatesInput>
    OR?: Enumerable<MethodViolatorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MethodViolatorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    techniqueCode?: StringWithAggregatesFilter | string
    nameTechnique?: StringWithAggregatesFilter | string
    MITRECode?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TacticsViolatorWhereInput = {
    AND?: Enumerable<TacticsViolatorWhereInput>
    OR?: Enumerable<TacticsViolatorWhereInput>
    NOT?: Enumerable<TacticsViolatorWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    objectAttack?: StringFilter | string
    stages?: StringFilter | string
    description?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TacticsViolatorOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    objectAttack?: SortOrder
    stages?: SortOrder
    description?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TacticsViolatorWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type TacticsViolatorOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    objectAttack?: SortOrder
    stages?: SortOrder
    description?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TacticsViolatorCountOrderByAggregateInput
    _max?: TacticsViolatorMaxOrderByAggregateInput
    _min?: TacticsViolatorMinOrderByAggregateInput
  }

  export type TacticsViolatorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TacticsViolatorScalarWhereWithAggregatesInput>
    OR?: Enumerable<TacticsViolatorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TacticsViolatorScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    objectAttack?: StringWithAggregatesFilter | string
    stages?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TypicalThreatWhereInput = {
    AND?: Enumerable<TypicalThreatWhereInput>
    OR?: Enumerable<TypicalThreatWhereInput>
    NOT?: Enumerable<TypicalThreatWhereInput>
    id?: StringFilter | string
    gangTools?: StringFilter | string
    toolType?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TypicalThreatOrderByWithRelationInput = {
    id?: SortOrder
    gangTools?: SortOrder
    toolType?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypicalThreatWhereUniqueInput = {
    id?: string
  }

  export type TypicalThreatOrderByWithAggregationInput = {
    id?: SortOrder
    gangTools?: SortOrder
    toolType?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TypicalThreatCountOrderByAggregateInput
    _max?: TypicalThreatMaxOrderByAggregateInput
    _min?: TypicalThreatMinOrderByAggregateInput
  }

  export type TypicalThreatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TypicalThreatScalarWhereWithAggregatesInput>
    OR?: Enumerable<TypicalThreatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TypicalThreatScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    gangTools?: StringWithAggregatesFilter | string
    toolType?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ResGeographyWhereInput = {
    AND?: Enumerable<ResGeographyWhereInput>
    OR?: Enumerable<ResGeographyWhereInput>
    NOT?: Enumerable<ResGeographyWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    geographicregions?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ResGeographyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    geographicregions?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResGeographyWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type ResGeographyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    geographicregions?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResGeographyCountOrderByAggregateInput
    _max?: ResGeographyMaxOrderByAggregateInput
    _min?: ResGeographyMinOrderByAggregateInput
  }

  export type ResGeographyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResGeographyScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResGeographyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResGeographyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    geographicregions?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type CurrentStatusWhereInput = {
    AND?: Enumerable<CurrentStatusWhereInput>
    OR?: Enumerable<CurrentStatusWhereInput>
    NOT?: Enumerable<CurrentStatusWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    nameStatus?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CurrentStatusOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    nameStatus?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrentStatusWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type CurrentStatusOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    nameStatus?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CurrentStatusCountOrderByAggregateInput
    _max?: CurrentStatusMaxOrderByAggregateInput
    _min?: CurrentStatusMinOrderByAggregateInput
  }

  export type CurrentStatusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CurrentStatusScalarWhereWithAggregatesInput>
    OR?: Enumerable<CurrentStatusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CurrentStatusScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    nameStatus?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type ConfidentialityWhereInput = {
    AND?: Enumerable<ConfidentialityWhereInput>
    OR?: Enumerable<ConfidentialityWhereInput>
    NOT?: Enumerable<ConfidentialityWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ConfidentialityOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfidentialityWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type ConfidentialityOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConfidentialityCountOrderByAggregateInput
    _max?: ConfidentialityMaxOrderByAggregateInput
    _min?: ConfidentialityMinOrderByAggregateInput
  }

  export type ConfidentialityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConfidentialityScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConfidentialityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConfidentialityScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DamageFactorsWhereInput = {
    AND?: Enumerable<DamageFactorsWhereInput>
    OR?: Enumerable<DamageFactorsWhereInput>
    NOT?: Enumerable<DamageFactorsWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DamageFactorsOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DamageFactorsWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type DamageFactorsOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DamageFactorsCountOrderByAggregateInput
    _max?: DamageFactorsMaxOrderByAggregateInput
    _min?: DamageFactorsMinOrderByAggregateInput
  }

  export type DamageFactorsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DamageFactorsScalarWhereWithAggregatesInput>
    OR?: Enumerable<DamageFactorsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DamageFactorsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SubjectDamageWhereInput = {
    AND?: Enumerable<SubjectDamageWhereInput>
    OR?: Enumerable<SubjectDamageWhereInput>
    NOT?: Enumerable<SubjectDamageWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    damage?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubjectDamageOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    damage?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectDamageWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type SubjectDamageOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    damage?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectDamageCountOrderByAggregateInput
    _max?: SubjectDamageMaxOrderByAggregateInput
    _min?: SubjectDamageMinOrderByAggregateInput
  }

  export type SubjectDamageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SubjectDamageScalarWhereWithAggregatesInput>
    OR?: Enumerable<SubjectDamageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SubjectDamageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    damage?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EmployeeNameWhereInput = {
    AND?: Enumerable<EmployeeNameWhereInput>
    OR?: Enumerable<EmployeeNameWhereInput>
    NOT?: Enumerable<EmployeeNameWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    fullName?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EmployeeNameOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeNameWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type EmployeeNameOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeNameCountOrderByAggregateInput
    _max?: EmployeeNameMaxOrderByAggregateInput
    _min?: EmployeeNameMinOrderByAggregateInput
  }

  export type EmployeeNameScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EmployeeNameScalarWhereWithAggregatesInput>
    OR?: Enumerable<EmployeeNameScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EmployeeNameScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type EditEmployeeNameWhereInput = {
    AND?: Enumerable<EditEmployeeNameWhereInput>
    OR?: Enumerable<EditEmployeeNameWhereInput>
    NOT?: Enumerable<EditEmployeeNameWhereInput>
    id?: StringFilter | string
    code?: StringFilter | string
    fullName?: StringFilter | string
    nameuz?: StringFilter | string
    nameru?: StringFilter | string
    creatorId?: StringFilter | string
    editorId?: StringFilter | string
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type EditEmployeeNameOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditEmployeeNameWhereUniqueInput = {
    id?: string
    code?: string
  }

  export type EditEmployeeNameOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EditEmployeeNameCountOrderByAggregateInput
    _max?: EditEmployeeNameMaxOrderByAggregateInput
    _min?: EditEmployeeNameMinOrderByAggregateInput
  }

  export type EditEmployeeNameScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EditEmployeeNameScalarWhereWithAggregatesInput>
    OR?: Enumerable<EditEmployeeNameScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EditEmployeeNameScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    fullName?: StringWithAggregatesFilter | string
    nameuz?: StringWithAggregatesFilter | string
    nameru?: StringWithAggregatesFilter | string
    creatorId?: StringWithAggregatesFilter | string
    editorId?: StringWithAggregatesFilter | string
    removerId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    password: string
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    password: string
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    password: string
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    fullName: string
    organization: string
    position: string
    email: string
    phone: string
    photo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutEmployeeInput
    role: RoleCreateNestedOneWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    fullName: string
    organization: string
    departmentId: string
    position: string
    email: string
    phone: string
    roleId: string
    photo: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutEmployeeNestedInput
    role?: RoleUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyInput = {
    id?: string
    fullName: string
    organization: string
    departmentId: string
    position: string
    email: string
    phone: string
    roleId: string
    photo: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listOrg: ListOrgCreateNestedOneWithoutDepartmentInput
    employee?: EmployeeCreateNestedManyWithoutDepartmentInput
    personal?: PersonalCreateNestedManyWithoutDepartmentInput
    subdepartment?: SubDepartmentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    listOrgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    personal?: PersonalUncheckedCreateNestedManyWithoutDepartmentInput
    subdepartment?: SubDepartmentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listOrg?: ListOrgUpdateOneRequiredWithoutDepartmentNestedInput
    employee?: EmployeeUpdateManyWithoutDepartmentNestedInput
    personal?: PersonalUpdateManyWithoutDepartmentNestedInput
    subdepartment?: SubDepartmentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    personal?: PersonalUncheckedUpdateManyWithoutDepartmentNestedInput
    subdepartment?: SubDepartmentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    listOrgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDepartmentCreateInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalCreateNestedManyWithoutSubDepartmentInput
    department: DepartmentCreateNestedOneWithoutSubdepartmentInput
  }

  export type SubDepartmentUncheckedCreateInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    departmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalUncheckedCreateNestedManyWithoutSubDepartmentInput
  }

  export type SubDepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUpdateManyWithoutSubDepartmentNestedInput
    department?: DepartmentUpdateOneRequiredWithoutSubdepartmentNestedInput
  }

  export type SubDepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUncheckedUpdateManyWithoutSubDepartmentNestedInput
  }

  export type SubDepartmentCreateManyInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    departmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubDepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionCreateInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalCreateNestedManyWithoutPositionInput
    listOrg: ListOrgCreateNestedOneWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    listOrgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUpdateManyWithoutPositionNestedInput
    listOrg?: ListOrgUpdateOneRequiredWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    listOrgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeIncidentCreateInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    code: string
    vector: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeIncidentUncheckedCreateInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    code: string
    vector: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeIncidentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    vector?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeIncidentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    vector?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeIncidentCreateManyInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    code: string
    vector: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeIncidentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    vector?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeIncidentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    vector?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListOrgCreateInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedManyWithoutListOrgInput
    personal?: PersonalCreateNestedManyWithoutListOrgInput
    position?: PositionCreateNestedManyWithoutListOrgInput
  }

  export type ListOrgUncheckedCreateInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentUncheckedCreateNestedManyWithoutListOrgInput
    personal?: PersonalUncheckedCreateNestedManyWithoutListOrgInput
    position?: PositionUncheckedCreateNestedManyWithoutListOrgInput
  }

  export type ListOrgUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateManyWithoutListOrgNestedInput
    personal?: PersonalUpdateManyWithoutListOrgNestedInput
    position?: PositionUpdateManyWithoutListOrgNestedInput
  }

  export type ListOrgUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUncheckedUpdateManyWithoutListOrgNestedInput
    personal?: PersonalUncheckedUpdateManyWithoutListOrgNestedInput
    position?: PositionUncheckedUpdateManyWithoutListOrgNestedInput
  }

  export type ListOrgCreateManyInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ListOrgUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListOrgUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPersonalInput
    listOrg: ListOrgCreateNestedOneWithoutPersonalInput
    position: PositionCreateNestedOneWithoutPersonalInput
    subDepartment?: SubDepartmentCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    positionId: string
    listOrgId: string
    departmentId: string
    subDepartmentId?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPersonalNestedInput
    listOrg?: ListOrgUpdateOneRequiredWithoutPersonalNestedInput
    position?: PositionUpdateOneRequiredWithoutPersonalNestedInput
    subDepartment?: SubDepartmentUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: StringFieldUpdateOperationsInput | string
    listOrgId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    subDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalCreateManyInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    positionId: string
    listOrgId: string
    departmentId: string
    subDepartmentId?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: StringFieldUpdateOperationsInput | string
    listOrgId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    subDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotLineCreateInput = {
    id?: string
    date?: Date | string
    fullName: string
    contact: string
    description: string
    answer: string
    employeeId: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotLineUncheckedCreateInput = {
    id?: string
    date?: Date | string
    fullName: string
    contact: string
    description: string
    answer: string
    employeeId: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotLineCreateManyInput = {
    id?: string
    date?: Date | string
    fullName: string
    contact: string
    description: string
    answer: string
    employeeId: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    fullName?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSueCreateInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSueUncheckedCreateInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSueCreateManyInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeComputerCreateInput = {
    id?: string
    incidentTypes: string
    code: string
    vector: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeComputerUncheckedCreateInput = {
    id?: string
    incidentTypes: string
    code: string
    vector: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeComputerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentTypes?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    vector?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeComputerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentTypes?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    vector?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeComputerCreateManyInput = {
    id?: string
    incidentTypes: string
    code: string
    vector: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeComputerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentTypes?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    vector?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeComputerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incidentTypes?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    vector?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutMeansCreateInput = {
    id?: string
    code: string
    toolDetails: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutMeansUncheckedCreateInput = {
    id?: string
    code: string
    toolDetails: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutMeansUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    toolDetails?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutMeansUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    toolDetails?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutMeansCreateManyInput = {
    id?: string
    code: string
    toolDetails: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AboutMeansUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    toolDetails?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AboutMeansUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    toolDetails?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeverityLevelCreateInput = {
    id?: string
    code: string
    severityLevel: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeverityLevelUncheckedCreateInput = {
    id?: string
    code: string
    severityLevel: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeverityLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    severityLevel?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeverityLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    severityLevel?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeverityLevelCreateManyInput = {
    id?: string
    code: string
    severityLevel: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeverityLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    severityLevel?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeverityLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    severityLevel?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortForceCreateInput = {
    id?: string
    code: string
    incidentSeverity: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortForceUncheckedCreateInput = {
    id?: string
    code: string
    incidentSeverity: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortForceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    incidentSeverity?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortForceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    incidentSeverity?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortForceCreateManyInput = {
    id?: string
    code: string
    incidentSeverity: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortForceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    incidentSeverity?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortForceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    incidentSeverity?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortGravityCreateInput = {
    id?: string
    code: string
    incidentSeverity: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortGravityUncheckedCreateInput = {
    id?: string
    code: string
    incidentSeverity: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortGravityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    incidentSeverity?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortGravityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    incidentSeverity?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortGravityCreateManyInput = {
    id?: string
    code: string
    incidentSeverity: string
    nameuz: string
    nameru: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SortGravityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    incidentSeverity?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SortGravityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    incidentSeverity?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarkLimitCreateInput = {
    id?: string
    code: string
    privacySymbol: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarkLimitUncheckedCreateInput = {
    id?: string
    code: string
    privacySymbol: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarkLimitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    privacySymbol?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarkLimitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    privacySymbol?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarkLimitCreateManyInput = {
    id?: string
    code: string
    privacySymbol: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarkLimitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    privacySymbol?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarkLimitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    privacySymbol?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainCreateInput = {
    id?: string
    hosting: string
    domainSupport: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainUncheckedCreateInput = {
    id?: string
    hosting: string
    domainSupport: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hosting?: StringFieldUpdateOperationsInput | string
    domainSupport?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hosting?: StringFieldUpdateOperationsInput | string
    domainSupport?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainCreateManyInput = {
    id?: string
    hosting: string
    domainSupport: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hosting?: StringFieldUpdateOperationsInput | string
    domainSupport?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hosting?: StringFieldUpdateOperationsInput | string
    domainSupport?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainUriCreateInput = {
    id?: string
    code: string
    organizationWebsite: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainUriUncheckedCreateInput = {
    id?: string
    code: string
    organizationWebsite: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainUriUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    organizationWebsite?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainUriUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    organizationWebsite?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainUriCreateManyInput = {
    id?: string
    code: string
    organizationWebsite: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainUriUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    organizationWebsite?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainUriUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    organizationWebsite?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainEmailCreateInput = {
    id?: string
    code: string
    email: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainEmailUncheckedCreateInput = {
    id?: string
    code: string
    email: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainEmailCreateManyInput = {
    id?: string
    code: string
    email: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttackedDomainEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttackedDomainEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainCreateInput = {
    id?: string
    hosting: string
    domainSupport: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainUncheckedCreateInput = {
    id?: string
    hosting: string
    domainSupport: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hosting?: StringFieldUpdateOperationsInput | string
    domainSupport?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hosting?: StringFieldUpdateOperationsInput | string
    domainSupport?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainCreateManyInput = {
    id?: string
    hosting: string
    domainSupport: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hosting?: StringFieldUpdateOperationsInput | string
    domainSupport?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hosting?: StringFieldUpdateOperationsInput | string
    domainSupport?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainUriCreateInput = {
    id?: string
    code: string
    organizationWebsite: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainUriUncheckedCreateInput = {
    id?: string
    code: string
    organizationWebsite: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainUriUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    organizationWebsite?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainUriUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    organizationWebsite?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainUriCreateManyInput = {
    id?: string
    code: string
    organizationWebsite: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainUriUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    organizationWebsite?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainUriUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    organizationWebsite?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainEmailCreateInput = {
    id?: string
    code: string
    email: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainEmailUncheckedCreateInput = {
    id?: string
    code: string
    email: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainEmailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainEmailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainEmailCreateManyInput = {
    id?: string
    code: string
    email: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HarmfulDomainEmailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HarmfulDomainEmailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VulnerabilityCreateInput = {
    id?: string
    code: string
    cellPhone: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VulnerabilityUncheckedCreateInput = {
    id?: string
    code: string
    cellPhone: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VulnerabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cellPhone?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VulnerabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cellPhone?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VulnerabilityCreateManyInput = {
    id?: string
    code: string
    cellPhone: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VulnerabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cellPhone?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VulnerabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    cellPhone?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsDetectedCreateInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsDetectedUncheckedCreateInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsDetectedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsDetectedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsDetectedCreateManyInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AsDetectedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AsDetectedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedStatusCreateInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetectedStatusUncheckedCreateInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetectedStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedStatusCreateManyInput = {
    id?: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DetectedStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetectedStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactObjectCreateInput = {
    id?: string
    code: string
    objectsInfluence: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpactObjectUncheckedCreateInput = {
    id?: string
    code: string
    objectsInfluence: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpactObjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    objectsInfluence?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactObjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    objectsInfluence?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactObjectCreateManyInput = {
    id?: string
    code: string
    objectsInfluence: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpactObjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    objectsInfluence?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactObjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    objectsInfluence?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeComponentsCreateInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeComponentsUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeComponentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeComponentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeComponentsCreateManyInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypeComponentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeComponentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupComponentsCreateInput = {
    id?: string
    code: string
    nameGroup: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupComponentsUncheckedCreateInput = {
    id?: string
    code: string
    nameGroup: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupComponentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameGroup?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupComponentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameGroup?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupComponentsCreateManyInput = {
    id?: string
    code: string
    nameGroup: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GroupComponentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameGroup?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupComponentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameGroup?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactComponentCreateInput = {
    id?: string
    code: string
    impactComponents: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpactComponentUncheckedCreateInput = {
    id?: string
    code: string
    impactComponents: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpactComponentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    impactComponents?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactComponentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    impactComponents?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactComponentCreateManyInput = {
    id?: string
    code: string
    impactComponents: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpactComponentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    impactComponents?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpactComponentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    impactComponents?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotivationCreateInput = {
    id?: string
    code: string
    hackerGroups: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotivationUncheckedCreateInput = {
    id?: string
    code: string
    hackerGroups: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotivationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    hackerGroups?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotivationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    hackerGroups?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotivationCreateManyInput = {
    id?: string
    code: string
    hackerGroups: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotivationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    hackerGroups?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotivationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    hackerGroups?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodViolatorCreateInput = {
    id?: string
    techniqueCode: string
    nameTechnique: string
    MITRECode: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MethodViolatorUncheckedCreateInput = {
    id?: string
    techniqueCode: string
    nameTechnique: string
    MITRECode: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MethodViolatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    techniqueCode?: StringFieldUpdateOperationsInput | string
    nameTechnique?: StringFieldUpdateOperationsInput | string
    MITRECode?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodViolatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    techniqueCode?: StringFieldUpdateOperationsInput | string
    nameTechnique?: StringFieldUpdateOperationsInput | string
    MITRECode?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodViolatorCreateManyInput = {
    id?: string
    techniqueCode: string
    nameTechnique: string
    MITRECode: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MethodViolatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    techniqueCode?: StringFieldUpdateOperationsInput | string
    nameTechnique?: StringFieldUpdateOperationsInput | string
    MITRECode?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MethodViolatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    techniqueCode?: StringFieldUpdateOperationsInput | string
    nameTechnique?: StringFieldUpdateOperationsInput | string
    MITRECode?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacticsViolatorCreateInput = {
    id?: string
    code: string
    objectAttack: string
    stages: string
    description: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TacticsViolatorUncheckedCreateInput = {
    id?: string
    code: string
    objectAttack: string
    stages: string
    description: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TacticsViolatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    objectAttack?: StringFieldUpdateOperationsInput | string
    stages?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacticsViolatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    objectAttack?: StringFieldUpdateOperationsInput | string
    stages?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacticsViolatorCreateManyInput = {
    id?: string
    code: string
    objectAttack: string
    stages: string
    description: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TacticsViolatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    objectAttack?: StringFieldUpdateOperationsInput | string
    stages?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TacticsViolatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    objectAttack?: StringFieldUpdateOperationsInput | string
    stages?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypicalThreatCreateInput = {
    id?: string
    gangTools: string
    toolType: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypicalThreatUncheckedCreateInput = {
    id?: string
    gangTools: string
    toolType: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypicalThreatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gangTools?: StringFieldUpdateOperationsInput | string
    toolType?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypicalThreatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gangTools?: StringFieldUpdateOperationsInput | string
    toolType?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypicalThreatCreateManyInput = {
    id?: string
    gangTools: string
    toolType: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TypicalThreatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gangTools?: StringFieldUpdateOperationsInput | string
    toolType?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypicalThreatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    gangTools?: StringFieldUpdateOperationsInput | string
    toolType?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResGeographyCreateInput = {
    id?: string
    code: string
    geographicregions: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResGeographyUncheckedCreateInput = {
    id?: string
    code: string
    geographicregions: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResGeographyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    geographicregions?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResGeographyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    geographicregions?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResGeographyCreateManyInput = {
    id?: string
    code: string
    geographicregions: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResGeographyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    geographicregions?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResGeographyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    geographicregions?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrentStatusCreateInput = {
    id?: string
    code: string
    nameStatus: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrentStatusUncheckedCreateInput = {
    id?: string
    code: string
    nameStatus: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrentStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameStatus?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrentStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameStatus?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrentStatusCreateManyInput = {
    id?: string
    code: string
    nameStatus: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CurrentStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameStatus?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CurrentStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    nameStatus?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfidentialityCreateInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfidentialityUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfidentialityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfidentialityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfidentialityCreateManyInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConfidentialityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfidentialityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageFactorsCreateInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DamageFactorsUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DamageFactorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageFactorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageFactorsCreateManyInput = {
    id?: string
    code: string
    name: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DamageFactorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DamageFactorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectDamageCreateInput = {
    id?: string
    code: string
    damage: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectDamageUncheckedCreateInput = {
    id?: string
    code: string
    damage: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectDamageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectDamageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectDamageCreateManyInput = {
    id?: string
    code: string
    damage: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectDamageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectDamageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    damage?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeNameCreateInput = {
    id?: string
    code: string
    fullName: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeNameUncheckedCreateInput = {
    id?: string
    code: string
    fullName: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeNameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeNameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeNameCreateManyInput = {
    id?: string
    code: string
    fullName: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeNameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeNameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditEmployeeNameCreateInput = {
    id?: string
    code: string
    fullName: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditEmployeeNameUncheckedCreateInput = {
    id?: string
    code: string
    fullName: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditEmployeeNameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditEmployeeNameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditEmployeeNameCreateManyInput = {
    id?: string
    code: string
    fullName: string
    nameuz: string
    nameru: string
    creatorId: string
    editorId: string
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditEmployeeNameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditEmployeeNameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nameuz?: StringFieldUpdateOperationsInput | string
    nameru?: StringFieldUpdateOperationsInput | string
    creatorId?: StringFieldUpdateOperationsInput | string
    editorId?: StringFieldUpdateOperationsInput | string
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    refreshToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DepartmentRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type RoleRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    organization?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    roleId?: SortOrder
    photo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    organization?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    roleId?: SortOrder
    photo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    organization?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    roleId?: SortOrder
    photo?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListOrgRelationFilter = {
    is?: ListOrgWhereInput
    isNot?: ListOrgWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type PersonalListRelationFilter = {
    every?: PersonalWhereInput
    some?: PersonalWhereInput
    none?: PersonalWhereInput
  }

  export type SubDepartmentListRelationFilter = {
    every?: SubDepartmentWhereInput
    some?: SubDepartmentWhereInput
    none?: SubDepartmentWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubDepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubDepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubDepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubDepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    listOrgId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeIncidentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeIncidentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeIncidentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type PositionListRelationFilter = {
    every?: PositionWhereInput
    some?: PositionWhereInput
    none?: PositionWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListOrgCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListOrgMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ListOrgMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionRelationFilter = {
    is?: PositionWhereInput
    isNot?: PositionWhereInput
  }

  export type SubDepartmentRelationFilter = {
    is?: SubDepartmentWhereInput | null
    isNot?: SubDepartmentWhereInput | null
  }

  export type PersonalCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    positionId?: SortOrder
    listOrgId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    positionId?: SortOrder
    listOrgId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PersonalMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    positionId?: SortOrder
    listOrgId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotLineCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    fullName?: SortOrder
    contact?: SortOrder
    description?: SortOrder
    answer?: SortOrder
    employeeId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotLineMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    fullName?: SortOrder
    contact?: SortOrder
    description?: SortOrder
    answer?: SortOrder
    employeeId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotLineMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    fullName?: SortOrder
    contact?: SortOrder
    description?: SortOrder
    answer?: SortOrder
    employeeId?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSueCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSueMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSueMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeComputerCountOrderByAggregateInput = {
    id?: SortOrder
    incidentTypes?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeComputerMaxOrderByAggregateInput = {
    id?: SortOrder
    incidentTypes?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeComputerMinOrderByAggregateInput = {
    id?: SortOrder
    incidentTypes?: SortOrder
    code?: SortOrder
    vector?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutMeansCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    toolDetails?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutMeansMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    toolDetails?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AboutMeansMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    toolDetails?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeverityLevelCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    severityLevel?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeverityLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    severityLevel?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeverityLevelMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    severityLevel?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortForceCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortForceMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortForceMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortGravityCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortGravityMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SortGravityMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    incidentSeverity?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarkLimitCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    privacySymbol?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarkLimitMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    privacySymbol?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarkLimitMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    privacySymbol?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainCountOrderByAggregateInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainMaxOrderByAggregateInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainMinOrderByAggregateInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainUriCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainUriMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainUriMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainEmailCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttackedDomainEmailMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainCountOrderByAggregateInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainMaxOrderByAggregateInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainMinOrderByAggregateInput = {
    id?: SortOrder
    hosting?: SortOrder
    domainSupport?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainUriCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainUriMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainUriMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    organizationWebsite?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainEmailCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainEmailMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HarmfulDomainEmailMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VulnerabilityCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    cellPhone?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VulnerabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    cellPhone?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VulnerabilityMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    cellPhone?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsDetectedCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsDetectedMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AsDetectedMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetectedStatusCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetectedStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DetectedStatusMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpactObjectCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    objectsInfluence?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpactObjectMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    objectsInfluence?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpactObjectMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    objectsInfluence?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeComponentsCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeComponentsMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeComponentsMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupComponentsCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameGroup?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupComponentsMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameGroup?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GroupComponentsMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameGroup?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpactComponentCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    impactComponents?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpactComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    impactComponents?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpactComponentMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    impactComponents?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotivationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    hackerGroups?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotivationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    hackerGroups?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotivationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    hackerGroups?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MethodViolatorCountOrderByAggregateInput = {
    id?: SortOrder
    techniqueCode?: SortOrder
    nameTechnique?: SortOrder
    MITRECode?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MethodViolatorMaxOrderByAggregateInput = {
    id?: SortOrder
    techniqueCode?: SortOrder
    nameTechnique?: SortOrder
    MITRECode?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MethodViolatorMinOrderByAggregateInput = {
    id?: SortOrder
    techniqueCode?: SortOrder
    nameTechnique?: SortOrder
    MITRECode?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TacticsViolatorCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    objectAttack?: SortOrder
    stages?: SortOrder
    description?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TacticsViolatorMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    objectAttack?: SortOrder
    stages?: SortOrder
    description?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TacticsViolatorMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    objectAttack?: SortOrder
    stages?: SortOrder
    description?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypicalThreatCountOrderByAggregateInput = {
    id?: SortOrder
    gangTools?: SortOrder
    toolType?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypicalThreatMaxOrderByAggregateInput = {
    id?: SortOrder
    gangTools?: SortOrder
    toolType?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypicalThreatMinOrderByAggregateInput = {
    id?: SortOrder
    gangTools?: SortOrder
    toolType?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResGeographyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    geographicregions?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResGeographyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    geographicregions?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResGeographyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    geographicregions?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrentStatusCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameStatus?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrentStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameStatus?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CurrentStatusMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    nameStatus?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfidentialityCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfidentialityMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConfidentialityMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DamageFactorsCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DamageFactorsMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DamageFactorsMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectDamageCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    damage?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectDamageMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    damage?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectDamageMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    damage?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeNameCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeNameMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeNameMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditEmployeeNameCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditEmployeeNameMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditEmployeeNameMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    fullName?: SortOrder
    nameuz?: SortOrder
    nameru?: SortOrder
    creatorId?: SortOrder
    editorId?: SortOrder
    removerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type DepartmentCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<DepartmentCreateWithoutEmployeeInput, DepartmentUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeeInput
    connect?: DepartmentWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<RoleCreateWithoutEmployeeInput, RoleUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeeInput
    connect?: RoleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<DepartmentCreateWithoutEmployeeInput, DepartmentUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeeInput
    upsert?: DepartmentUpsertWithoutEmployeeInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<DepartmentUpdateWithoutEmployeeInput, DepartmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type RoleUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<RoleCreateWithoutEmployeeInput, RoleUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: RoleCreateOrConnectWithoutEmployeeInput
    upsert?: RoleUpsertWithoutEmployeeInput
    connect?: RoleWhereUniqueInput
    update?: XOR<RoleUpdateWithoutEmployeeInput, RoleUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type ListOrgCreateNestedOneWithoutDepartmentInput = {
    create?: XOR<ListOrgCreateWithoutDepartmentInput, ListOrgUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: ListOrgCreateOrConnectWithoutDepartmentInput
    connect?: ListOrgWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutDepartmentInput>, Enumerable<EmployeeUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutDepartmentInput>
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type PersonalCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutDepartmentInput>, Enumerable<PersonalUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutDepartmentInput>
    createMany?: PersonalCreateManyDepartmentInputEnvelope
    connect?: Enumerable<PersonalWhereUniqueInput>
  }

  export type SubDepartmentCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<SubDepartmentCreateWithoutDepartmentInput>, Enumerable<SubDepartmentUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<SubDepartmentCreateOrConnectWithoutDepartmentInput>
    createMany?: SubDepartmentCreateManyDepartmentInputEnvelope
    connect?: Enumerable<SubDepartmentWhereUniqueInput>
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutDepartmentInput>, Enumerable<EmployeeUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutDepartmentInput>
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type PersonalUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutDepartmentInput>, Enumerable<PersonalUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutDepartmentInput>
    createMany?: PersonalCreateManyDepartmentInputEnvelope
    connect?: Enumerable<PersonalWhereUniqueInput>
  }

  export type SubDepartmentUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<Enumerable<SubDepartmentCreateWithoutDepartmentInput>, Enumerable<SubDepartmentUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<SubDepartmentCreateOrConnectWithoutDepartmentInput>
    createMany?: SubDepartmentCreateManyDepartmentInputEnvelope
    connect?: Enumerable<SubDepartmentWhereUniqueInput>
  }

  export type ListOrgUpdateOneRequiredWithoutDepartmentNestedInput = {
    create?: XOR<ListOrgCreateWithoutDepartmentInput, ListOrgUncheckedCreateWithoutDepartmentInput>
    connectOrCreate?: ListOrgCreateOrConnectWithoutDepartmentInput
    upsert?: ListOrgUpsertWithoutDepartmentInput
    connect?: ListOrgWhereUniqueInput
    update?: XOR<ListOrgUpdateWithoutDepartmentInput, ListOrgUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutDepartmentInput>, Enumerable<EmployeeUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutDepartmentInput>
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type PersonalUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutDepartmentInput>, Enumerable<PersonalUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<PersonalUpsertWithWhereUniqueWithoutDepartmentInput>
    createMany?: PersonalCreateManyDepartmentInputEnvelope
    set?: Enumerable<PersonalWhereUniqueInput>
    disconnect?: Enumerable<PersonalWhereUniqueInput>
    delete?: Enumerable<PersonalWhereUniqueInput>
    connect?: Enumerable<PersonalWhereUniqueInput>
    update?: Enumerable<PersonalUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<PersonalUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<PersonalScalarWhereInput>
  }

  export type SubDepartmentUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<Enumerable<SubDepartmentCreateWithoutDepartmentInput>, Enumerable<SubDepartmentUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<SubDepartmentCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<SubDepartmentUpsertWithWhereUniqueWithoutDepartmentInput>
    createMany?: SubDepartmentCreateManyDepartmentInputEnvelope
    set?: Enumerable<SubDepartmentWhereUniqueInput>
    disconnect?: Enumerable<SubDepartmentWhereUniqueInput>
    delete?: Enumerable<SubDepartmentWhereUniqueInput>
    connect?: Enumerable<SubDepartmentWhereUniqueInput>
    update?: Enumerable<SubDepartmentUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<SubDepartmentUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<SubDepartmentScalarWhereInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutDepartmentInput>, Enumerable<EmployeeUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutDepartmentInput>
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type PersonalUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutDepartmentInput>, Enumerable<PersonalUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<PersonalUpsertWithWhereUniqueWithoutDepartmentInput>
    createMany?: PersonalCreateManyDepartmentInputEnvelope
    set?: Enumerable<PersonalWhereUniqueInput>
    disconnect?: Enumerable<PersonalWhereUniqueInput>
    delete?: Enumerable<PersonalWhereUniqueInput>
    connect?: Enumerable<PersonalWhereUniqueInput>
    update?: Enumerable<PersonalUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<PersonalUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<PersonalScalarWhereInput>
  }

  export type SubDepartmentUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<Enumerable<SubDepartmentCreateWithoutDepartmentInput>, Enumerable<SubDepartmentUncheckedCreateWithoutDepartmentInput>>
    connectOrCreate?: Enumerable<SubDepartmentCreateOrConnectWithoutDepartmentInput>
    upsert?: Enumerable<SubDepartmentUpsertWithWhereUniqueWithoutDepartmentInput>
    createMany?: SubDepartmentCreateManyDepartmentInputEnvelope
    set?: Enumerable<SubDepartmentWhereUniqueInput>
    disconnect?: Enumerable<SubDepartmentWhereUniqueInput>
    delete?: Enumerable<SubDepartmentWhereUniqueInput>
    connect?: Enumerable<SubDepartmentWhereUniqueInput>
    update?: Enumerable<SubDepartmentUpdateWithWhereUniqueWithoutDepartmentInput>
    updateMany?: Enumerable<SubDepartmentUpdateManyWithWhereWithoutDepartmentInput>
    deleteMany?: Enumerable<SubDepartmentScalarWhereInput>
  }

  export type PersonalCreateNestedManyWithoutSubDepartmentInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutSubDepartmentInput>, Enumerable<PersonalUncheckedCreateWithoutSubDepartmentInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutSubDepartmentInput>
    createMany?: PersonalCreateManySubDepartmentInputEnvelope
    connect?: Enumerable<PersonalWhereUniqueInput>
  }

  export type DepartmentCreateNestedOneWithoutSubdepartmentInput = {
    create?: XOR<DepartmentCreateWithoutSubdepartmentInput, DepartmentUncheckedCreateWithoutSubdepartmentInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSubdepartmentInput
    connect?: DepartmentWhereUniqueInput
  }

  export type PersonalUncheckedCreateNestedManyWithoutSubDepartmentInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutSubDepartmentInput>, Enumerable<PersonalUncheckedCreateWithoutSubDepartmentInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutSubDepartmentInput>
    createMany?: PersonalCreateManySubDepartmentInputEnvelope
    connect?: Enumerable<PersonalWhereUniqueInput>
  }

  export type PersonalUpdateManyWithoutSubDepartmentNestedInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutSubDepartmentInput>, Enumerable<PersonalUncheckedCreateWithoutSubDepartmentInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutSubDepartmentInput>
    upsert?: Enumerable<PersonalUpsertWithWhereUniqueWithoutSubDepartmentInput>
    createMany?: PersonalCreateManySubDepartmentInputEnvelope
    set?: Enumerable<PersonalWhereUniqueInput>
    disconnect?: Enumerable<PersonalWhereUniqueInput>
    delete?: Enumerable<PersonalWhereUniqueInput>
    connect?: Enumerable<PersonalWhereUniqueInput>
    update?: Enumerable<PersonalUpdateWithWhereUniqueWithoutSubDepartmentInput>
    updateMany?: Enumerable<PersonalUpdateManyWithWhereWithoutSubDepartmentInput>
    deleteMany?: Enumerable<PersonalScalarWhereInput>
  }

  export type DepartmentUpdateOneRequiredWithoutSubdepartmentNestedInput = {
    create?: XOR<DepartmentCreateWithoutSubdepartmentInput, DepartmentUncheckedCreateWithoutSubdepartmentInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSubdepartmentInput
    upsert?: DepartmentUpsertWithoutSubdepartmentInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<DepartmentUpdateWithoutSubdepartmentInput, DepartmentUncheckedUpdateWithoutSubdepartmentInput>
  }

  export type PersonalUncheckedUpdateManyWithoutSubDepartmentNestedInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutSubDepartmentInput>, Enumerable<PersonalUncheckedCreateWithoutSubDepartmentInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutSubDepartmentInput>
    upsert?: Enumerable<PersonalUpsertWithWhereUniqueWithoutSubDepartmentInput>
    createMany?: PersonalCreateManySubDepartmentInputEnvelope
    set?: Enumerable<PersonalWhereUniqueInput>
    disconnect?: Enumerable<PersonalWhereUniqueInput>
    delete?: Enumerable<PersonalWhereUniqueInput>
    connect?: Enumerable<PersonalWhereUniqueInput>
    update?: Enumerable<PersonalUpdateWithWhereUniqueWithoutSubDepartmentInput>
    updateMany?: Enumerable<PersonalUpdateManyWithWhereWithoutSubDepartmentInput>
    deleteMany?: Enumerable<PersonalScalarWhereInput>
  }

  export type EmployeeCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutRoleInput>, Enumerable<EmployeeUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutRoleInput>
    createMany?: EmployeeCreateManyRoleInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type EmployeeUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutRoleInput>, Enumerable<EmployeeUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutRoleInput>
    createMany?: EmployeeCreateManyRoleInputEnvelope
    connect?: Enumerable<EmployeeWhereUniqueInput>
  }

  export type EmployeeUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutRoleInput>, Enumerable<EmployeeUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: EmployeeCreateManyRoleInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<Enumerable<EmployeeCreateWithoutRoleInput>, Enumerable<EmployeeUncheckedCreateWithoutRoleInput>>
    connectOrCreate?: Enumerable<EmployeeCreateOrConnectWithoutRoleInput>
    upsert?: Enumerable<EmployeeUpsertWithWhereUniqueWithoutRoleInput>
    createMany?: EmployeeCreateManyRoleInputEnvelope
    set?: Enumerable<EmployeeWhereUniqueInput>
    disconnect?: Enumerable<EmployeeWhereUniqueInput>
    delete?: Enumerable<EmployeeWhereUniqueInput>
    connect?: Enumerable<EmployeeWhereUniqueInput>
    update?: Enumerable<EmployeeUpdateWithWhereUniqueWithoutRoleInput>
    updateMany?: Enumerable<EmployeeUpdateManyWithWhereWithoutRoleInput>
    deleteMany?: Enumerable<EmployeeScalarWhereInput>
  }

  export type PersonalCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutPositionInput>, Enumerable<PersonalUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutPositionInput>
    createMany?: PersonalCreateManyPositionInputEnvelope
    connect?: Enumerable<PersonalWhereUniqueInput>
  }

  export type ListOrgCreateNestedOneWithoutPositionInput = {
    create?: XOR<ListOrgCreateWithoutPositionInput, ListOrgUncheckedCreateWithoutPositionInput>
    connectOrCreate?: ListOrgCreateOrConnectWithoutPositionInput
    connect?: ListOrgWhereUniqueInput
  }

  export type PersonalUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutPositionInput>, Enumerable<PersonalUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutPositionInput>
    createMany?: PersonalCreateManyPositionInputEnvelope
    connect?: Enumerable<PersonalWhereUniqueInput>
  }

  export type PersonalUpdateManyWithoutPositionNestedInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutPositionInput>, Enumerable<PersonalUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<PersonalUpsertWithWhereUniqueWithoutPositionInput>
    createMany?: PersonalCreateManyPositionInputEnvelope
    set?: Enumerable<PersonalWhereUniqueInput>
    disconnect?: Enumerable<PersonalWhereUniqueInput>
    delete?: Enumerable<PersonalWhereUniqueInput>
    connect?: Enumerable<PersonalWhereUniqueInput>
    update?: Enumerable<PersonalUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<PersonalUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<PersonalScalarWhereInput>
  }

  export type ListOrgUpdateOneRequiredWithoutPositionNestedInput = {
    create?: XOR<ListOrgCreateWithoutPositionInput, ListOrgUncheckedCreateWithoutPositionInput>
    connectOrCreate?: ListOrgCreateOrConnectWithoutPositionInput
    upsert?: ListOrgUpsertWithoutPositionInput
    connect?: ListOrgWhereUniqueInput
    update?: XOR<ListOrgUpdateWithoutPositionInput, ListOrgUncheckedUpdateWithoutPositionInput>
  }

  export type PersonalUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutPositionInput>, Enumerable<PersonalUncheckedCreateWithoutPositionInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutPositionInput>
    upsert?: Enumerable<PersonalUpsertWithWhereUniqueWithoutPositionInput>
    createMany?: PersonalCreateManyPositionInputEnvelope
    set?: Enumerable<PersonalWhereUniqueInput>
    disconnect?: Enumerable<PersonalWhereUniqueInput>
    delete?: Enumerable<PersonalWhereUniqueInput>
    connect?: Enumerable<PersonalWhereUniqueInput>
    update?: Enumerable<PersonalUpdateWithWhereUniqueWithoutPositionInput>
    updateMany?: Enumerable<PersonalUpdateManyWithWhereWithoutPositionInput>
    deleteMany?: Enumerable<PersonalScalarWhereInput>
  }

  export type DepartmentCreateNestedManyWithoutListOrgInput = {
    create?: XOR<Enumerable<DepartmentCreateWithoutListOrgInput>, Enumerable<DepartmentUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<DepartmentCreateOrConnectWithoutListOrgInput>
    createMany?: DepartmentCreateManyListOrgInputEnvelope
    connect?: Enumerable<DepartmentWhereUniqueInput>
  }

  export type PersonalCreateNestedManyWithoutListOrgInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutListOrgInput>, Enumerable<PersonalUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutListOrgInput>
    createMany?: PersonalCreateManyListOrgInputEnvelope
    connect?: Enumerable<PersonalWhereUniqueInput>
  }

  export type PositionCreateNestedManyWithoutListOrgInput = {
    create?: XOR<Enumerable<PositionCreateWithoutListOrgInput>, Enumerable<PositionUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutListOrgInput>
    createMany?: PositionCreateManyListOrgInputEnvelope
    connect?: Enumerable<PositionWhereUniqueInput>
  }

  export type DepartmentUncheckedCreateNestedManyWithoutListOrgInput = {
    create?: XOR<Enumerable<DepartmentCreateWithoutListOrgInput>, Enumerable<DepartmentUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<DepartmentCreateOrConnectWithoutListOrgInput>
    createMany?: DepartmentCreateManyListOrgInputEnvelope
    connect?: Enumerable<DepartmentWhereUniqueInput>
  }

  export type PersonalUncheckedCreateNestedManyWithoutListOrgInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutListOrgInput>, Enumerable<PersonalUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutListOrgInput>
    createMany?: PersonalCreateManyListOrgInputEnvelope
    connect?: Enumerable<PersonalWhereUniqueInput>
  }

  export type PositionUncheckedCreateNestedManyWithoutListOrgInput = {
    create?: XOR<Enumerable<PositionCreateWithoutListOrgInput>, Enumerable<PositionUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutListOrgInput>
    createMany?: PositionCreateManyListOrgInputEnvelope
    connect?: Enumerable<PositionWhereUniqueInput>
  }

  export type DepartmentUpdateManyWithoutListOrgNestedInput = {
    create?: XOR<Enumerable<DepartmentCreateWithoutListOrgInput>, Enumerable<DepartmentUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<DepartmentCreateOrConnectWithoutListOrgInput>
    upsert?: Enumerable<DepartmentUpsertWithWhereUniqueWithoutListOrgInput>
    createMany?: DepartmentCreateManyListOrgInputEnvelope
    set?: Enumerable<DepartmentWhereUniqueInput>
    disconnect?: Enumerable<DepartmentWhereUniqueInput>
    delete?: Enumerable<DepartmentWhereUniqueInput>
    connect?: Enumerable<DepartmentWhereUniqueInput>
    update?: Enumerable<DepartmentUpdateWithWhereUniqueWithoutListOrgInput>
    updateMany?: Enumerable<DepartmentUpdateManyWithWhereWithoutListOrgInput>
    deleteMany?: Enumerable<DepartmentScalarWhereInput>
  }

  export type PersonalUpdateManyWithoutListOrgNestedInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutListOrgInput>, Enumerable<PersonalUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutListOrgInput>
    upsert?: Enumerable<PersonalUpsertWithWhereUniqueWithoutListOrgInput>
    createMany?: PersonalCreateManyListOrgInputEnvelope
    set?: Enumerable<PersonalWhereUniqueInput>
    disconnect?: Enumerable<PersonalWhereUniqueInput>
    delete?: Enumerable<PersonalWhereUniqueInput>
    connect?: Enumerable<PersonalWhereUniqueInput>
    update?: Enumerable<PersonalUpdateWithWhereUniqueWithoutListOrgInput>
    updateMany?: Enumerable<PersonalUpdateManyWithWhereWithoutListOrgInput>
    deleteMany?: Enumerable<PersonalScalarWhereInput>
  }

  export type PositionUpdateManyWithoutListOrgNestedInput = {
    create?: XOR<Enumerable<PositionCreateWithoutListOrgInput>, Enumerable<PositionUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutListOrgInput>
    upsert?: Enumerable<PositionUpsertWithWhereUniqueWithoutListOrgInput>
    createMany?: PositionCreateManyListOrgInputEnvelope
    set?: Enumerable<PositionWhereUniqueInput>
    disconnect?: Enumerable<PositionWhereUniqueInput>
    delete?: Enumerable<PositionWhereUniqueInput>
    connect?: Enumerable<PositionWhereUniqueInput>
    update?: Enumerable<PositionUpdateWithWhereUniqueWithoutListOrgInput>
    updateMany?: Enumerable<PositionUpdateManyWithWhereWithoutListOrgInput>
    deleteMany?: Enumerable<PositionScalarWhereInput>
  }

  export type DepartmentUncheckedUpdateManyWithoutListOrgNestedInput = {
    create?: XOR<Enumerable<DepartmentCreateWithoutListOrgInput>, Enumerable<DepartmentUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<DepartmentCreateOrConnectWithoutListOrgInput>
    upsert?: Enumerable<DepartmentUpsertWithWhereUniqueWithoutListOrgInput>
    createMany?: DepartmentCreateManyListOrgInputEnvelope
    set?: Enumerable<DepartmentWhereUniqueInput>
    disconnect?: Enumerable<DepartmentWhereUniqueInput>
    delete?: Enumerable<DepartmentWhereUniqueInput>
    connect?: Enumerable<DepartmentWhereUniqueInput>
    update?: Enumerable<DepartmentUpdateWithWhereUniqueWithoutListOrgInput>
    updateMany?: Enumerable<DepartmentUpdateManyWithWhereWithoutListOrgInput>
    deleteMany?: Enumerable<DepartmentScalarWhereInput>
  }

  export type PersonalUncheckedUpdateManyWithoutListOrgNestedInput = {
    create?: XOR<Enumerable<PersonalCreateWithoutListOrgInput>, Enumerable<PersonalUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<PersonalCreateOrConnectWithoutListOrgInput>
    upsert?: Enumerable<PersonalUpsertWithWhereUniqueWithoutListOrgInput>
    createMany?: PersonalCreateManyListOrgInputEnvelope
    set?: Enumerable<PersonalWhereUniqueInput>
    disconnect?: Enumerable<PersonalWhereUniqueInput>
    delete?: Enumerable<PersonalWhereUniqueInput>
    connect?: Enumerable<PersonalWhereUniqueInput>
    update?: Enumerable<PersonalUpdateWithWhereUniqueWithoutListOrgInput>
    updateMany?: Enumerable<PersonalUpdateManyWithWhereWithoutListOrgInput>
    deleteMany?: Enumerable<PersonalScalarWhereInput>
  }

  export type PositionUncheckedUpdateManyWithoutListOrgNestedInput = {
    create?: XOR<Enumerable<PositionCreateWithoutListOrgInput>, Enumerable<PositionUncheckedCreateWithoutListOrgInput>>
    connectOrCreate?: Enumerable<PositionCreateOrConnectWithoutListOrgInput>
    upsert?: Enumerable<PositionUpsertWithWhereUniqueWithoutListOrgInput>
    createMany?: PositionCreateManyListOrgInputEnvelope
    set?: Enumerable<PositionWhereUniqueInput>
    disconnect?: Enumerable<PositionWhereUniqueInput>
    delete?: Enumerable<PositionWhereUniqueInput>
    connect?: Enumerable<PositionWhereUniqueInput>
    update?: Enumerable<PositionUpdateWithWhereUniqueWithoutListOrgInput>
    updateMany?: Enumerable<PositionUpdateManyWithWhereWithoutListOrgInput>
    deleteMany?: Enumerable<PositionScalarWhereInput>
  }

  export type DepartmentCreateNestedOneWithoutPersonalInput = {
    create?: XOR<DepartmentCreateWithoutPersonalInput, DepartmentUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPersonalInput
    connect?: DepartmentWhereUniqueInput
  }

  export type ListOrgCreateNestedOneWithoutPersonalInput = {
    create?: XOR<ListOrgCreateWithoutPersonalInput, ListOrgUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: ListOrgCreateOrConnectWithoutPersonalInput
    connect?: ListOrgWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutPersonalInput = {
    create?: XOR<PositionCreateWithoutPersonalInput, PositionUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: PositionCreateOrConnectWithoutPersonalInput
    connect?: PositionWhereUniqueInput
  }

  export type SubDepartmentCreateNestedOneWithoutPersonalInput = {
    create?: XOR<SubDepartmentCreateWithoutPersonalInput, SubDepartmentUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: SubDepartmentCreateOrConnectWithoutPersonalInput
    connect?: SubDepartmentWhereUniqueInput
  }

  export type DepartmentUpdateOneRequiredWithoutPersonalNestedInput = {
    create?: XOR<DepartmentCreateWithoutPersonalInput, DepartmentUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPersonalInput
    upsert?: DepartmentUpsertWithoutPersonalInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<DepartmentUpdateWithoutPersonalInput, DepartmentUncheckedUpdateWithoutPersonalInput>
  }

  export type ListOrgUpdateOneRequiredWithoutPersonalNestedInput = {
    create?: XOR<ListOrgCreateWithoutPersonalInput, ListOrgUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: ListOrgCreateOrConnectWithoutPersonalInput
    upsert?: ListOrgUpsertWithoutPersonalInput
    connect?: ListOrgWhereUniqueInput
    update?: XOR<ListOrgUpdateWithoutPersonalInput, ListOrgUncheckedUpdateWithoutPersonalInput>
  }

  export type PositionUpdateOneRequiredWithoutPersonalNestedInput = {
    create?: XOR<PositionCreateWithoutPersonalInput, PositionUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: PositionCreateOrConnectWithoutPersonalInput
    upsert?: PositionUpsertWithoutPersonalInput
    connect?: PositionWhereUniqueInput
    update?: XOR<PositionUpdateWithoutPersonalInput, PositionUncheckedUpdateWithoutPersonalInput>
  }

  export type SubDepartmentUpdateOneWithoutPersonalNestedInput = {
    create?: XOR<SubDepartmentCreateWithoutPersonalInput, SubDepartmentUncheckedCreateWithoutPersonalInput>
    connectOrCreate?: SubDepartmentCreateOrConnectWithoutPersonalInput
    upsert?: SubDepartmentUpsertWithoutPersonalInput
    disconnect?: boolean
    delete?: boolean
    connect?: SubDepartmentWhereUniqueInput
    update?: XOR<SubDepartmentUpdateWithoutPersonalInput, SubDepartmentUncheckedUpdateWithoutPersonalInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    fullName: string
    organization: string
    position: string
    email: string
    phone: string
    photo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutEmployeeInput
    role: RoleCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    fullName: string
    organization: string
    departmentId: string
    position: string
    email: string
    phone: string
    roleId: string
    photo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutEmployeeNestedInput
    role?: RoleUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateWithoutEmployeeInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listOrg: ListOrgCreateNestedOneWithoutDepartmentInput
    personal?: PersonalCreateNestedManyWithoutDepartmentInput
    subdepartment?: SubDepartmentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    listOrgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalUncheckedCreateNestedManyWithoutDepartmentInput
    subdepartment?: SubDepartmentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutEmployeeInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeeInput, DepartmentUncheckedCreateWithoutEmployeeInput>
  }

  export type RoleCreateWithoutEmployeeInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutEmployeeInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutEmployeeInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutEmployeeInput, RoleUncheckedCreateWithoutEmployeeInput>
  }

  export type UserCreateWithoutEmployeeInput = {
    id?: string
    username: string
    password: string
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: string
    username: string
    password: string
    refreshToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type DepartmentUpsertWithoutEmployeeInput = {
    update: XOR<DepartmentUpdateWithoutEmployeeInput, DepartmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DepartmentCreateWithoutEmployeeInput, DepartmentUncheckedCreateWithoutEmployeeInput>
  }

  export type DepartmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listOrg?: ListOrgUpdateOneRequiredWithoutDepartmentNestedInput
    personal?: PersonalUpdateManyWithoutDepartmentNestedInput
    subdepartment?: SubDepartmentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUncheckedUpdateManyWithoutDepartmentNestedInput
    subdepartment?: SubDepartmentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type RoleUpsertWithoutEmployeeInput = {
    update: XOR<RoleUpdateWithoutEmployeeInput, RoleUncheckedUpdateWithoutEmployeeInput>
    create: XOR<RoleCreateWithoutEmployeeInput, RoleUncheckedCreateWithoutEmployeeInput>
  }

  export type RoleUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListOrgCreateWithoutDepartmentInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalCreateNestedManyWithoutListOrgInput
    position?: PositionCreateNestedManyWithoutListOrgInput
  }

  export type ListOrgUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalUncheckedCreateNestedManyWithoutListOrgInput
    position?: PositionUncheckedCreateNestedManyWithoutListOrgInput
  }

  export type ListOrgCreateOrConnectWithoutDepartmentInput = {
    where: ListOrgWhereUniqueInput
    create: XOR<ListOrgCreateWithoutDepartmentInput, ListOrgUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    id?: string
    fullName: string
    organization: string
    position: string
    email: string
    phone: string
    photo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: string
    fullName: string
    organization: string
    position: string
    email: string
    phone: string
    roleId: string
    photo: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: Enumerable<EmployeeCreateManyDepartmentInput>
    skipDuplicates?: boolean
  }

  export type PersonalCreateWithoutDepartmentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listOrg: ListOrgCreateNestedOneWithoutPersonalInput
    position: PositionCreateNestedOneWithoutPersonalInput
    subDepartment?: SubDepartmentCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutDepartmentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    positionId: string
    listOrgId: string
    subDepartmentId?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalCreateOrConnectWithoutDepartmentInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutDepartmentInput, PersonalUncheckedCreateWithoutDepartmentInput>
  }

  export type PersonalCreateManyDepartmentInputEnvelope = {
    data: Enumerable<PersonalCreateManyDepartmentInput>
    skipDuplicates?: boolean
  }

  export type SubDepartmentCreateWithoutDepartmentInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalCreateNestedManyWithoutSubDepartmentInput
  }

  export type SubDepartmentUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalUncheckedCreateNestedManyWithoutSubDepartmentInput
  }

  export type SubDepartmentCreateOrConnectWithoutDepartmentInput = {
    where: SubDepartmentWhereUniqueInput
    create: XOR<SubDepartmentCreateWithoutDepartmentInput, SubDepartmentUncheckedCreateWithoutDepartmentInput>
  }

  export type SubDepartmentCreateManyDepartmentInputEnvelope = {
    data: Enumerable<SubDepartmentCreateManyDepartmentInput>
    skipDuplicates?: boolean
  }

  export type ListOrgUpsertWithoutDepartmentInput = {
    update: XOR<ListOrgUpdateWithoutDepartmentInput, ListOrgUncheckedUpdateWithoutDepartmentInput>
    create: XOR<ListOrgCreateWithoutDepartmentInput, ListOrgUncheckedCreateWithoutDepartmentInput>
  }

  export type ListOrgUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUpdateManyWithoutListOrgNestedInput
    position?: PositionUpdateManyWithoutListOrgNestedInput
  }

  export type ListOrgUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUncheckedUpdateManyWithoutListOrgNestedInput
    position?: PositionUncheckedUpdateManyWithoutListOrgNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: Enumerable<EmployeeScalarWhereInput>
    OR?: Enumerable<EmployeeScalarWhereInput>
    NOT?: Enumerable<EmployeeScalarWhereInput>
    id?: StringFilter | string
    fullName?: StringFilter | string
    organization?: StringFilter | string
    departmentId?: StringFilter | string
    position?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    roleId?: StringFilter | string
    photo?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PersonalUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: PersonalWhereUniqueInput
    update: XOR<PersonalUpdateWithoutDepartmentInput, PersonalUncheckedUpdateWithoutDepartmentInput>
    create: XOR<PersonalCreateWithoutDepartmentInput, PersonalUncheckedCreateWithoutDepartmentInput>
  }

  export type PersonalUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: PersonalWhereUniqueInput
    data: XOR<PersonalUpdateWithoutDepartmentInput, PersonalUncheckedUpdateWithoutDepartmentInput>
  }

  export type PersonalUpdateManyWithWhereWithoutDepartmentInput = {
    where: PersonalScalarWhereInput
    data: XOR<PersonalUpdateManyMutationInput, PersonalUncheckedUpdateManyWithoutPersonalInput>
  }

  export type PersonalScalarWhereInput = {
    AND?: Enumerable<PersonalScalarWhereInput>
    OR?: Enumerable<PersonalScalarWhereInput>
    NOT?: Enumerable<PersonalScalarWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    middleName?: StringNullableFilter | string | null
    lastName?: StringFilter | string
    phone?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    positionId?: StringFilter | string
    listOrgId?: StringFilter | string
    departmentId?: StringFilter | string
    subDepartmentId?: StringNullableFilter | string | null
    creatorId?: StringNullableFilter | string | null
    editorId?: StringNullableFilter | string | null
    removerId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type SubDepartmentUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: SubDepartmentWhereUniqueInput
    update: XOR<SubDepartmentUpdateWithoutDepartmentInput, SubDepartmentUncheckedUpdateWithoutDepartmentInput>
    create: XOR<SubDepartmentCreateWithoutDepartmentInput, SubDepartmentUncheckedCreateWithoutDepartmentInput>
  }

  export type SubDepartmentUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: SubDepartmentWhereUniqueInput
    data: XOR<SubDepartmentUpdateWithoutDepartmentInput, SubDepartmentUncheckedUpdateWithoutDepartmentInput>
  }

  export type SubDepartmentUpdateManyWithWhereWithoutDepartmentInput = {
    where: SubDepartmentScalarWhereInput
    data: XOR<SubDepartmentUpdateManyMutationInput, SubDepartmentUncheckedUpdateManyWithoutSubdepartmentInput>
  }

  export type SubDepartmentScalarWhereInput = {
    AND?: Enumerable<SubDepartmentScalarWhereInput>
    OR?: Enumerable<SubDepartmentScalarWhereInput>
    NOT?: Enumerable<SubDepartmentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringNullableFilter | string | null
    nameru?: StringNullableFilter | string | null
    departmentId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PersonalCreateWithoutSubDepartmentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPersonalInput
    listOrg: ListOrgCreateNestedOneWithoutPersonalInput
    position: PositionCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutSubDepartmentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    positionId: string
    listOrgId: string
    departmentId: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalCreateOrConnectWithoutSubDepartmentInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutSubDepartmentInput, PersonalUncheckedCreateWithoutSubDepartmentInput>
  }

  export type PersonalCreateManySubDepartmentInputEnvelope = {
    data: Enumerable<PersonalCreateManySubDepartmentInput>
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutSubdepartmentInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listOrg: ListOrgCreateNestedOneWithoutDepartmentInput
    employee?: EmployeeCreateNestedManyWithoutDepartmentInput
    personal?: PersonalCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutSubdepartmentInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    listOrgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    personal?: PersonalUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutSubdepartmentInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutSubdepartmentInput, DepartmentUncheckedCreateWithoutSubdepartmentInput>
  }

  export type PersonalUpsertWithWhereUniqueWithoutSubDepartmentInput = {
    where: PersonalWhereUniqueInput
    update: XOR<PersonalUpdateWithoutSubDepartmentInput, PersonalUncheckedUpdateWithoutSubDepartmentInput>
    create: XOR<PersonalCreateWithoutSubDepartmentInput, PersonalUncheckedCreateWithoutSubDepartmentInput>
  }

  export type PersonalUpdateWithWhereUniqueWithoutSubDepartmentInput = {
    where: PersonalWhereUniqueInput
    data: XOR<PersonalUpdateWithoutSubDepartmentInput, PersonalUncheckedUpdateWithoutSubDepartmentInput>
  }

  export type PersonalUpdateManyWithWhereWithoutSubDepartmentInput = {
    where: PersonalScalarWhereInput
    data: XOR<PersonalUpdateManyMutationInput, PersonalUncheckedUpdateManyWithoutPersonalInput>
  }

  export type DepartmentUpsertWithoutSubdepartmentInput = {
    update: XOR<DepartmentUpdateWithoutSubdepartmentInput, DepartmentUncheckedUpdateWithoutSubdepartmentInput>
    create: XOR<DepartmentCreateWithoutSubdepartmentInput, DepartmentUncheckedCreateWithoutSubdepartmentInput>
  }

  export type DepartmentUpdateWithoutSubdepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listOrg?: ListOrgUpdateOneRequiredWithoutDepartmentNestedInput
    employee?: EmployeeUpdateManyWithoutDepartmentNestedInput
    personal?: PersonalUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutSubdepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    personal?: PersonalUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type EmployeeCreateWithoutRoleInput = {
    id?: string
    fullName: string
    organization: string
    position: string
    email: string
    phone: string
    photo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutEmployeeInput
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutRoleInput = {
    id?: string
    fullName: string
    organization: string
    departmentId: string
    position: string
    email: string
    phone: string
    photo: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateOrConnectWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeCreateManyRoleInputEnvelope = {
    data: Enumerable<EmployeeCreateManyRoleInput>
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutRoleInput, EmployeeUncheckedUpdateWithoutRoleInput>
    create: XOR<EmployeeCreateWithoutRoleInput, EmployeeUncheckedCreateWithoutRoleInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutRoleInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutRoleInput, EmployeeUncheckedUpdateWithoutRoleInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutRoleInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PersonalCreateWithoutPositionInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPersonalInput
    listOrg: ListOrgCreateNestedOneWithoutPersonalInput
    subDepartment?: SubDepartmentCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutPositionInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    listOrgId: string
    departmentId: string
    subDepartmentId?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalCreateOrConnectWithoutPositionInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutPositionInput, PersonalUncheckedCreateWithoutPositionInput>
  }

  export type PersonalCreateManyPositionInputEnvelope = {
    data: Enumerable<PersonalCreateManyPositionInput>
    skipDuplicates?: boolean
  }

  export type ListOrgCreateWithoutPositionInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedManyWithoutListOrgInput
    personal?: PersonalCreateNestedManyWithoutListOrgInput
  }

  export type ListOrgUncheckedCreateWithoutPositionInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentUncheckedCreateNestedManyWithoutListOrgInput
    personal?: PersonalUncheckedCreateNestedManyWithoutListOrgInput
  }

  export type ListOrgCreateOrConnectWithoutPositionInput = {
    where: ListOrgWhereUniqueInput
    create: XOR<ListOrgCreateWithoutPositionInput, ListOrgUncheckedCreateWithoutPositionInput>
  }

  export type PersonalUpsertWithWhereUniqueWithoutPositionInput = {
    where: PersonalWhereUniqueInput
    update: XOR<PersonalUpdateWithoutPositionInput, PersonalUncheckedUpdateWithoutPositionInput>
    create: XOR<PersonalCreateWithoutPositionInput, PersonalUncheckedCreateWithoutPositionInput>
  }

  export type PersonalUpdateWithWhereUniqueWithoutPositionInput = {
    where: PersonalWhereUniqueInput
    data: XOR<PersonalUpdateWithoutPositionInput, PersonalUncheckedUpdateWithoutPositionInput>
  }

  export type PersonalUpdateManyWithWhereWithoutPositionInput = {
    where: PersonalScalarWhereInput
    data: XOR<PersonalUpdateManyMutationInput, PersonalUncheckedUpdateManyWithoutPersonalInput>
  }

  export type ListOrgUpsertWithoutPositionInput = {
    update: XOR<ListOrgUpdateWithoutPositionInput, ListOrgUncheckedUpdateWithoutPositionInput>
    create: XOR<ListOrgCreateWithoutPositionInput, ListOrgUncheckedCreateWithoutPositionInput>
  }

  export type ListOrgUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateManyWithoutListOrgNestedInput
    personal?: PersonalUpdateManyWithoutListOrgNestedInput
  }

  export type ListOrgUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUncheckedUpdateManyWithoutListOrgNestedInput
    personal?: PersonalUncheckedUpdateManyWithoutListOrgNestedInput
  }

  export type DepartmentCreateWithoutListOrgInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeCreateNestedManyWithoutDepartmentInput
    personal?: PersonalCreateNestedManyWithoutDepartmentInput
    subdepartment?: SubDepartmentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutListOrgInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    personal?: PersonalUncheckedCreateNestedManyWithoutDepartmentInput
    subdepartment?: SubDepartmentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutListOrgInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutListOrgInput, DepartmentUncheckedCreateWithoutListOrgInput>
  }

  export type DepartmentCreateManyListOrgInputEnvelope = {
    data: Enumerable<DepartmentCreateManyListOrgInput>
    skipDuplicates?: boolean
  }

  export type PersonalCreateWithoutListOrgInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutPersonalInput
    position: PositionCreateNestedOneWithoutPersonalInput
    subDepartment?: SubDepartmentCreateNestedOneWithoutPersonalInput
  }

  export type PersonalUncheckedCreateWithoutListOrgInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    positionId: string
    departmentId: string
    subDepartmentId?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalCreateOrConnectWithoutListOrgInput = {
    where: PersonalWhereUniqueInput
    create: XOR<PersonalCreateWithoutListOrgInput, PersonalUncheckedCreateWithoutListOrgInput>
  }

  export type PersonalCreateManyListOrgInputEnvelope = {
    data: Enumerable<PersonalCreateManyListOrgInput>
    skipDuplicates?: boolean
  }

  export type PositionCreateWithoutListOrgInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutListOrgInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    personal?: PersonalUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutListOrgInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutListOrgInput, PositionUncheckedCreateWithoutListOrgInput>
  }

  export type PositionCreateManyListOrgInputEnvelope = {
    data: Enumerable<PositionCreateManyListOrgInput>
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithWhereUniqueWithoutListOrgInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutListOrgInput, DepartmentUncheckedUpdateWithoutListOrgInput>
    create: XOR<DepartmentCreateWithoutListOrgInput, DepartmentUncheckedCreateWithoutListOrgInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutListOrgInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutListOrgInput, DepartmentUncheckedUpdateWithoutListOrgInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutListOrgInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: Enumerable<DepartmentScalarWhereInput>
    OR?: Enumerable<DepartmentScalarWhereInput>
    NOT?: Enumerable<DepartmentScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringNullableFilter | string | null
    nameru?: StringNullableFilter | string | null
    listOrgId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PersonalUpsertWithWhereUniqueWithoutListOrgInput = {
    where: PersonalWhereUniqueInput
    update: XOR<PersonalUpdateWithoutListOrgInput, PersonalUncheckedUpdateWithoutListOrgInput>
    create: XOR<PersonalCreateWithoutListOrgInput, PersonalUncheckedCreateWithoutListOrgInput>
  }

  export type PersonalUpdateWithWhereUniqueWithoutListOrgInput = {
    where: PersonalWhereUniqueInput
    data: XOR<PersonalUpdateWithoutListOrgInput, PersonalUncheckedUpdateWithoutListOrgInput>
  }

  export type PersonalUpdateManyWithWhereWithoutListOrgInput = {
    where: PersonalScalarWhereInput
    data: XOR<PersonalUpdateManyMutationInput, PersonalUncheckedUpdateManyWithoutPersonalInput>
  }

  export type PositionUpsertWithWhereUniqueWithoutListOrgInput = {
    where: PositionWhereUniqueInput
    update: XOR<PositionUpdateWithoutListOrgInput, PositionUncheckedUpdateWithoutListOrgInput>
    create: XOR<PositionCreateWithoutListOrgInput, PositionUncheckedCreateWithoutListOrgInput>
  }

  export type PositionUpdateWithWhereUniqueWithoutListOrgInput = {
    where: PositionWhereUniqueInput
    data: XOR<PositionUpdateWithoutListOrgInput, PositionUncheckedUpdateWithoutListOrgInput>
  }

  export type PositionUpdateManyWithWhereWithoutListOrgInput = {
    where: PositionScalarWhereInput
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyWithoutPositionInput>
  }

  export type PositionScalarWhereInput = {
    AND?: Enumerable<PositionScalarWhereInput>
    OR?: Enumerable<PositionScalarWhereInput>
    NOT?: Enumerable<PositionScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    nameuz?: StringNullableFilter | string | null
    nameru?: StringNullableFilter | string | null
    listOrgId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type DepartmentCreateWithoutPersonalInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listOrg: ListOrgCreateNestedOneWithoutDepartmentInput
    employee?: EmployeeCreateNestedManyWithoutDepartmentInput
    subdepartment?: SubDepartmentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutPersonalInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    listOrgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    subdepartment?: SubDepartmentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutPersonalInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPersonalInput, DepartmentUncheckedCreateWithoutPersonalInput>
  }

  export type ListOrgCreateWithoutPersonalInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedManyWithoutListOrgInput
    position?: PositionCreateNestedManyWithoutListOrgInput
  }

  export type ListOrgUncheckedCreateWithoutPersonalInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentUncheckedCreateNestedManyWithoutListOrgInput
    position?: PositionUncheckedCreateNestedManyWithoutListOrgInput
  }

  export type ListOrgCreateOrConnectWithoutPersonalInput = {
    where: ListOrgWhereUniqueInput
    create: XOR<ListOrgCreateWithoutPersonalInput, ListOrgUncheckedCreateWithoutPersonalInput>
  }

  export type PositionCreateWithoutPersonalInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listOrg: ListOrgCreateNestedOneWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutPersonalInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    listOrgId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionCreateOrConnectWithoutPersonalInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutPersonalInput, PositionUncheckedCreateWithoutPersonalInput>
  }

  export type SubDepartmentCreateWithoutPersonalInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutSubdepartmentInput
  }

  export type SubDepartmentUncheckedCreateWithoutPersonalInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    departmentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubDepartmentCreateOrConnectWithoutPersonalInput = {
    where: SubDepartmentWhereUniqueInput
    create: XOR<SubDepartmentCreateWithoutPersonalInput, SubDepartmentUncheckedCreateWithoutPersonalInput>
  }

  export type DepartmentUpsertWithoutPersonalInput = {
    update: XOR<DepartmentUpdateWithoutPersonalInput, DepartmentUncheckedUpdateWithoutPersonalInput>
    create: XOR<DepartmentCreateWithoutPersonalInput, DepartmentUncheckedCreateWithoutPersonalInput>
  }

  export type DepartmentUpdateWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listOrg?: ListOrgUpdateOneRequiredWithoutDepartmentNestedInput
    employee?: EmployeeUpdateManyWithoutDepartmentNestedInput
    subdepartment?: SubDepartmentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    subdepartment?: SubDepartmentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ListOrgUpsertWithoutPersonalInput = {
    update: XOR<ListOrgUpdateWithoutPersonalInput, ListOrgUncheckedUpdateWithoutPersonalInput>
    create: XOR<ListOrgCreateWithoutPersonalInput, ListOrgUncheckedCreateWithoutPersonalInput>
  }

  export type ListOrgUpdateWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateManyWithoutListOrgNestedInput
    position?: PositionUpdateManyWithoutListOrgNestedInput
  }

  export type ListOrgUncheckedUpdateWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUncheckedUpdateManyWithoutListOrgNestedInput
    position?: PositionUncheckedUpdateManyWithoutListOrgNestedInput
  }

  export type PositionUpsertWithoutPersonalInput = {
    update: XOR<PositionUpdateWithoutPersonalInput, PositionUncheckedUpdateWithoutPersonalInput>
    create: XOR<PositionCreateWithoutPersonalInput, PositionUncheckedCreateWithoutPersonalInput>
  }

  export type PositionUpdateWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listOrg?: ListOrgUpdateOneRequiredWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDepartmentUpsertWithoutPersonalInput = {
    update: XOR<SubDepartmentUpdateWithoutPersonalInput, SubDepartmentUncheckedUpdateWithoutPersonalInput>
    create: XOR<SubDepartmentCreateWithoutPersonalInput, SubDepartmentUncheckedCreateWithoutPersonalInput>
  }

  export type SubDepartmentUpdateWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutSubdepartmentNestedInput
  }

  export type SubDepartmentUncheckedUpdateWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: string
    fullName: string
    organization: string
    position: string
    email: string
    phone: string
    roleId: string
    photo: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalCreateManyDepartmentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    positionId: string
    listOrgId: string
    subDepartmentId?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubDepartmentCreateManyDepartmentInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listOrg?: ListOrgUpdateOneRequiredWithoutPersonalNestedInput
    position?: PositionUpdateOneRequiredWithoutPersonalNestedInput
    subDepartment?: SubDepartmentUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: StringFieldUpdateOperationsInput | string
    listOrgId?: StringFieldUpdateOperationsInput | string
    subDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalUncheckedUpdateManyWithoutPersonalInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: StringFieldUpdateOperationsInput | string
    listOrgId?: StringFieldUpdateOperationsInput | string
    subDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubDepartmentUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUpdateManyWithoutSubDepartmentNestedInput
  }

  export type SubDepartmentUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUncheckedUpdateManyWithoutSubDepartmentNestedInput
  }

  export type SubDepartmentUncheckedUpdateManyWithoutSubdepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalCreateManySubDepartmentInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    positionId: string
    listOrgId: string
    departmentId: string
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalUpdateWithoutSubDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPersonalNestedInput
    listOrg?: ListOrgUpdateOneRequiredWithoutPersonalNestedInput
    position?: PositionUpdateOneRequiredWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutSubDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: StringFieldUpdateOperationsInput | string
    listOrgId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyRoleInput = {
    id?: string
    fullName: string
    organization: string
    departmentId: string
    position: string
    email: string
    phone: string
    photo: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutEmployeeNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    organization?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    photo?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalCreateManyPositionInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    listOrgId: string
    departmentId: string
    subDepartmentId?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPersonalNestedInput
    listOrg?: ListOrgUpdateOneRequiredWithoutPersonalNestedInput
    subDepartment?: SubDepartmentUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    listOrgId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    subDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyListOrgInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PersonalCreateManyListOrgInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    phone?: string | null
    email?: string | null
    positionId: string
    departmentId: string
    subDepartmentId?: string | null
    creatorId?: string | null
    editorId?: string | null
    removerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionCreateManyListOrgInput = {
    id?: string
    name: string
    nameuz?: string | null
    nameru?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateWithoutListOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateManyWithoutDepartmentNestedInput
    personal?: PersonalUpdateManyWithoutDepartmentNestedInput
    subdepartment?: SubDepartmentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutListOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    personal?: PersonalUncheckedUpdateManyWithoutDepartmentNestedInput
    subdepartment?: SubDepartmentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonalUpdateWithoutListOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutPersonalNestedInput
    position?: PositionUpdateOneRequiredWithoutPersonalNestedInput
    subDepartment?: SubDepartmentUpdateOneWithoutPersonalNestedInput
  }

  export type PersonalUncheckedUpdateWithoutListOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    subDepartmentId?: NullableStringFieldUpdateOperationsInput | string | null
    creatorId?: NullableStringFieldUpdateOperationsInput | string | null
    editorId?: NullableStringFieldUpdateOperationsInput | string | null
    removerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUpdateWithoutListOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutListOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: PersonalUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameuz?: NullableStringFieldUpdateOperationsInput | string | null
    nameru?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}